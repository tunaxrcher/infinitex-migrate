
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model admin_permissions
 * 
 */
export type admin_permissions = $Result.DefaultSelection<Prisma.$admin_permissionsPayload>
/**
 * Model admin_sessions
 * 
 */
export type admin_sessions = $Result.DefaultSelection<Prisma.$admin_sessionsPayload>
/**
 * Model admins
 * 
 */
export type admins = $Result.DefaultSelection<Prisma.$adminsPayload>
/**
 * Model agent_customers
 * 
 */
export type agent_customers = $Result.DefaultSelection<Prisma.$agent_customersPayload>
/**
 * Model audit_logs
 * 
 */
export type audit_logs = $Result.DefaultSelection<Prisma.$audit_logsPayload>
/**
 * Model banners
 * 
 */
export type banners = $Result.DefaultSelection<Prisma.$bannersPayload>
/**
 * Model coin_transactions
 * 
 */
export type coin_transactions = $Result.DefaultSelection<Prisma.$coin_transactionsPayload>
/**
 * Model loan_applications
 * 
 */
export type loan_applications = $Result.DefaultSelection<Prisma.$loan_applicationsPayload>
/**
 * Model loan_installments
 * 
 */
export type loan_installments = $Result.DefaultSelection<Prisma.$loan_installmentsPayload>
/**
 * Model loans
 * 
 */
export type loans = $Result.DefaultSelection<Prisma.$loansPayload>
/**
 * Model notifications
 * 
 */
export type notifications = $Result.DefaultSelection<Prisma.$notificationsPayload>
/**
 * Model payments
 * 
 */
export type payments = $Result.DefaultSelection<Prisma.$paymentsPayload>
/**
 * Model privileges
 * 
 */
export type privileges = $Result.DefaultSelection<Prisma.$privilegesPayload>
/**
 * Model reward_redemptions
 * 
 */
export type reward_redemptions = $Result.DefaultSelection<Prisma.$reward_redemptionsPayload>
/**
 * Model rewards
 * 
 */
export type rewards = $Result.DefaultSelection<Prisma.$rewardsPayload>
/**
 * Model sessions
 * 
 */
export type sessions = $Result.DefaultSelection<Prisma.$sessionsPayload>
/**
 * Model system_config
 * 
 */
export type system_config = $Result.DefaultSelection<Prisma.$system_configPayload>
/**
 * Model documents
 * 
 */
export type documents = $Result.DefaultSelection<Prisma.$documentsPayload>
/**
 * Model document_title_lists
 * 
 */
export type document_title_lists = $Result.DefaultSelection<Prisma.$document_title_listsPayload>
/**
 * Model land_accounts
 * 
 */
export type land_accounts = $Result.DefaultSelection<Prisma.$land_accountsPayload>
/**
 * Model land_account_logs
 * 
 */
export type land_account_logs = $Result.DefaultSelection<Prisma.$land_account_logsPayload>
/**
 * Model land_account_reports
 * 
 */
export type land_account_reports = $Result.DefaultSelection<Prisma.$land_account_reportsPayload>
/**
 * Model user_profiles
 * 
 */
export type user_profiles = $Result.DefaultSelection<Prisma.$user_profilesPayload>
/**
 * Model users
 * 
 */
export type users = $Result.DefaultSelection<Prisma.$usersPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const admin_permissions_permission: {
  VIEW_APPLICATIONS: 'VIEW_APPLICATIONS',
  APPROVE_APPLICATIONS: 'APPROVE_APPLICATIONS',
  REJECT_APPLICATIONS: 'REJECT_APPLICATIONS',
  VIEW_LOANS: 'VIEW_LOANS',
  CREATE_LOANS: 'CREATE_LOANS',
  UPDATE_LOANS: 'UPDATE_LOANS',
  DELETE_LOANS: 'DELETE_LOANS',
  VIEW_USERS: 'VIEW_USERS',
  CREATE_USERS: 'CREATE_USERS',
  UPDATE_USERS: 'UPDATE_USERS',
  DELETE_USERS: 'DELETE_USERS',
  MANAGE_AGENTS: 'MANAGE_AGENTS',
  VIEW_PAYMENTS: 'VIEW_PAYMENTS',
  PROCESS_PAYMENTS: 'PROCESS_PAYMENTS',
  REFUND_PAYMENTS: 'REFUND_PAYMENTS',
  MANAGE_BANNERS: 'MANAGE_BANNERS',
  MANAGE_PRIVILEGES: 'MANAGE_PRIVILEGES',
  MANAGE_REWARDS: 'MANAGE_REWARDS',
  MANAGE_SYSTEM_CONFIG: 'MANAGE_SYSTEM_CONFIG',
  VIEW_AUDIT_LOGS: 'VIEW_AUDIT_LOGS',
  VIEW_REPORTS: 'VIEW_REPORTS',
  EXPORT_DATA: 'EXPORT_DATA'
};

export type admin_permissions_permission = (typeof admin_permissions_permission)[keyof typeof admin_permissions_permission]


export const coin_transactions_type: {
  EARNED_SIGNUP: 'EARNED_SIGNUP',
  EARNED_ON_TIME_PAYMENT: 'EARNED_ON_TIME_PAYMENT',
  EARNED_DAILY_TASK: 'EARNED_DAILY_TASK',
  EARNED_PROMOTION: 'EARNED_PROMOTION',
  REDEEMED_REWARD: 'REDEEMED_REWARD',
  EXPIRED: 'EXPIRED'
};

export type coin_transactions_type = (typeof coin_transactions_type)[keyof typeof coin_transactions_type]


export const notifications_type: {
  PAYMENT_DUE: 'PAYMENT_DUE',
  PAYMENT_SUCCESS: 'PAYMENT_SUCCESS',
  PAYMENT_FAILED: 'PAYMENT_FAILED',
  LOAN_APPROVED: 'LOAN_APPROVED',
  LOAN_REJECTED: 'LOAN_REJECTED',
  SYSTEM_ANNOUNCEMENT: 'SYSTEM_ANNOUNCEMENT',
  PROMOTION: 'PROMOTION'
};

export type notifications_type = (typeof notifications_type)[keyof typeof notifications_type]


export const loan_applications_loanType: {
  HOUSE_LAND_MORTGAGE: 'HOUSE_LAND_MORTGAGE',
  CAR_REGISTRATION: 'CAR_REGISTRATION',
  FINX_PLUS: 'FINX_PLUS'
};

export type loan_applications_loanType = (typeof loan_applications_loanType)[keyof typeof loan_applications_loanType]


export const loan_applications_status: {
  DRAFT: 'DRAFT',
  SUBMITTED: 'SUBMITTED',
  UNDER_REVIEW: 'UNDER_REVIEW',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  CANCELLED: 'CANCELLED'
};

export type loan_applications_status = (typeof loan_applications_status)[keyof typeof loan_applications_status]


export const reward_redemptions_status: {
  PENDING: 'PENDING',
  PROCESSING: 'PROCESSING',
  DELIVERED: 'DELIVERED',
  CANCELLED: 'CANCELLED'
};

export type reward_redemptions_status = (typeof reward_redemptions_status)[keyof typeof reward_redemptions_status]


export const admins_role: {
  SUPER_ADMIN: 'SUPER_ADMIN',
  LOAN_OFFICER: 'LOAN_OFFICER',
  CUSTOMER_SERVICE: 'CUSTOMER_SERVICE',
  FINANCE: 'FINANCE',
  CONTENT_MANAGER: 'CONTENT_MANAGER'
};

export type admins_role = (typeof admins_role)[keyof typeof admins_role]


export const loans_loanType: {
  HOUSE_LAND_MORTGAGE: 'HOUSE_LAND_MORTGAGE',
  CAR_REGISTRATION: 'CAR_REGISTRATION',
  FINX_PLUS: 'FINX_PLUS'
};

export type loans_loanType = (typeof loans_loanType)[keyof typeof loans_loanType]


export const payments_paymentMethod: {
  CASH: 'CASH',
  QR_CODE: 'QR_CODE',
  BARCODE: 'BARCODE',
  INTERNET_BANKING: 'INTERNET_BANKING',
  BANK_TRANSFER: 'BANK_TRANSFER'
};

export type payments_paymentMethod = (typeof payments_paymentMethod)[keyof typeof payments_paymentMethod]


export const loans_status: {
  ACTIVE: 'ACTIVE',
  COMPLETED: 'COMPLETED',
  DEFAULTED: 'DEFAULTED',
  CANCELLED: 'CANCELLED'
};

export type loans_status = (typeof loans_status)[keyof typeof loans_status]


export const payments_status: {
  PENDING: 'PENDING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  CANCELLED: 'CANCELLED'
};

export type payments_status = (typeof payments_status)[keyof typeof payments_status]


export const users_userType: {
  CUSTOMER: 'CUSTOMER',
  AGENT: 'AGENT'
};

export type users_userType = (typeof users_userType)[keyof typeof users_userType]


export const documents_docType: {
  RECEIPT: 'RECEIPT',
  PAYMENT_VOUCHER: 'PAYMENT_VOUCHER',
  DISCOUNT_NOTE: 'DISCOUNT_NOTE',
  EXPENSE: 'EXPENSE'
};

export type documents_docType = (typeof documents_docType)[keyof typeof documents_docType]


export const document_title_lists_docType: {
  RECEIPT: 'RECEIPT',
  PAYMENT_VOUCHER: 'PAYMENT_VOUCHER'
};

export type document_title_lists_docType = (typeof document_title_lists_docType)[keyof typeof document_title_lists_docType]

}

export type admin_permissions_permission = $Enums.admin_permissions_permission

export const admin_permissions_permission: typeof $Enums.admin_permissions_permission

export type coin_transactions_type = $Enums.coin_transactions_type

export const coin_transactions_type: typeof $Enums.coin_transactions_type

export type notifications_type = $Enums.notifications_type

export const notifications_type: typeof $Enums.notifications_type

export type loan_applications_loanType = $Enums.loan_applications_loanType

export const loan_applications_loanType: typeof $Enums.loan_applications_loanType

export type loan_applications_status = $Enums.loan_applications_status

export const loan_applications_status: typeof $Enums.loan_applications_status

export type reward_redemptions_status = $Enums.reward_redemptions_status

export const reward_redemptions_status: typeof $Enums.reward_redemptions_status

export type admins_role = $Enums.admins_role

export const admins_role: typeof $Enums.admins_role

export type loans_loanType = $Enums.loans_loanType

export const loans_loanType: typeof $Enums.loans_loanType

export type payments_paymentMethod = $Enums.payments_paymentMethod

export const payments_paymentMethod: typeof $Enums.payments_paymentMethod

export type loans_status = $Enums.loans_status

export const loans_status: typeof $Enums.loans_status

export type payments_status = $Enums.payments_status

export const payments_status: typeof $Enums.payments_status

export type users_userType = $Enums.users_userType

export const users_userType: typeof $Enums.users_userType

export type documents_docType = $Enums.documents_docType

export const documents_docType: typeof $Enums.documents_docType

export type document_title_lists_docType = $Enums.document_title_lists_docType

export const document_title_lists_docType: typeof $Enums.document_title_lists_docType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Admin_permissions
 * const admin_permissions = await prisma.admin_permissions.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Admin_permissions
   * const admin_permissions = await prisma.admin_permissions.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.admin_permissions`: Exposes CRUD operations for the **admin_permissions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admin_permissions
    * const admin_permissions = await prisma.admin_permissions.findMany()
    * ```
    */
  get admin_permissions(): Prisma.admin_permissionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.admin_sessions`: Exposes CRUD operations for the **admin_sessions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admin_sessions
    * const admin_sessions = await prisma.admin_sessions.findMany()
    * ```
    */
  get admin_sessions(): Prisma.admin_sessionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.admins`: Exposes CRUD operations for the **admins** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admins
    * const admins = await prisma.admins.findMany()
    * ```
    */
  get admins(): Prisma.adminsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agent_customers`: Exposes CRUD operations for the **agent_customers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Agent_customers
    * const agent_customers = await prisma.agent_customers.findMany()
    * ```
    */
  get agent_customers(): Prisma.agent_customersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.audit_logs`: Exposes CRUD operations for the **audit_logs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Audit_logs
    * const audit_logs = await prisma.audit_logs.findMany()
    * ```
    */
  get audit_logs(): Prisma.audit_logsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.banners`: Exposes CRUD operations for the **banners** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Banners
    * const banners = await prisma.banners.findMany()
    * ```
    */
  get banners(): Prisma.bannersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.coin_transactions`: Exposes CRUD operations for the **coin_transactions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Coin_transactions
    * const coin_transactions = await prisma.coin_transactions.findMany()
    * ```
    */
  get coin_transactions(): Prisma.coin_transactionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.loan_applications`: Exposes CRUD operations for the **loan_applications** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Loan_applications
    * const loan_applications = await prisma.loan_applications.findMany()
    * ```
    */
  get loan_applications(): Prisma.loan_applicationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.loan_installments`: Exposes CRUD operations for the **loan_installments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Loan_installments
    * const loan_installments = await prisma.loan_installments.findMany()
    * ```
    */
  get loan_installments(): Prisma.loan_installmentsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.loans`: Exposes CRUD operations for the **loans** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Loans
    * const loans = await prisma.loans.findMany()
    * ```
    */
  get loans(): Prisma.loansDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notifications`: Exposes CRUD operations for the **notifications** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notifications.findMany()
    * ```
    */
  get notifications(): Prisma.notificationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payments`: Exposes CRUD operations for the **payments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payments.findMany()
    * ```
    */
  get payments(): Prisma.paymentsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.privileges`: Exposes CRUD operations for the **privileges** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Privileges
    * const privileges = await prisma.privileges.findMany()
    * ```
    */
  get privileges(): Prisma.privilegesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reward_redemptions`: Exposes CRUD operations for the **reward_redemptions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reward_redemptions
    * const reward_redemptions = await prisma.reward_redemptions.findMany()
    * ```
    */
  get reward_redemptions(): Prisma.reward_redemptionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rewards`: Exposes CRUD operations for the **rewards** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rewards
    * const rewards = await prisma.rewards.findMany()
    * ```
    */
  get rewards(): Prisma.rewardsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sessions`: Exposes CRUD operations for the **sessions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.sessions.findMany()
    * ```
    */
  get sessions(): Prisma.sessionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.system_config`: Exposes CRUD operations for the **system_config** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more System_configs
    * const system_configs = await prisma.system_config.findMany()
    * ```
    */
  get system_config(): Prisma.system_configDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.documents`: Exposes CRUD operations for the **documents** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Documents
    * const documents = await prisma.documents.findMany()
    * ```
    */
  get documents(): Prisma.documentsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.document_title_lists`: Exposes CRUD operations for the **document_title_lists** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Document_title_lists
    * const document_title_lists = await prisma.document_title_lists.findMany()
    * ```
    */
  get document_title_lists(): Prisma.document_title_listsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.land_accounts`: Exposes CRUD operations for the **land_accounts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Land_accounts
    * const land_accounts = await prisma.land_accounts.findMany()
    * ```
    */
  get land_accounts(): Prisma.land_accountsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.land_account_logs`: Exposes CRUD operations for the **land_account_logs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Land_account_logs
    * const land_account_logs = await prisma.land_account_logs.findMany()
    * ```
    */
  get land_account_logs(): Prisma.land_account_logsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.land_account_reports`: Exposes CRUD operations for the **land_account_reports** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Land_account_reports
    * const land_account_reports = await prisma.land_account_reports.findMany()
    * ```
    */
  get land_account_reports(): Prisma.land_account_reportsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user_profiles`: Exposes CRUD operations for the **user_profiles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_profiles
    * const user_profiles = await prisma.user_profiles.findMany()
    * ```
    */
  get user_profiles(): Prisma.user_profilesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.users`: Exposes CRUD operations for the **users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.usersDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.0
   * Query Engine version: 2ba551f319ab1df4bc874a89965d8b3641056773
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    admin_permissions: 'admin_permissions',
    admin_sessions: 'admin_sessions',
    admins: 'admins',
    agent_customers: 'agent_customers',
    audit_logs: 'audit_logs',
    banners: 'banners',
    coin_transactions: 'coin_transactions',
    loan_applications: 'loan_applications',
    loan_installments: 'loan_installments',
    loans: 'loans',
    notifications: 'notifications',
    payments: 'payments',
    privileges: 'privileges',
    reward_redemptions: 'reward_redemptions',
    rewards: 'rewards',
    sessions: 'sessions',
    system_config: 'system_config',
    documents: 'documents',
    document_title_lists: 'document_title_lists',
    land_accounts: 'land_accounts',
    land_account_logs: 'land_account_logs',
    land_account_reports: 'land_account_reports',
    user_profiles: 'user_profiles',
    users: 'users'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "admin_permissions" | "admin_sessions" | "admins" | "agent_customers" | "audit_logs" | "banners" | "coin_transactions" | "loan_applications" | "loan_installments" | "loans" | "notifications" | "payments" | "privileges" | "reward_redemptions" | "rewards" | "sessions" | "system_config" | "documents" | "document_title_lists" | "land_accounts" | "land_account_logs" | "land_account_reports" | "user_profiles" | "users"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      admin_permissions: {
        payload: Prisma.$admin_permissionsPayload<ExtArgs>
        fields: Prisma.admin_permissionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.admin_permissionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_permissionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.admin_permissionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_permissionsPayload>
          }
          findFirst: {
            args: Prisma.admin_permissionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_permissionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.admin_permissionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_permissionsPayload>
          }
          findMany: {
            args: Prisma.admin_permissionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_permissionsPayload>[]
          }
          create: {
            args: Prisma.admin_permissionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_permissionsPayload>
          }
          createMany: {
            args: Prisma.admin_permissionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.admin_permissionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_permissionsPayload>
          }
          update: {
            args: Prisma.admin_permissionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_permissionsPayload>
          }
          deleteMany: {
            args: Prisma.admin_permissionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.admin_permissionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.admin_permissionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_permissionsPayload>
          }
          aggregate: {
            args: Prisma.Admin_permissionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmin_permissions>
          }
          groupBy: {
            args: Prisma.admin_permissionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Admin_permissionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.admin_permissionsCountArgs<ExtArgs>
            result: $Utils.Optional<Admin_permissionsCountAggregateOutputType> | number
          }
        }
      }
      admin_sessions: {
        payload: Prisma.$admin_sessionsPayload<ExtArgs>
        fields: Prisma.admin_sessionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.admin_sessionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_sessionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.admin_sessionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_sessionsPayload>
          }
          findFirst: {
            args: Prisma.admin_sessionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_sessionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.admin_sessionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_sessionsPayload>
          }
          findMany: {
            args: Prisma.admin_sessionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_sessionsPayload>[]
          }
          create: {
            args: Prisma.admin_sessionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_sessionsPayload>
          }
          createMany: {
            args: Prisma.admin_sessionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.admin_sessionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_sessionsPayload>
          }
          update: {
            args: Prisma.admin_sessionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_sessionsPayload>
          }
          deleteMany: {
            args: Prisma.admin_sessionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.admin_sessionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.admin_sessionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_sessionsPayload>
          }
          aggregate: {
            args: Prisma.Admin_sessionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmin_sessions>
          }
          groupBy: {
            args: Prisma.admin_sessionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Admin_sessionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.admin_sessionsCountArgs<ExtArgs>
            result: $Utils.Optional<Admin_sessionsCountAggregateOutputType> | number
          }
        }
      }
      admins: {
        payload: Prisma.$adminsPayload<ExtArgs>
        fields: Prisma.adminsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.adminsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.adminsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminsPayload>
          }
          findFirst: {
            args: Prisma.adminsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.adminsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminsPayload>
          }
          findMany: {
            args: Prisma.adminsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminsPayload>[]
          }
          create: {
            args: Prisma.adminsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminsPayload>
          }
          createMany: {
            args: Prisma.adminsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.adminsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminsPayload>
          }
          update: {
            args: Prisma.adminsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminsPayload>
          }
          deleteMany: {
            args: Prisma.adminsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.adminsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.adminsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminsPayload>
          }
          aggregate: {
            args: Prisma.AdminsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmins>
          }
          groupBy: {
            args: Prisma.adminsGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminsGroupByOutputType>[]
          }
          count: {
            args: Prisma.adminsCountArgs<ExtArgs>
            result: $Utils.Optional<AdminsCountAggregateOutputType> | number
          }
        }
      }
      agent_customers: {
        payload: Prisma.$agent_customersPayload<ExtArgs>
        fields: Prisma.agent_customersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.agent_customersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agent_customersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.agent_customersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agent_customersPayload>
          }
          findFirst: {
            args: Prisma.agent_customersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agent_customersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.agent_customersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agent_customersPayload>
          }
          findMany: {
            args: Prisma.agent_customersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agent_customersPayload>[]
          }
          create: {
            args: Prisma.agent_customersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agent_customersPayload>
          }
          createMany: {
            args: Prisma.agent_customersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.agent_customersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agent_customersPayload>
          }
          update: {
            args: Prisma.agent_customersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agent_customersPayload>
          }
          deleteMany: {
            args: Prisma.agent_customersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.agent_customersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.agent_customersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agent_customersPayload>
          }
          aggregate: {
            args: Prisma.Agent_customersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgent_customers>
          }
          groupBy: {
            args: Prisma.agent_customersGroupByArgs<ExtArgs>
            result: $Utils.Optional<Agent_customersGroupByOutputType>[]
          }
          count: {
            args: Prisma.agent_customersCountArgs<ExtArgs>
            result: $Utils.Optional<Agent_customersCountAggregateOutputType> | number
          }
        }
      }
      audit_logs: {
        payload: Prisma.$audit_logsPayload<ExtArgs>
        fields: Prisma.audit_logsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.audit_logsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_logsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.audit_logsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_logsPayload>
          }
          findFirst: {
            args: Prisma.audit_logsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_logsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.audit_logsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_logsPayload>
          }
          findMany: {
            args: Prisma.audit_logsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_logsPayload>[]
          }
          create: {
            args: Prisma.audit_logsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_logsPayload>
          }
          createMany: {
            args: Prisma.audit_logsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.audit_logsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_logsPayload>
          }
          update: {
            args: Prisma.audit_logsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_logsPayload>
          }
          deleteMany: {
            args: Prisma.audit_logsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.audit_logsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.audit_logsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_logsPayload>
          }
          aggregate: {
            args: Prisma.Audit_logsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAudit_logs>
          }
          groupBy: {
            args: Prisma.audit_logsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Audit_logsGroupByOutputType>[]
          }
          count: {
            args: Prisma.audit_logsCountArgs<ExtArgs>
            result: $Utils.Optional<Audit_logsCountAggregateOutputType> | number
          }
        }
      }
      banners: {
        payload: Prisma.$bannersPayload<ExtArgs>
        fields: Prisma.bannersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.bannersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bannersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.bannersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bannersPayload>
          }
          findFirst: {
            args: Prisma.bannersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bannersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.bannersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bannersPayload>
          }
          findMany: {
            args: Prisma.bannersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bannersPayload>[]
          }
          create: {
            args: Prisma.bannersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bannersPayload>
          }
          createMany: {
            args: Prisma.bannersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.bannersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bannersPayload>
          }
          update: {
            args: Prisma.bannersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bannersPayload>
          }
          deleteMany: {
            args: Prisma.bannersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.bannersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.bannersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bannersPayload>
          }
          aggregate: {
            args: Prisma.BannersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBanners>
          }
          groupBy: {
            args: Prisma.bannersGroupByArgs<ExtArgs>
            result: $Utils.Optional<BannersGroupByOutputType>[]
          }
          count: {
            args: Prisma.bannersCountArgs<ExtArgs>
            result: $Utils.Optional<BannersCountAggregateOutputType> | number
          }
        }
      }
      coin_transactions: {
        payload: Prisma.$coin_transactionsPayload<ExtArgs>
        fields: Prisma.coin_transactionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.coin_transactionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coin_transactionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.coin_transactionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coin_transactionsPayload>
          }
          findFirst: {
            args: Prisma.coin_transactionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coin_transactionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.coin_transactionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coin_transactionsPayload>
          }
          findMany: {
            args: Prisma.coin_transactionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coin_transactionsPayload>[]
          }
          create: {
            args: Prisma.coin_transactionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coin_transactionsPayload>
          }
          createMany: {
            args: Prisma.coin_transactionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.coin_transactionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coin_transactionsPayload>
          }
          update: {
            args: Prisma.coin_transactionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coin_transactionsPayload>
          }
          deleteMany: {
            args: Prisma.coin_transactionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.coin_transactionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.coin_transactionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coin_transactionsPayload>
          }
          aggregate: {
            args: Prisma.Coin_transactionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCoin_transactions>
          }
          groupBy: {
            args: Prisma.coin_transactionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Coin_transactionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.coin_transactionsCountArgs<ExtArgs>
            result: $Utils.Optional<Coin_transactionsCountAggregateOutputType> | number
          }
        }
      }
      loan_applications: {
        payload: Prisma.$loan_applicationsPayload<ExtArgs>
        fields: Prisma.loan_applicationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.loan_applicationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$loan_applicationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.loan_applicationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$loan_applicationsPayload>
          }
          findFirst: {
            args: Prisma.loan_applicationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$loan_applicationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.loan_applicationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$loan_applicationsPayload>
          }
          findMany: {
            args: Prisma.loan_applicationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$loan_applicationsPayload>[]
          }
          create: {
            args: Prisma.loan_applicationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$loan_applicationsPayload>
          }
          createMany: {
            args: Prisma.loan_applicationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.loan_applicationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$loan_applicationsPayload>
          }
          update: {
            args: Prisma.loan_applicationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$loan_applicationsPayload>
          }
          deleteMany: {
            args: Prisma.loan_applicationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.loan_applicationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.loan_applicationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$loan_applicationsPayload>
          }
          aggregate: {
            args: Prisma.Loan_applicationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLoan_applications>
          }
          groupBy: {
            args: Prisma.loan_applicationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Loan_applicationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.loan_applicationsCountArgs<ExtArgs>
            result: $Utils.Optional<Loan_applicationsCountAggregateOutputType> | number
          }
        }
      }
      loan_installments: {
        payload: Prisma.$loan_installmentsPayload<ExtArgs>
        fields: Prisma.loan_installmentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.loan_installmentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$loan_installmentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.loan_installmentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$loan_installmentsPayload>
          }
          findFirst: {
            args: Prisma.loan_installmentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$loan_installmentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.loan_installmentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$loan_installmentsPayload>
          }
          findMany: {
            args: Prisma.loan_installmentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$loan_installmentsPayload>[]
          }
          create: {
            args: Prisma.loan_installmentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$loan_installmentsPayload>
          }
          createMany: {
            args: Prisma.loan_installmentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.loan_installmentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$loan_installmentsPayload>
          }
          update: {
            args: Prisma.loan_installmentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$loan_installmentsPayload>
          }
          deleteMany: {
            args: Prisma.loan_installmentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.loan_installmentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.loan_installmentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$loan_installmentsPayload>
          }
          aggregate: {
            args: Prisma.Loan_installmentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLoan_installments>
          }
          groupBy: {
            args: Prisma.loan_installmentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Loan_installmentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.loan_installmentsCountArgs<ExtArgs>
            result: $Utils.Optional<Loan_installmentsCountAggregateOutputType> | number
          }
        }
      }
      loans: {
        payload: Prisma.$loansPayload<ExtArgs>
        fields: Prisma.loansFieldRefs
        operations: {
          findUnique: {
            args: Prisma.loansFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$loansPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.loansFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$loansPayload>
          }
          findFirst: {
            args: Prisma.loansFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$loansPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.loansFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$loansPayload>
          }
          findMany: {
            args: Prisma.loansFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$loansPayload>[]
          }
          create: {
            args: Prisma.loansCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$loansPayload>
          }
          createMany: {
            args: Prisma.loansCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.loansDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$loansPayload>
          }
          update: {
            args: Prisma.loansUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$loansPayload>
          }
          deleteMany: {
            args: Prisma.loansDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.loansUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.loansUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$loansPayload>
          }
          aggregate: {
            args: Prisma.LoansAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLoans>
          }
          groupBy: {
            args: Prisma.loansGroupByArgs<ExtArgs>
            result: $Utils.Optional<LoansGroupByOutputType>[]
          }
          count: {
            args: Prisma.loansCountArgs<ExtArgs>
            result: $Utils.Optional<LoansCountAggregateOutputType> | number
          }
        }
      }
      notifications: {
        payload: Prisma.$notificationsPayload<ExtArgs>
        fields: Prisma.notificationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.notificationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.notificationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          findFirst: {
            args: Prisma.notificationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.notificationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          findMany: {
            args: Prisma.notificationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>[]
          }
          create: {
            args: Prisma.notificationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          createMany: {
            args: Prisma.notificationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.notificationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          update: {
            args: Prisma.notificationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          deleteMany: {
            args: Prisma.notificationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.notificationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.notificationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          aggregate: {
            args: Prisma.NotificationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotifications>
          }
          groupBy: {
            args: Prisma.notificationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.notificationsCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationsCountAggregateOutputType> | number
          }
        }
      }
      payments: {
        payload: Prisma.$paymentsPayload<ExtArgs>
        fields: Prisma.paymentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.paymentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.paymentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          findFirst: {
            args: Prisma.paymentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.paymentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          findMany: {
            args: Prisma.paymentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>[]
          }
          create: {
            args: Prisma.paymentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          createMany: {
            args: Prisma.paymentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.paymentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          update: {
            args: Prisma.paymentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          deleteMany: {
            args: Prisma.paymentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.paymentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.paymentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          aggregate: {
            args: Prisma.PaymentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayments>
          }
          groupBy: {
            args: Prisma.paymentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.paymentsCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentsCountAggregateOutputType> | number
          }
        }
      }
      privileges: {
        payload: Prisma.$privilegesPayload<ExtArgs>
        fields: Prisma.privilegesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.privilegesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$privilegesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.privilegesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$privilegesPayload>
          }
          findFirst: {
            args: Prisma.privilegesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$privilegesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.privilegesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$privilegesPayload>
          }
          findMany: {
            args: Prisma.privilegesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$privilegesPayload>[]
          }
          create: {
            args: Prisma.privilegesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$privilegesPayload>
          }
          createMany: {
            args: Prisma.privilegesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.privilegesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$privilegesPayload>
          }
          update: {
            args: Prisma.privilegesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$privilegesPayload>
          }
          deleteMany: {
            args: Prisma.privilegesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.privilegesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.privilegesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$privilegesPayload>
          }
          aggregate: {
            args: Prisma.PrivilegesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrivileges>
          }
          groupBy: {
            args: Prisma.privilegesGroupByArgs<ExtArgs>
            result: $Utils.Optional<PrivilegesGroupByOutputType>[]
          }
          count: {
            args: Prisma.privilegesCountArgs<ExtArgs>
            result: $Utils.Optional<PrivilegesCountAggregateOutputType> | number
          }
        }
      }
      reward_redemptions: {
        payload: Prisma.$reward_redemptionsPayload<ExtArgs>
        fields: Prisma.reward_redemptionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.reward_redemptionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reward_redemptionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.reward_redemptionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reward_redemptionsPayload>
          }
          findFirst: {
            args: Prisma.reward_redemptionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reward_redemptionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.reward_redemptionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reward_redemptionsPayload>
          }
          findMany: {
            args: Prisma.reward_redemptionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reward_redemptionsPayload>[]
          }
          create: {
            args: Prisma.reward_redemptionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reward_redemptionsPayload>
          }
          createMany: {
            args: Prisma.reward_redemptionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.reward_redemptionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reward_redemptionsPayload>
          }
          update: {
            args: Prisma.reward_redemptionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reward_redemptionsPayload>
          }
          deleteMany: {
            args: Prisma.reward_redemptionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.reward_redemptionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.reward_redemptionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reward_redemptionsPayload>
          }
          aggregate: {
            args: Prisma.Reward_redemptionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReward_redemptions>
          }
          groupBy: {
            args: Prisma.reward_redemptionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Reward_redemptionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.reward_redemptionsCountArgs<ExtArgs>
            result: $Utils.Optional<Reward_redemptionsCountAggregateOutputType> | number
          }
        }
      }
      rewards: {
        payload: Prisma.$rewardsPayload<ExtArgs>
        fields: Prisma.rewardsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.rewardsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rewardsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.rewardsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rewardsPayload>
          }
          findFirst: {
            args: Prisma.rewardsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rewardsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.rewardsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rewardsPayload>
          }
          findMany: {
            args: Prisma.rewardsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rewardsPayload>[]
          }
          create: {
            args: Prisma.rewardsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rewardsPayload>
          }
          createMany: {
            args: Prisma.rewardsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.rewardsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rewardsPayload>
          }
          update: {
            args: Prisma.rewardsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rewardsPayload>
          }
          deleteMany: {
            args: Prisma.rewardsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.rewardsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.rewardsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rewardsPayload>
          }
          aggregate: {
            args: Prisma.RewardsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRewards>
          }
          groupBy: {
            args: Prisma.rewardsGroupByArgs<ExtArgs>
            result: $Utils.Optional<RewardsGroupByOutputType>[]
          }
          count: {
            args: Prisma.rewardsCountArgs<ExtArgs>
            result: $Utils.Optional<RewardsCountAggregateOutputType> | number
          }
        }
      }
      sessions: {
        payload: Prisma.$sessionsPayload<ExtArgs>
        fields: Prisma.sessionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.sessionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.sessionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>
          }
          findFirst: {
            args: Prisma.sessionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.sessionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>
          }
          findMany: {
            args: Prisma.sessionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>[]
          }
          create: {
            args: Prisma.sessionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>
          }
          createMany: {
            args: Prisma.sessionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.sessionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>
          }
          update: {
            args: Prisma.sessionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>
          }
          deleteMany: {
            args: Prisma.sessionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.sessionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.sessionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>
          }
          aggregate: {
            args: Prisma.SessionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSessions>
          }
          groupBy: {
            args: Prisma.sessionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.sessionsCountArgs<ExtArgs>
            result: $Utils.Optional<SessionsCountAggregateOutputType> | number
          }
        }
      }
      system_config: {
        payload: Prisma.$system_configPayload<ExtArgs>
        fields: Prisma.system_configFieldRefs
        operations: {
          findUnique: {
            args: Prisma.system_configFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$system_configPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.system_configFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$system_configPayload>
          }
          findFirst: {
            args: Prisma.system_configFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$system_configPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.system_configFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$system_configPayload>
          }
          findMany: {
            args: Prisma.system_configFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$system_configPayload>[]
          }
          create: {
            args: Prisma.system_configCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$system_configPayload>
          }
          createMany: {
            args: Prisma.system_configCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.system_configDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$system_configPayload>
          }
          update: {
            args: Prisma.system_configUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$system_configPayload>
          }
          deleteMany: {
            args: Prisma.system_configDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.system_configUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.system_configUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$system_configPayload>
          }
          aggregate: {
            args: Prisma.System_configAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystem_config>
          }
          groupBy: {
            args: Prisma.system_configGroupByArgs<ExtArgs>
            result: $Utils.Optional<System_configGroupByOutputType>[]
          }
          count: {
            args: Prisma.system_configCountArgs<ExtArgs>
            result: $Utils.Optional<System_configCountAggregateOutputType> | number
          }
        }
      }
      documents: {
        payload: Prisma.$documentsPayload<ExtArgs>
        fields: Prisma.documentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.documentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.documentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documentsPayload>
          }
          findFirst: {
            args: Prisma.documentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.documentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documentsPayload>
          }
          findMany: {
            args: Prisma.documentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documentsPayload>[]
          }
          create: {
            args: Prisma.documentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documentsPayload>
          }
          createMany: {
            args: Prisma.documentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.documentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documentsPayload>
          }
          update: {
            args: Prisma.documentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documentsPayload>
          }
          deleteMany: {
            args: Prisma.documentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.documentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.documentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documentsPayload>
          }
          aggregate: {
            args: Prisma.DocumentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocuments>
          }
          groupBy: {
            args: Prisma.documentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.documentsCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentsCountAggregateOutputType> | number
          }
        }
      }
      document_title_lists: {
        payload: Prisma.$document_title_listsPayload<ExtArgs>
        fields: Prisma.document_title_listsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.document_title_listsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$document_title_listsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.document_title_listsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$document_title_listsPayload>
          }
          findFirst: {
            args: Prisma.document_title_listsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$document_title_listsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.document_title_listsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$document_title_listsPayload>
          }
          findMany: {
            args: Prisma.document_title_listsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$document_title_listsPayload>[]
          }
          create: {
            args: Prisma.document_title_listsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$document_title_listsPayload>
          }
          createMany: {
            args: Prisma.document_title_listsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.document_title_listsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$document_title_listsPayload>
          }
          update: {
            args: Prisma.document_title_listsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$document_title_listsPayload>
          }
          deleteMany: {
            args: Prisma.document_title_listsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.document_title_listsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.document_title_listsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$document_title_listsPayload>
          }
          aggregate: {
            args: Prisma.Document_title_listsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocument_title_lists>
          }
          groupBy: {
            args: Prisma.document_title_listsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Document_title_listsGroupByOutputType>[]
          }
          count: {
            args: Prisma.document_title_listsCountArgs<ExtArgs>
            result: $Utils.Optional<Document_title_listsCountAggregateOutputType> | number
          }
        }
      }
      land_accounts: {
        payload: Prisma.$land_accountsPayload<ExtArgs>
        fields: Prisma.land_accountsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.land_accountsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$land_accountsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.land_accountsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$land_accountsPayload>
          }
          findFirst: {
            args: Prisma.land_accountsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$land_accountsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.land_accountsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$land_accountsPayload>
          }
          findMany: {
            args: Prisma.land_accountsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$land_accountsPayload>[]
          }
          create: {
            args: Prisma.land_accountsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$land_accountsPayload>
          }
          createMany: {
            args: Prisma.land_accountsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.land_accountsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$land_accountsPayload>
          }
          update: {
            args: Prisma.land_accountsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$land_accountsPayload>
          }
          deleteMany: {
            args: Prisma.land_accountsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.land_accountsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.land_accountsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$land_accountsPayload>
          }
          aggregate: {
            args: Prisma.Land_accountsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLand_accounts>
          }
          groupBy: {
            args: Prisma.land_accountsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Land_accountsGroupByOutputType>[]
          }
          count: {
            args: Prisma.land_accountsCountArgs<ExtArgs>
            result: $Utils.Optional<Land_accountsCountAggregateOutputType> | number
          }
        }
      }
      land_account_logs: {
        payload: Prisma.$land_account_logsPayload<ExtArgs>
        fields: Prisma.land_account_logsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.land_account_logsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$land_account_logsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.land_account_logsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$land_account_logsPayload>
          }
          findFirst: {
            args: Prisma.land_account_logsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$land_account_logsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.land_account_logsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$land_account_logsPayload>
          }
          findMany: {
            args: Prisma.land_account_logsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$land_account_logsPayload>[]
          }
          create: {
            args: Prisma.land_account_logsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$land_account_logsPayload>
          }
          createMany: {
            args: Prisma.land_account_logsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.land_account_logsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$land_account_logsPayload>
          }
          update: {
            args: Prisma.land_account_logsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$land_account_logsPayload>
          }
          deleteMany: {
            args: Prisma.land_account_logsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.land_account_logsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.land_account_logsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$land_account_logsPayload>
          }
          aggregate: {
            args: Prisma.Land_account_logsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLand_account_logs>
          }
          groupBy: {
            args: Prisma.land_account_logsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Land_account_logsGroupByOutputType>[]
          }
          count: {
            args: Prisma.land_account_logsCountArgs<ExtArgs>
            result: $Utils.Optional<Land_account_logsCountAggregateOutputType> | number
          }
        }
      }
      land_account_reports: {
        payload: Prisma.$land_account_reportsPayload<ExtArgs>
        fields: Prisma.land_account_reportsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.land_account_reportsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$land_account_reportsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.land_account_reportsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$land_account_reportsPayload>
          }
          findFirst: {
            args: Prisma.land_account_reportsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$land_account_reportsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.land_account_reportsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$land_account_reportsPayload>
          }
          findMany: {
            args: Prisma.land_account_reportsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$land_account_reportsPayload>[]
          }
          create: {
            args: Prisma.land_account_reportsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$land_account_reportsPayload>
          }
          createMany: {
            args: Prisma.land_account_reportsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.land_account_reportsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$land_account_reportsPayload>
          }
          update: {
            args: Prisma.land_account_reportsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$land_account_reportsPayload>
          }
          deleteMany: {
            args: Prisma.land_account_reportsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.land_account_reportsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.land_account_reportsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$land_account_reportsPayload>
          }
          aggregate: {
            args: Prisma.Land_account_reportsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLand_account_reports>
          }
          groupBy: {
            args: Prisma.land_account_reportsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Land_account_reportsGroupByOutputType>[]
          }
          count: {
            args: Prisma.land_account_reportsCountArgs<ExtArgs>
            result: $Utils.Optional<Land_account_reportsCountAggregateOutputType> | number
          }
        }
      }
      user_profiles: {
        payload: Prisma.$user_profilesPayload<ExtArgs>
        fields: Prisma.user_profilesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.user_profilesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_profilesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.user_profilesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_profilesPayload>
          }
          findFirst: {
            args: Prisma.user_profilesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_profilesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.user_profilesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_profilesPayload>
          }
          findMany: {
            args: Prisma.user_profilesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_profilesPayload>[]
          }
          create: {
            args: Prisma.user_profilesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_profilesPayload>
          }
          createMany: {
            args: Prisma.user_profilesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.user_profilesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_profilesPayload>
          }
          update: {
            args: Prisma.user_profilesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_profilesPayload>
          }
          deleteMany: {
            args: Prisma.user_profilesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.user_profilesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.user_profilesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_profilesPayload>
          }
          aggregate: {
            args: Prisma.User_profilesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser_profiles>
          }
          groupBy: {
            args: Prisma.user_profilesGroupByArgs<ExtArgs>
            result: $Utils.Optional<User_profilesGroupByOutputType>[]
          }
          count: {
            args: Prisma.user_profilesCountArgs<ExtArgs>
            result: $Utils.Optional<User_profilesCountAggregateOutputType> | number
          }
        }
      }
      users: {
        payload: Prisma.$usersPayload<ExtArgs>
        fields: Prisma.usersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findFirst: {
            args: Prisma.usersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findMany: {
            args: Prisma.usersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          create: {
            args: Prisma.usersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          createMany: {
            args: Prisma.usersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.usersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          update: {
            args: Prisma.usersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          deleteMany: {
            args: Prisma.usersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.usersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.usersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.usersGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.usersCountArgs<ExtArgs>
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    admin_permissions?: admin_permissionsOmit
    admin_sessions?: admin_sessionsOmit
    admins?: adminsOmit
    agent_customers?: agent_customersOmit
    audit_logs?: audit_logsOmit
    banners?: bannersOmit
    coin_transactions?: coin_transactionsOmit
    loan_applications?: loan_applicationsOmit
    loan_installments?: loan_installmentsOmit
    loans?: loansOmit
    notifications?: notificationsOmit
    payments?: paymentsOmit
    privileges?: privilegesOmit
    reward_redemptions?: reward_redemptionsOmit
    rewards?: rewardsOmit
    sessions?: sessionsOmit
    system_config?: system_configOmit
    documents?: documentsOmit
    document_title_lists?: document_title_listsOmit
    land_accounts?: land_accountsOmit
    land_account_logs?: land_account_logsOmit
    land_account_reports?: land_account_reportsOmit
    user_profiles?: user_profilesOmit
    users?: usersOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type Land_accountsCountOutputType
   */

  export type Land_accountsCountOutputType = {
    logs: number
    reports: number
  }

  export type Land_accountsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    logs?: boolean | Land_accountsCountOutputTypeCountLogsArgs
    reports?: boolean | Land_accountsCountOutputTypeCountReportsArgs
  }

  // Custom InputTypes
  /**
   * Land_accountsCountOutputType without action
   */
  export type Land_accountsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Land_accountsCountOutputType
     */
    select?: Land_accountsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Land_accountsCountOutputType without action
   */
  export type Land_accountsCountOutputTypeCountLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: land_account_logsWhereInput
  }

  /**
   * Land_accountsCountOutputType without action
   */
  export type Land_accountsCountOutputTypeCountReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: land_account_reportsWhereInput
  }


  /**
   * Models
   */

  /**
   * Model admin_permissions
   */

  export type AggregateAdmin_permissions = {
    _count: Admin_permissionsCountAggregateOutputType | null
    _min: Admin_permissionsMinAggregateOutputType | null
    _max: Admin_permissionsMaxAggregateOutputType | null
  }

  export type Admin_permissionsMinAggregateOutputType = {
    id: string | null
    adminId: string | null
    permission: $Enums.admin_permissions_permission | null
    grantedAt: Date | null
    grantedBy: string | null
  }

  export type Admin_permissionsMaxAggregateOutputType = {
    id: string | null
    adminId: string | null
    permission: $Enums.admin_permissions_permission | null
    grantedAt: Date | null
    grantedBy: string | null
  }

  export type Admin_permissionsCountAggregateOutputType = {
    id: number
    adminId: number
    permission: number
    grantedAt: number
    grantedBy: number
    _all: number
  }


  export type Admin_permissionsMinAggregateInputType = {
    id?: true
    adminId?: true
    permission?: true
    grantedAt?: true
    grantedBy?: true
  }

  export type Admin_permissionsMaxAggregateInputType = {
    id?: true
    adminId?: true
    permission?: true
    grantedAt?: true
    grantedBy?: true
  }

  export type Admin_permissionsCountAggregateInputType = {
    id?: true
    adminId?: true
    permission?: true
    grantedAt?: true
    grantedBy?: true
    _all?: true
  }

  export type Admin_permissionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which admin_permissions to aggregate.
     */
    where?: admin_permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admin_permissions to fetch.
     */
    orderBy?: admin_permissionsOrderByWithRelationInput | admin_permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: admin_permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admin_permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admin_permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned admin_permissions
    **/
    _count?: true | Admin_permissionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Admin_permissionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Admin_permissionsMaxAggregateInputType
  }

  export type GetAdmin_permissionsAggregateType<T extends Admin_permissionsAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin_permissions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin_permissions[P]>
      : GetScalarType<T[P], AggregateAdmin_permissions[P]>
  }




  export type admin_permissionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: admin_permissionsWhereInput
    orderBy?: admin_permissionsOrderByWithAggregationInput | admin_permissionsOrderByWithAggregationInput[]
    by: Admin_permissionsScalarFieldEnum[] | Admin_permissionsScalarFieldEnum
    having?: admin_permissionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Admin_permissionsCountAggregateInputType | true
    _min?: Admin_permissionsMinAggregateInputType
    _max?: Admin_permissionsMaxAggregateInputType
  }

  export type Admin_permissionsGroupByOutputType = {
    id: string
    adminId: string
    permission: $Enums.admin_permissions_permission
    grantedAt: Date
    grantedBy: string | null
    _count: Admin_permissionsCountAggregateOutputType | null
    _min: Admin_permissionsMinAggregateOutputType | null
    _max: Admin_permissionsMaxAggregateOutputType | null
  }

  type GetAdmin_permissionsGroupByPayload<T extends admin_permissionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Admin_permissionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Admin_permissionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Admin_permissionsGroupByOutputType[P]>
            : GetScalarType<T[P], Admin_permissionsGroupByOutputType[P]>
        }
      >
    >


  export type admin_permissionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    permission?: boolean
    grantedAt?: boolean
    grantedBy?: boolean
  }, ExtArgs["result"]["admin_permissions"]>



  export type admin_permissionsSelectScalar = {
    id?: boolean
    adminId?: boolean
    permission?: boolean
    grantedAt?: boolean
    grantedBy?: boolean
  }

  export type admin_permissionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "adminId" | "permission" | "grantedAt" | "grantedBy", ExtArgs["result"]["admin_permissions"]>

  export type $admin_permissionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "admin_permissions"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      adminId: string
      permission: $Enums.admin_permissions_permission
      grantedAt: Date
      grantedBy: string | null
    }, ExtArgs["result"]["admin_permissions"]>
    composites: {}
  }

  type admin_permissionsGetPayload<S extends boolean | null | undefined | admin_permissionsDefaultArgs> = $Result.GetResult<Prisma.$admin_permissionsPayload, S>

  type admin_permissionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<admin_permissionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Admin_permissionsCountAggregateInputType | true
    }

  export interface admin_permissionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['admin_permissions'], meta: { name: 'admin_permissions' } }
    /**
     * Find zero or one Admin_permissions that matches the filter.
     * @param {admin_permissionsFindUniqueArgs} args - Arguments to find a Admin_permissions
     * @example
     * // Get one Admin_permissions
     * const admin_permissions = await prisma.admin_permissions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends admin_permissionsFindUniqueArgs>(args: SelectSubset<T, admin_permissionsFindUniqueArgs<ExtArgs>>): Prisma__admin_permissionsClient<$Result.GetResult<Prisma.$admin_permissionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Admin_permissions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {admin_permissionsFindUniqueOrThrowArgs} args - Arguments to find a Admin_permissions
     * @example
     * // Get one Admin_permissions
     * const admin_permissions = await prisma.admin_permissions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends admin_permissionsFindUniqueOrThrowArgs>(args: SelectSubset<T, admin_permissionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__admin_permissionsClient<$Result.GetResult<Prisma.$admin_permissionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin_permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admin_permissionsFindFirstArgs} args - Arguments to find a Admin_permissions
     * @example
     * // Get one Admin_permissions
     * const admin_permissions = await prisma.admin_permissions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends admin_permissionsFindFirstArgs>(args?: SelectSubset<T, admin_permissionsFindFirstArgs<ExtArgs>>): Prisma__admin_permissionsClient<$Result.GetResult<Prisma.$admin_permissionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin_permissions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admin_permissionsFindFirstOrThrowArgs} args - Arguments to find a Admin_permissions
     * @example
     * // Get one Admin_permissions
     * const admin_permissions = await prisma.admin_permissions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends admin_permissionsFindFirstOrThrowArgs>(args?: SelectSubset<T, admin_permissionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__admin_permissionsClient<$Result.GetResult<Prisma.$admin_permissionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Admin_permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admin_permissionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admin_permissions
     * const admin_permissions = await prisma.admin_permissions.findMany()
     * 
     * // Get first 10 Admin_permissions
     * const admin_permissions = await prisma.admin_permissions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const admin_permissionsWithIdOnly = await prisma.admin_permissions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends admin_permissionsFindManyArgs>(args?: SelectSubset<T, admin_permissionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$admin_permissionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Admin_permissions.
     * @param {admin_permissionsCreateArgs} args - Arguments to create a Admin_permissions.
     * @example
     * // Create one Admin_permissions
     * const Admin_permissions = await prisma.admin_permissions.create({
     *   data: {
     *     // ... data to create a Admin_permissions
     *   }
     * })
     * 
     */
    create<T extends admin_permissionsCreateArgs>(args: SelectSubset<T, admin_permissionsCreateArgs<ExtArgs>>): Prisma__admin_permissionsClient<$Result.GetResult<Prisma.$admin_permissionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Admin_permissions.
     * @param {admin_permissionsCreateManyArgs} args - Arguments to create many Admin_permissions.
     * @example
     * // Create many Admin_permissions
     * const admin_permissions = await prisma.admin_permissions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends admin_permissionsCreateManyArgs>(args?: SelectSubset<T, admin_permissionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Admin_permissions.
     * @param {admin_permissionsDeleteArgs} args - Arguments to delete one Admin_permissions.
     * @example
     * // Delete one Admin_permissions
     * const Admin_permissions = await prisma.admin_permissions.delete({
     *   where: {
     *     // ... filter to delete one Admin_permissions
     *   }
     * })
     * 
     */
    delete<T extends admin_permissionsDeleteArgs>(args: SelectSubset<T, admin_permissionsDeleteArgs<ExtArgs>>): Prisma__admin_permissionsClient<$Result.GetResult<Prisma.$admin_permissionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Admin_permissions.
     * @param {admin_permissionsUpdateArgs} args - Arguments to update one Admin_permissions.
     * @example
     * // Update one Admin_permissions
     * const admin_permissions = await prisma.admin_permissions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends admin_permissionsUpdateArgs>(args: SelectSubset<T, admin_permissionsUpdateArgs<ExtArgs>>): Prisma__admin_permissionsClient<$Result.GetResult<Prisma.$admin_permissionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Admin_permissions.
     * @param {admin_permissionsDeleteManyArgs} args - Arguments to filter Admin_permissions to delete.
     * @example
     * // Delete a few Admin_permissions
     * const { count } = await prisma.admin_permissions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends admin_permissionsDeleteManyArgs>(args?: SelectSubset<T, admin_permissionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admin_permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admin_permissionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admin_permissions
     * const admin_permissions = await prisma.admin_permissions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends admin_permissionsUpdateManyArgs>(args: SelectSubset<T, admin_permissionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Admin_permissions.
     * @param {admin_permissionsUpsertArgs} args - Arguments to update or create a Admin_permissions.
     * @example
     * // Update or create a Admin_permissions
     * const admin_permissions = await prisma.admin_permissions.upsert({
     *   create: {
     *     // ... data to create a Admin_permissions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin_permissions we want to update
     *   }
     * })
     */
    upsert<T extends admin_permissionsUpsertArgs>(args: SelectSubset<T, admin_permissionsUpsertArgs<ExtArgs>>): Prisma__admin_permissionsClient<$Result.GetResult<Prisma.$admin_permissionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Admin_permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admin_permissionsCountArgs} args - Arguments to filter Admin_permissions to count.
     * @example
     * // Count the number of Admin_permissions
     * const count = await prisma.admin_permissions.count({
     *   where: {
     *     // ... the filter for the Admin_permissions we want to count
     *   }
     * })
    **/
    count<T extends admin_permissionsCountArgs>(
      args?: Subset<T, admin_permissionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Admin_permissionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin_permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Admin_permissionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Admin_permissionsAggregateArgs>(args: Subset<T, Admin_permissionsAggregateArgs>): Prisma.PrismaPromise<GetAdmin_permissionsAggregateType<T>>

    /**
     * Group by Admin_permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admin_permissionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends admin_permissionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: admin_permissionsGroupByArgs['orderBy'] }
        : { orderBy?: admin_permissionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, admin_permissionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdmin_permissionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the admin_permissions model
   */
  readonly fields: admin_permissionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for admin_permissions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__admin_permissionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the admin_permissions model
   */
  interface admin_permissionsFieldRefs {
    readonly id: FieldRef<"admin_permissions", 'String'>
    readonly adminId: FieldRef<"admin_permissions", 'String'>
    readonly permission: FieldRef<"admin_permissions", 'admin_permissions_permission'>
    readonly grantedAt: FieldRef<"admin_permissions", 'DateTime'>
    readonly grantedBy: FieldRef<"admin_permissions", 'String'>
  }
    

  // Custom InputTypes
  /**
   * admin_permissions findUnique
   */
  export type admin_permissionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_permissions
     */
    select?: admin_permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin_permissions
     */
    omit?: admin_permissionsOmit<ExtArgs> | null
    /**
     * Filter, which admin_permissions to fetch.
     */
    where: admin_permissionsWhereUniqueInput
  }

  /**
   * admin_permissions findUniqueOrThrow
   */
  export type admin_permissionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_permissions
     */
    select?: admin_permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin_permissions
     */
    omit?: admin_permissionsOmit<ExtArgs> | null
    /**
     * Filter, which admin_permissions to fetch.
     */
    where: admin_permissionsWhereUniqueInput
  }

  /**
   * admin_permissions findFirst
   */
  export type admin_permissionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_permissions
     */
    select?: admin_permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin_permissions
     */
    omit?: admin_permissionsOmit<ExtArgs> | null
    /**
     * Filter, which admin_permissions to fetch.
     */
    where?: admin_permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admin_permissions to fetch.
     */
    orderBy?: admin_permissionsOrderByWithRelationInput | admin_permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for admin_permissions.
     */
    cursor?: admin_permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admin_permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admin_permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of admin_permissions.
     */
    distinct?: Admin_permissionsScalarFieldEnum | Admin_permissionsScalarFieldEnum[]
  }

  /**
   * admin_permissions findFirstOrThrow
   */
  export type admin_permissionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_permissions
     */
    select?: admin_permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin_permissions
     */
    omit?: admin_permissionsOmit<ExtArgs> | null
    /**
     * Filter, which admin_permissions to fetch.
     */
    where?: admin_permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admin_permissions to fetch.
     */
    orderBy?: admin_permissionsOrderByWithRelationInput | admin_permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for admin_permissions.
     */
    cursor?: admin_permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admin_permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admin_permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of admin_permissions.
     */
    distinct?: Admin_permissionsScalarFieldEnum | Admin_permissionsScalarFieldEnum[]
  }

  /**
   * admin_permissions findMany
   */
  export type admin_permissionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_permissions
     */
    select?: admin_permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin_permissions
     */
    omit?: admin_permissionsOmit<ExtArgs> | null
    /**
     * Filter, which admin_permissions to fetch.
     */
    where?: admin_permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admin_permissions to fetch.
     */
    orderBy?: admin_permissionsOrderByWithRelationInput | admin_permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing admin_permissions.
     */
    cursor?: admin_permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admin_permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admin_permissions.
     */
    skip?: number
    distinct?: Admin_permissionsScalarFieldEnum | Admin_permissionsScalarFieldEnum[]
  }

  /**
   * admin_permissions create
   */
  export type admin_permissionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_permissions
     */
    select?: admin_permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin_permissions
     */
    omit?: admin_permissionsOmit<ExtArgs> | null
    /**
     * The data needed to create a admin_permissions.
     */
    data: XOR<admin_permissionsCreateInput, admin_permissionsUncheckedCreateInput>
  }

  /**
   * admin_permissions createMany
   */
  export type admin_permissionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many admin_permissions.
     */
    data: admin_permissionsCreateManyInput | admin_permissionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * admin_permissions update
   */
  export type admin_permissionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_permissions
     */
    select?: admin_permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin_permissions
     */
    omit?: admin_permissionsOmit<ExtArgs> | null
    /**
     * The data needed to update a admin_permissions.
     */
    data: XOR<admin_permissionsUpdateInput, admin_permissionsUncheckedUpdateInput>
    /**
     * Choose, which admin_permissions to update.
     */
    where: admin_permissionsWhereUniqueInput
  }

  /**
   * admin_permissions updateMany
   */
  export type admin_permissionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update admin_permissions.
     */
    data: XOR<admin_permissionsUpdateManyMutationInput, admin_permissionsUncheckedUpdateManyInput>
    /**
     * Filter which admin_permissions to update
     */
    where?: admin_permissionsWhereInput
    /**
     * Limit how many admin_permissions to update.
     */
    limit?: number
  }

  /**
   * admin_permissions upsert
   */
  export type admin_permissionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_permissions
     */
    select?: admin_permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin_permissions
     */
    omit?: admin_permissionsOmit<ExtArgs> | null
    /**
     * The filter to search for the admin_permissions to update in case it exists.
     */
    where: admin_permissionsWhereUniqueInput
    /**
     * In case the admin_permissions found by the `where` argument doesn't exist, create a new admin_permissions with this data.
     */
    create: XOR<admin_permissionsCreateInput, admin_permissionsUncheckedCreateInput>
    /**
     * In case the admin_permissions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<admin_permissionsUpdateInput, admin_permissionsUncheckedUpdateInput>
  }

  /**
   * admin_permissions delete
   */
  export type admin_permissionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_permissions
     */
    select?: admin_permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin_permissions
     */
    omit?: admin_permissionsOmit<ExtArgs> | null
    /**
     * Filter which admin_permissions to delete.
     */
    where: admin_permissionsWhereUniqueInput
  }

  /**
   * admin_permissions deleteMany
   */
  export type admin_permissionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which admin_permissions to delete
     */
    where?: admin_permissionsWhereInput
    /**
     * Limit how many admin_permissions to delete.
     */
    limit?: number
  }

  /**
   * admin_permissions without action
   */
  export type admin_permissionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_permissions
     */
    select?: admin_permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin_permissions
     */
    omit?: admin_permissionsOmit<ExtArgs> | null
  }


  /**
   * Model admin_sessions
   */

  export type AggregateAdmin_sessions = {
    _count: Admin_sessionsCountAggregateOutputType | null
    _min: Admin_sessionsMinAggregateOutputType | null
    _max: Admin_sessionsMaxAggregateOutputType | null
  }

  export type Admin_sessionsMinAggregateOutputType = {
    id: string | null
    adminId: string | null
    token: string | null
    deviceInfo: string | null
    ipAddress: string | null
    userAgent: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type Admin_sessionsMaxAggregateOutputType = {
    id: string | null
    adminId: string | null
    token: string | null
    deviceInfo: string | null
    ipAddress: string | null
    userAgent: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type Admin_sessionsCountAggregateOutputType = {
    id: number
    adminId: number
    token: number
    deviceInfo: number
    ipAddress: number
    userAgent: number
    expiresAt: number
    createdAt: number
    _all: number
  }


  export type Admin_sessionsMinAggregateInputType = {
    id?: true
    adminId?: true
    token?: true
    deviceInfo?: true
    ipAddress?: true
    userAgent?: true
    expiresAt?: true
    createdAt?: true
  }

  export type Admin_sessionsMaxAggregateInputType = {
    id?: true
    adminId?: true
    token?: true
    deviceInfo?: true
    ipAddress?: true
    userAgent?: true
    expiresAt?: true
    createdAt?: true
  }

  export type Admin_sessionsCountAggregateInputType = {
    id?: true
    adminId?: true
    token?: true
    deviceInfo?: true
    ipAddress?: true
    userAgent?: true
    expiresAt?: true
    createdAt?: true
    _all?: true
  }

  export type Admin_sessionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which admin_sessions to aggregate.
     */
    where?: admin_sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admin_sessions to fetch.
     */
    orderBy?: admin_sessionsOrderByWithRelationInput | admin_sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: admin_sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admin_sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admin_sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned admin_sessions
    **/
    _count?: true | Admin_sessionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Admin_sessionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Admin_sessionsMaxAggregateInputType
  }

  export type GetAdmin_sessionsAggregateType<T extends Admin_sessionsAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin_sessions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin_sessions[P]>
      : GetScalarType<T[P], AggregateAdmin_sessions[P]>
  }




  export type admin_sessionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: admin_sessionsWhereInput
    orderBy?: admin_sessionsOrderByWithAggregationInput | admin_sessionsOrderByWithAggregationInput[]
    by: Admin_sessionsScalarFieldEnum[] | Admin_sessionsScalarFieldEnum
    having?: admin_sessionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Admin_sessionsCountAggregateInputType | true
    _min?: Admin_sessionsMinAggregateInputType
    _max?: Admin_sessionsMaxAggregateInputType
  }

  export type Admin_sessionsGroupByOutputType = {
    id: string
    adminId: string
    token: string
    deviceInfo: string | null
    ipAddress: string | null
    userAgent: string | null
    expiresAt: Date
    createdAt: Date
    _count: Admin_sessionsCountAggregateOutputType | null
    _min: Admin_sessionsMinAggregateOutputType | null
    _max: Admin_sessionsMaxAggregateOutputType | null
  }

  type GetAdmin_sessionsGroupByPayload<T extends admin_sessionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Admin_sessionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Admin_sessionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Admin_sessionsGroupByOutputType[P]>
            : GetScalarType<T[P], Admin_sessionsGroupByOutputType[P]>
        }
      >
    >


  export type admin_sessionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    token?: boolean
    deviceInfo?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["admin_sessions"]>



  export type admin_sessionsSelectScalar = {
    id?: boolean
    adminId?: boolean
    token?: boolean
    deviceInfo?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }

  export type admin_sessionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "adminId" | "token" | "deviceInfo" | "ipAddress" | "userAgent" | "expiresAt" | "createdAt", ExtArgs["result"]["admin_sessions"]>

  export type $admin_sessionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "admin_sessions"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      adminId: string
      token: string
      deviceInfo: string | null
      ipAddress: string | null
      userAgent: string | null
      expiresAt: Date
      createdAt: Date
    }, ExtArgs["result"]["admin_sessions"]>
    composites: {}
  }

  type admin_sessionsGetPayload<S extends boolean | null | undefined | admin_sessionsDefaultArgs> = $Result.GetResult<Prisma.$admin_sessionsPayload, S>

  type admin_sessionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<admin_sessionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Admin_sessionsCountAggregateInputType | true
    }

  export interface admin_sessionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['admin_sessions'], meta: { name: 'admin_sessions' } }
    /**
     * Find zero or one Admin_sessions that matches the filter.
     * @param {admin_sessionsFindUniqueArgs} args - Arguments to find a Admin_sessions
     * @example
     * // Get one Admin_sessions
     * const admin_sessions = await prisma.admin_sessions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends admin_sessionsFindUniqueArgs>(args: SelectSubset<T, admin_sessionsFindUniqueArgs<ExtArgs>>): Prisma__admin_sessionsClient<$Result.GetResult<Prisma.$admin_sessionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Admin_sessions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {admin_sessionsFindUniqueOrThrowArgs} args - Arguments to find a Admin_sessions
     * @example
     * // Get one Admin_sessions
     * const admin_sessions = await prisma.admin_sessions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends admin_sessionsFindUniqueOrThrowArgs>(args: SelectSubset<T, admin_sessionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__admin_sessionsClient<$Result.GetResult<Prisma.$admin_sessionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin_sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admin_sessionsFindFirstArgs} args - Arguments to find a Admin_sessions
     * @example
     * // Get one Admin_sessions
     * const admin_sessions = await prisma.admin_sessions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends admin_sessionsFindFirstArgs>(args?: SelectSubset<T, admin_sessionsFindFirstArgs<ExtArgs>>): Prisma__admin_sessionsClient<$Result.GetResult<Prisma.$admin_sessionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin_sessions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admin_sessionsFindFirstOrThrowArgs} args - Arguments to find a Admin_sessions
     * @example
     * // Get one Admin_sessions
     * const admin_sessions = await prisma.admin_sessions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends admin_sessionsFindFirstOrThrowArgs>(args?: SelectSubset<T, admin_sessionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__admin_sessionsClient<$Result.GetResult<Prisma.$admin_sessionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Admin_sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admin_sessionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admin_sessions
     * const admin_sessions = await prisma.admin_sessions.findMany()
     * 
     * // Get first 10 Admin_sessions
     * const admin_sessions = await prisma.admin_sessions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const admin_sessionsWithIdOnly = await prisma.admin_sessions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends admin_sessionsFindManyArgs>(args?: SelectSubset<T, admin_sessionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$admin_sessionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Admin_sessions.
     * @param {admin_sessionsCreateArgs} args - Arguments to create a Admin_sessions.
     * @example
     * // Create one Admin_sessions
     * const Admin_sessions = await prisma.admin_sessions.create({
     *   data: {
     *     // ... data to create a Admin_sessions
     *   }
     * })
     * 
     */
    create<T extends admin_sessionsCreateArgs>(args: SelectSubset<T, admin_sessionsCreateArgs<ExtArgs>>): Prisma__admin_sessionsClient<$Result.GetResult<Prisma.$admin_sessionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Admin_sessions.
     * @param {admin_sessionsCreateManyArgs} args - Arguments to create many Admin_sessions.
     * @example
     * // Create many Admin_sessions
     * const admin_sessions = await prisma.admin_sessions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends admin_sessionsCreateManyArgs>(args?: SelectSubset<T, admin_sessionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Admin_sessions.
     * @param {admin_sessionsDeleteArgs} args - Arguments to delete one Admin_sessions.
     * @example
     * // Delete one Admin_sessions
     * const Admin_sessions = await prisma.admin_sessions.delete({
     *   where: {
     *     // ... filter to delete one Admin_sessions
     *   }
     * })
     * 
     */
    delete<T extends admin_sessionsDeleteArgs>(args: SelectSubset<T, admin_sessionsDeleteArgs<ExtArgs>>): Prisma__admin_sessionsClient<$Result.GetResult<Prisma.$admin_sessionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Admin_sessions.
     * @param {admin_sessionsUpdateArgs} args - Arguments to update one Admin_sessions.
     * @example
     * // Update one Admin_sessions
     * const admin_sessions = await prisma.admin_sessions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends admin_sessionsUpdateArgs>(args: SelectSubset<T, admin_sessionsUpdateArgs<ExtArgs>>): Prisma__admin_sessionsClient<$Result.GetResult<Prisma.$admin_sessionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Admin_sessions.
     * @param {admin_sessionsDeleteManyArgs} args - Arguments to filter Admin_sessions to delete.
     * @example
     * // Delete a few Admin_sessions
     * const { count } = await prisma.admin_sessions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends admin_sessionsDeleteManyArgs>(args?: SelectSubset<T, admin_sessionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admin_sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admin_sessionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admin_sessions
     * const admin_sessions = await prisma.admin_sessions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends admin_sessionsUpdateManyArgs>(args: SelectSubset<T, admin_sessionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Admin_sessions.
     * @param {admin_sessionsUpsertArgs} args - Arguments to update or create a Admin_sessions.
     * @example
     * // Update or create a Admin_sessions
     * const admin_sessions = await prisma.admin_sessions.upsert({
     *   create: {
     *     // ... data to create a Admin_sessions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin_sessions we want to update
     *   }
     * })
     */
    upsert<T extends admin_sessionsUpsertArgs>(args: SelectSubset<T, admin_sessionsUpsertArgs<ExtArgs>>): Prisma__admin_sessionsClient<$Result.GetResult<Prisma.$admin_sessionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Admin_sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admin_sessionsCountArgs} args - Arguments to filter Admin_sessions to count.
     * @example
     * // Count the number of Admin_sessions
     * const count = await prisma.admin_sessions.count({
     *   where: {
     *     // ... the filter for the Admin_sessions we want to count
     *   }
     * })
    **/
    count<T extends admin_sessionsCountArgs>(
      args?: Subset<T, admin_sessionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Admin_sessionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin_sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Admin_sessionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Admin_sessionsAggregateArgs>(args: Subset<T, Admin_sessionsAggregateArgs>): Prisma.PrismaPromise<GetAdmin_sessionsAggregateType<T>>

    /**
     * Group by Admin_sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admin_sessionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends admin_sessionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: admin_sessionsGroupByArgs['orderBy'] }
        : { orderBy?: admin_sessionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, admin_sessionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdmin_sessionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the admin_sessions model
   */
  readonly fields: admin_sessionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for admin_sessions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__admin_sessionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the admin_sessions model
   */
  interface admin_sessionsFieldRefs {
    readonly id: FieldRef<"admin_sessions", 'String'>
    readonly adminId: FieldRef<"admin_sessions", 'String'>
    readonly token: FieldRef<"admin_sessions", 'String'>
    readonly deviceInfo: FieldRef<"admin_sessions", 'String'>
    readonly ipAddress: FieldRef<"admin_sessions", 'String'>
    readonly userAgent: FieldRef<"admin_sessions", 'String'>
    readonly expiresAt: FieldRef<"admin_sessions", 'DateTime'>
    readonly createdAt: FieldRef<"admin_sessions", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * admin_sessions findUnique
   */
  export type admin_sessionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_sessions
     */
    select?: admin_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin_sessions
     */
    omit?: admin_sessionsOmit<ExtArgs> | null
    /**
     * Filter, which admin_sessions to fetch.
     */
    where: admin_sessionsWhereUniqueInput
  }

  /**
   * admin_sessions findUniqueOrThrow
   */
  export type admin_sessionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_sessions
     */
    select?: admin_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin_sessions
     */
    omit?: admin_sessionsOmit<ExtArgs> | null
    /**
     * Filter, which admin_sessions to fetch.
     */
    where: admin_sessionsWhereUniqueInput
  }

  /**
   * admin_sessions findFirst
   */
  export type admin_sessionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_sessions
     */
    select?: admin_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin_sessions
     */
    omit?: admin_sessionsOmit<ExtArgs> | null
    /**
     * Filter, which admin_sessions to fetch.
     */
    where?: admin_sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admin_sessions to fetch.
     */
    orderBy?: admin_sessionsOrderByWithRelationInput | admin_sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for admin_sessions.
     */
    cursor?: admin_sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admin_sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admin_sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of admin_sessions.
     */
    distinct?: Admin_sessionsScalarFieldEnum | Admin_sessionsScalarFieldEnum[]
  }

  /**
   * admin_sessions findFirstOrThrow
   */
  export type admin_sessionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_sessions
     */
    select?: admin_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin_sessions
     */
    omit?: admin_sessionsOmit<ExtArgs> | null
    /**
     * Filter, which admin_sessions to fetch.
     */
    where?: admin_sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admin_sessions to fetch.
     */
    orderBy?: admin_sessionsOrderByWithRelationInput | admin_sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for admin_sessions.
     */
    cursor?: admin_sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admin_sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admin_sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of admin_sessions.
     */
    distinct?: Admin_sessionsScalarFieldEnum | Admin_sessionsScalarFieldEnum[]
  }

  /**
   * admin_sessions findMany
   */
  export type admin_sessionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_sessions
     */
    select?: admin_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin_sessions
     */
    omit?: admin_sessionsOmit<ExtArgs> | null
    /**
     * Filter, which admin_sessions to fetch.
     */
    where?: admin_sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admin_sessions to fetch.
     */
    orderBy?: admin_sessionsOrderByWithRelationInput | admin_sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing admin_sessions.
     */
    cursor?: admin_sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admin_sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admin_sessions.
     */
    skip?: number
    distinct?: Admin_sessionsScalarFieldEnum | Admin_sessionsScalarFieldEnum[]
  }

  /**
   * admin_sessions create
   */
  export type admin_sessionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_sessions
     */
    select?: admin_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin_sessions
     */
    omit?: admin_sessionsOmit<ExtArgs> | null
    /**
     * The data needed to create a admin_sessions.
     */
    data: XOR<admin_sessionsCreateInput, admin_sessionsUncheckedCreateInput>
  }

  /**
   * admin_sessions createMany
   */
  export type admin_sessionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many admin_sessions.
     */
    data: admin_sessionsCreateManyInput | admin_sessionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * admin_sessions update
   */
  export type admin_sessionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_sessions
     */
    select?: admin_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin_sessions
     */
    omit?: admin_sessionsOmit<ExtArgs> | null
    /**
     * The data needed to update a admin_sessions.
     */
    data: XOR<admin_sessionsUpdateInput, admin_sessionsUncheckedUpdateInput>
    /**
     * Choose, which admin_sessions to update.
     */
    where: admin_sessionsWhereUniqueInput
  }

  /**
   * admin_sessions updateMany
   */
  export type admin_sessionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update admin_sessions.
     */
    data: XOR<admin_sessionsUpdateManyMutationInput, admin_sessionsUncheckedUpdateManyInput>
    /**
     * Filter which admin_sessions to update
     */
    where?: admin_sessionsWhereInput
    /**
     * Limit how many admin_sessions to update.
     */
    limit?: number
  }

  /**
   * admin_sessions upsert
   */
  export type admin_sessionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_sessions
     */
    select?: admin_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin_sessions
     */
    omit?: admin_sessionsOmit<ExtArgs> | null
    /**
     * The filter to search for the admin_sessions to update in case it exists.
     */
    where: admin_sessionsWhereUniqueInput
    /**
     * In case the admin_sessions found by the `where` argument doesn't exist, create a new admin_sessions with this data.
     */
    create: XOR<admin_sessionsCreateInput, admin_sessionsUncheckedCreateInput>
    /**
     * In case the admin_sessions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<admin_sessionsUpdateInput, admin_sessionsUncheckedUpdateInput>
  }

  /**
   * admin_sessions delete
   */
  export type admin_sessionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_sessions
     */
    select?: admin_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin_sessions
     */
    omit?: admin_sessionsOmit<ExtArgs> | null
    /**
     * Filter which admin_sessions to delete.
     */
    where: admin_sessionsWhereUniqueInput
  }

  /**
   * admin_sessions deleteMany
   */
  export type admin_sessionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which admin_sessions to delete
     */
    where?: admin_sessionsWhereInput
    /**
     * Limit how many admin_sessions to delete.
     */
    limit?: number
  }

  /**
   * admin_sessions without action
   */
  export type admin_sessionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_sessions
     */
    select?: admin_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin_sessions
     */
    omit?: admin_sessionsOmit<ExtArgs> | null
  }


  /**
   * Model admins
   */

  export type AggregateAdmins = {
    _count: AdminsCountAggregateOutputType | null
    _min: AdminsMinAggregateOutputType | null
    _max: AdminsMaxAggregateOutputType | null
  }

  export type AdminsMinAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    firstName: string | null
    lastName: string | null
    role: $Enums.admins_role | null
    isActive: boolean | null
    lastLoginAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminsMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    firstName: string | null
    lastName: string | null
    role: $Enums.admins_role | null
    isActive: boolean | null
    lastLoginAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminsCountAggregateOutputType = {
    id: number
    email: number
    password: number
    firstName: number
    lastName: number
    role: number
    isActive: number
    lastLoginAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AdminsMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    firstName?: true
    lastName?: true
    role?: true
    isActive?: true
    lastLoginAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminsMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    firstName?: true
    lastName?: true
    role?: true
    isActive?: true
    lastLoginAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminsCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    firstName?: true
    lastName?: true
    role?: true
    isActive?: true
    lastLoginAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AdminsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which admins to aggregate.
     */
    where?: adminsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admins to fetch.
     */
    orderBy?: adminsOrderByWithRelationInput | adminsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: adminsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned admins
    **/
    _count?: true | AdminsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminsMaxAggregateInputType
  }

  export type GetAdminsAggregateType<T extends AdminsAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmins]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmins[P]>
      : GetScalarType<T[P], AggregateAdmins[P]>
  }




  export type adminsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: adminsWhereInput
    orderBy?: adminsOrderByWithAggregationInput | adminsOrderByWithAggregationInput[]
    by: AdminsScalarFieldEnum[] | AdminsScalarFieldEnum
    having?: adminsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminsCountAggregateInputType | true
    _min?: AdminsMinAggregateInputType
    _max?: AdminsMaxAggregateInputType
  }

  export type AdminsGroupByOutputType = {
    id: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.admins_role
    isActive: boolean
    lastLoginAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: AdminsCountAggregateOutputType | null
    _min: AdminsMinAggregateOutputType | null
    _max: AdminsMaxAggregateOutputType | null
  }

  type GetAdminsGroupByPayload<T extends adminsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminsGroupByOutputType[P]>
            : GetScalarType<T[P], AdminsGroupByOutputType[P]>
        }
      >
    >


  export type adminsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    role?: boolean
    isActive?: boolean
    lastLoginAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["admins"]>



  export type adminsSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    role?: boolean
    isActive?: boolean
    lastLoginAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type adminsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "password" | "firstName" | "lastName" | "role" | "isActive" | "lastLoginAt" | "createdAt" | "updatedAt", ExtArgs["result"]["admins"]>

  export type $adminsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "admins"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password: string
      firstName: string
      lastName: string
      role: $Enums.admins_role
      isActive: boolean
      lastLoginAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["admins"]>
    composites: {}
  }

  type adminsGetPayload<S extends boolean | null | undefined | adminsDefaultArgs> = $Result.GetResult<Prisma.$adminsPayload, S>

  type adminsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<adminsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminsCountAggregateInputType | true
    }

  export interface adminsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['admins'], meta: { name: 'admins' } }
    /**
     * Find zero or one Admins that matches the filter.
     * @param {adminsFindUniqueArgs} args - Arguments to find a Admins
     * @example
     * // Get one Admins
     * const admins = await prisma.admins.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends adminsFindUniqueArgs>(args: SelectSubset<T, adminsFindUniqueArgs<ExtArgs>>): Prisma__adminsClient<$Result.GetResult<Prisma.$adminsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Admins that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {adminsFindUniqueOrThrowArgs} args - Arguments to find a Admins
     * @example
     * // Get one Admins
     * const admins = await prisma.admins.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends adminsFindUniqueOrThrowArgs>(args: SelectSubset<T, adminsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__adminsClient<$Result.GetResult<Prisma.$adminsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminsFindFirstArgs} args - Arguments to find a Admins
     * @example
     * // Get one Admins
     * const admins = await prisma.admins.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends adminsFindFirstArgs>(args?: SelectSubset<T, adminsFindFirstArgs<ExtArgs>>): Prisma__adminsClient<$Result.GetResult<Prisma.$adminsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admins that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminsFindFirstOrThrowArgs} args - Arguments to find a Admins
     * @example
     * // Get one Admins
     * const admins = await prisma.admins.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends adminsFindFirstOrThrowArgs>(args?: SelectSubset<T, adminsFindFirstOrThrowArgs<ExtArgs>>): Prisma__adminsClient<$Result.GetResult<Prisma.$adminsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admins
     * const admins = await prisma.admins.findMany()
     * 
     * // Get first 10 Admins
     * const admins = await prisma.admins.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminsWithIdOnly = await prisma.admins.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends adminsFindManyArgs>(args?: SelectSubset<T, adminsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$adminsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Admins.
     * @param {adminsCreateArgs} args - Arguments to create a Admins.
     * @example
     * // Create one Admins
     * const Admins = await prisma.admins.create({
     *   data: {
     *     // ... data to create a Admins
     *   }
     * })
     * 
     */
    create<T extends adminsCreateArgs>(args: SelectSubset<T, adminsCreateArgs<ExtArgs>>): Prisma__adminsClient<$Result.GetResult<Prisma.$adminsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Admins.
     * @param {adminsCreateManyArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admins = await prisma.admins.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends adminsCreateManyArgs>(args?: SelectSubset<T, adminsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Admins.
     * @param {adminsDeleteArgs} args - Arguments to delete one Admins.
     * @example
     * // Delete one Admins
     * const Admins = await prisma.admins.delete({
     *   where: {
     *     // ... filter to delete one Admins
     *   }
     * })
     * 
     */
    delete<T extends adminsDeleteArgs>(args: SelectSubset<T, adminsDeleteArgs<ExtArgs>>): Prisma__adminsClient<$Result.GetResult<Prisma.$adminsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Admins.
     * @param {adminsUpdateArgs} args - Arguments to update one Admins.
     * @example
     * // Update one Admins
     * const admins = await prisma.admins.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends adminsUpdateArgs>(args: SelectSubset<T, adminsUpdateArgs<ExtArgs>>): Prisma__adminsClient<$Result.GetResult<Prisma.$adminsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Admins.
     * @param {adminsDeleteManyArgs} args - Arguments to filter Admins to delete.
     * @example
     * // Delete a few Admins
     * const { count } = await prisma.admins.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends adminsDeleteManyArgs>(args?: SelectSubset<T, adminsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admins
     * const admins = await prisma.admins.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends adminsUpdateManyArgs>(args: SelectSubset<T, adminsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Admins.
     * @param {adminsUpsertArgs} args - Arguments to update or create a Admins.
     * @example
     * // Update or create a Admins
     * const admins = await prisma.admins.upsert({
     *   create: {
     *     // ... data to create a Admins
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admins we want to update
     *   }
     * })
     */
    upsert<T extends adminsUpsertArgs>(args: SelectSubset<T, adminsUpsertArgs<ExtArgs>>): Prisma__adminsClient<$Result.GetResult<Prisma.$adminsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminsCountArgs} args - Arguments to filter Admins to count.
     * @example
     * // Count the number of Admins
     * const count = await prisma.admins.count({
     *   where: {
     *     // ... the filter for the Admins we want to count
     *   }
     * })
    **/
    count<T extends adminsCountArgs>(
      args?: Subset<T, adminsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminsAggregateArgs>(args: Subset<T, AdminsAggregateArgs>): Prisma.PrismaPromise<GetAdminsAggregateType<T>>

    /**
     * Group by Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends adminsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: adminsGroupByArgs['orderBy'] }
        : { orderBy?: adminsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, adminsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the admins model
   */
  readonly fields: adminsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for admins.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__adminsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the admins model
   */
  interface adminsFieldRefs {
    readonly id: FieldRef<"admins", 'String'>
    readonly email: FieldRef<"admins", 'String'>
    readonly password: FieldRef<"admins", 'String'>
    readonly firstName: FieldRef<"admins", 'String'>
    readonly lastName: FieldRef<"admins", 'String'>
    readonly role: FieldRef<"admins", 'admins_role'>
    readonly isActive: FieldRef<"admins", 'Boolean'>
    readonly lastLoginAt: FieldRef<"admins", 'DateTime'>
    readonly createdAt: FieldRef<"admins", 'DateTime'>
    readonly updatedAt: FieldRef<"admins", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * admins findUnique
   */
  export type adminsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admins
     */
    select?: adminsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admins
     */
    omit?: adminsOmit<ExtArgs> | null
    /**
     * Filter, which admins to fetch.
     */
    where: adminsWhereUniqueInput
  }

  /**
   * admins findUniqueOrThrow
   */
  export type adminsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admins
     */
    select?: adminsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admins
     */
    omit?: adminsOmit<ExtArgs> | null
    /**
     * Filter, which admins to fetch.
     */
    where: adminsWhereUniqueInput
  }

  /**
   * admins findFirst
   */
  export type adminsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admins
     */
    select?: adminsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admins
     */
    omit?: adminsOmit<ExtArgs> | null
    /**
     * Filter, which admins to fetch.
     */
    where?: adminsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admins to fetch.
     */
    orderBy?: adminsOrderByWithRelationInput | adminsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for admins.
     */
    cursor?: adminsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of admins.
     */
    distinct?: AdminsScalarFieldEnum | AdminsScalarFieldEnum[]
  }

  /**
   * admins findFirstOrThrow
   */
  export type adminsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admins
     */
    select?: adminsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admins
     */
    omit?: adminsOmit<ExtArgs> | null
    /**
     * Filter, which admins to fetch.
     */
    where?: adminsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admins to fetch.
     */
    orderBy?: adminsOrderByWithRelationInput | adminsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for admins.
     */
    cursor?: adminsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of admins.
     */
    distinct?: AdminsScalarFieldEnum | AdminsScalarFieldEnum[]
  }

  /**
   * admins findMany
   */
  export type adminsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admins
     */
    select?: adminsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admins
     */
    omit?: adminsOmit<ExtArgs> | null
    /**
     * Filter, which admins to fetch.
     */
    where?: adminsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admins to fetch.
     */
    orderBy?: adminsOrderByWithRelationInput | adminsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing admins.
     */
    cursor?: adminsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admins.
     */
    skip?: number
    distinct?: AdminsScalarFieldEnum | AdminsScalarFieldEnum[]
  }

  /**
   * admins create
   */
  export type adminsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admins
     */
    select?: adminsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admins
     */
    omit?: adminsOmit<ExtArgs> | null
    /**
     * The data needed to create a admins.
     */
    data: XOR<adminsCreateInput, adminsUncheckedCreateInput>
  }

  /**
   * admins createMany
   */
  export type adminsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many admins.
     */
    data: adminsCreateManyInput | adminsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * admins update
   */
  export type adminsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admins
     */
    select?: adminsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admins
     */
    omit?: adminsOmit<ExtArgs> | null
    /**
     * The data needed to update a admins.
     */
    data: XOR<adminsUpdateInput, adminsUncheckedUpdateInput>
    /**
     * Choose, which admins to update.
     */
    where: adminsWhereUniqueInput
  }

  /**
   * admins updateMany
   */
  export type adminsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update admins.
     */
    data: XOR<adminsUpdateManyMutationInput, adminsUncheckedUpdateManyInput>
    /**
     * Filter which admins to update
     */
    where?: adminsWhereInput
    /**
     * Limit how many admins to update.
     */
    limit?: number
  }

  /**
   * admins upsert
   */
  export type adminsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admins
     */
    select?: adminsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admins
     */
    omit?: adminsOmit<ExtArgs> | null
    /**
     * The filter to search for the admins to update in case it exists.
     */
    where: adminsWhereUniqueInput
    /**
     * In case the admins found by the `where` argument doesn't exist, create a new admins with this data.
     */
    create: XOR<adminsCreateInput, adminsUncheckedCreateInput>
    /**
     * In case the admins was found with the provided `where` argument, update it with this data.
     */
    update: XOR<adminsUpdateInput, adminsUncheckedUpdateInput>
  }

  /**
   * admins delete
   */
  export type adminsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admins
     */
    select?: adminsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admins
     */
    omit?: adminsOmit<ExtArgs> | null
    /**
     * Filter which admins to delete.
     */
    where: adminsWhereUniqueInput
  }

  /**
   * admins deleteMany
   */
  export type adminsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which admins to delete
     */
    where?: adminsWhereInput
    /**
     * Limit how many admins to delete.
     */
    limit?: number
  }

  /**
   * admins without action
   */
  export type adminsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admins
     */
    select?: adminsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admins
     */
    omit?: adminsOmit<ExtArgs> | null
  }


  /**
   * Model agent_customers
   */

  export type AggregateAgent_customers = {
    _count: Agent_customersCountAggregateOutputType | null
    _min: Agent_customersMinAggregateOutputType | null
    _max: Agent_customersMaxAggregateOutputType | null
  }

  export type Agent_customersMinAggregateOutputType = {
    id: string | null
    agentId: string | null
    customerId: string | null
    assignedAt: Date | null
    isActive: boolean | null
  }

  export type Agent_customersMaxAggregateOutputType = {
    id: string | null
    agentId: string | null
    customerId: string | null
    assignedAt: Date | null
    isActive: boolean | null
  }

  export type Agent_customersCountAggregateOutputType = {
    id: number
    agentId: number
    customerId: number
    assignedAt: number
    isActive: number
    _all: number
  }


  export type Agent_customersMinAggregateInputType = {
    id?: true
    agentId?: true
    customerId?: true
    assignedAt?: true
    isActive?: true
  }

  export type Agent_customersMaxAggregateInputType = {
    id?: true
    agentId?: true
    customerId?: true
    assignedAt?: true
    isActive?: true
  }

  export type Agent_customersCountAggregateInputType = {
    id?: true
    agentId?: true
    customerId?: true
    assignedAt?: true
    isActive?: true
    _all?: true
  }

  export type Agent_customersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which agent_customers to aggregate.
     */
    where?: agent_customersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of agent_customers to fetch.
     */
    orderBy?: agent_customersOrderByWithRelationInput | agent_customersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: agent_customersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` agent_customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` agent_customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned agent_customers
    **/
    _count?: true | Agent_customersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Agent_customersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Agent_customersMaxAggregateInputType
  }

  export type GetAgent_customersAggregateType<T extends Agent_customersAggregateArgs> = {
        [P in keyof T & keyof AggregateAgent_customers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgent_customers[P]>
      : GetScalarType<T[P], AggregateAgent_customers[P]>
  }




  export type agent_customersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: agent_customersWhereInput
    orderBy?: agent_customersOrderByWithAggregationInput | agent_customersOrderByWithAggregationInput[]
    by: Agent_customersScalarFieldEnum[] | Agent_customersScalarFieldEnum
    having?: agent_customersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Agent_customersCountAggregateInputType | true
    _min?: Agent_customersMinAggregateInputType
    _max?: Agent_customersMaxAggregateInputType
  }

  export type Agent_customersGroupByOutputType = {
    id: string
    agentId: string
    customerId: string
    assignedAt: Date
    isActive: boolean
    _count: Agent_customersCountAggregateOutputType | null
    _min: Agent_customersMinAggregateOutputType | null
    _max: Agent_customersMaxAggregateOutputType | null
  }

  type GetAgent_customersGroupByPayload<T extends agent_customersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Agent_customersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Agent_customersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Agent_customersGroupByOutputType[P]>
            : GetScalarType<T[P], Agent_customersGroupByOutputType[P]>
        }
      >
    >


  export type agent_customersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    customerId?: boolean
    assignedAt?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["agent_customers"]>



  export type agent_customersSelectScalar = {
    id?: boolean
    agentId?: boolean
    customerId?: boolean
    assignedAt?: boolean
    isActive?: boolean
  }

  export type agent_customersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "agentId" | "customerId" | "assignedAt" | "isActive", ExtArgs["result"]["agent_customers"]>

  export type $agent_customersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "agent_customers"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      agentId: string
      customerId: string
      assignedAt: Date
      isActive: boolean
    }, ExtArgs["result"]["agent_customers"]>
    composites: {}
  }

  type agent_customersGetPayload<S extends boolean | null | undefined | agent_customersDefaultArgs> = $Result.GetResult<Prisma.$agent_customersPayload, S>

  type agent_customersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<agent_customersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Agent_customersCountAggregateInputType | true
    }

  export interface agent_customersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['agent_customers'], meta: { name: 'agent_customers' } }
    /**
     * Find zero or one Agent_customers that matches the filter.
     * @param {agent_customersFindUniqueArgs} args - Arguments to find a Agent_customers
     * @example
     * // Get one Agent_customers
     * const agent_customers = await prisma.agent_customers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends agent_customersFindUniqueArgs>(args: SelectSubset<T, agent_customersFindUniqueArgs<ExtArgs>>): Prisma__agent_customersClient<$Result.GetResult<Prisma.$agent_customersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Agent_customers that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {agent_customersFindUniqueOrThrowArgs} args - Arguments to find a Agent_customers
     * @example
     * // Get one Agent_customers
     * const agent_customers = await prisma.agent_customers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends agent_customersFindUniqueOrThrowArgs>(args: SelectSubset<T, agent_customersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__agent_customersClient<$Result.GetResult<Prisma.$agent_customersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Agent_customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agent_customersFindFirstArgs} args - Arguments to find a Agent_customers
     * @example
     * // Get one Agent_customers
     * const agent_customers = await prisma.agent_customers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends agent_customersFindFirstArgs>(args?: SelectSubset<T, agent_customersFindFirstArgs<ExtArgs>>): Prisma__agent_customersClient<$Result.GetResult<Prisma.$agent_customersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Agent_customers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agent_customersFindFirstOrThrowArgs} args - Arguments to find a Agent_customers
     * @example
     * // Get one Agent_customers
     * const agent_customers = await prisma.agent_customers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends agent_customersFindFirstOrThrowArgs>(args?: SelectSubset<T, agent_customersFindFirstOrThrowArgs<ExtArgs>>): Prisma__agent_customersClient<$Result.GetResult<Prisma.$agent_customersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Agent_customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agent_customersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Agent_customers
     * const agent_customers = await prisma.agent_customers.findMany()
     * 
     * // Get first 10 Agent_customers
     * const agent_customers = await prisma.agent_customers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agent_customersWithIdOnly = await prisma.agent_customers.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends agent_customersFindManyArgs>(args?: SelectSubset<T, agent_customersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$agent_customersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Agent_customers.
     * @param {agent_customersCreateArgs} args - Arguments to create a Agent_customers.
     * @example
     * // Create one Agent_customers
     * const Agent_customers = await prisma.agent_customers.create({
     *   data: {
     *     // ... data to create a Agent_customers
     *   }
     * })
     * 
     */
    create<T extends agent_customersCreateArgs>(args: SelectSubset<T, agent_customersCreateArgs<ExtArgs>>): Prisma__agent_customersClient<$Result.GetResult<Prisma.$agent_customersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Agent_customers.
     * @param {agent_customersCreateManyArgs} args - Arguments to create many Agent_customers.
     * @example
     * // Create many Agent_customers
     * const agent_customers = await prisma.agent_customers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends agent_customersCreateManyArgs>(args?: SelectSubset<T, agent_customersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Agent_customers.
     * @param {agent_customersDeleteArgs} args - Arguments to delete one Agent_customers.
     * @example
     * // Delete one Agent_customers
     * const Agent_customers = await prisma.agent_customers.delete({
     *   where: {
     *     // ... filter to delete one Agent_customers
     *   }
     * })
     * 
     */
    delete<T extends agent_customersDeleteArgs>(args: SelectSubset<T, agent_customersDeleteArgs<ExtArgs>>): Prisma__agent_customersClient<$Result.GetResult<Prisma.$agent_customersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Agent_customers.
     * @param {agent_customersUpdateArgs} args - Arguments to update one Agent_customers.
     * @example
     * // Update one Agent_customers
     * const agent_customers = await prisma.agent_customers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends agent_customersUpdateArgs>(args: SelectSubset<T, agent_customersUpdateArgs<ExtArgs>>): Prisma__agent_customersClient<$Result.GetResult<Prisma.$agent_customersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Agent_customers.
     * @param {agent_customersDeleteManyArgs} args - Arguments to filter Agent_customers to delete.
     * @example
     * // Delete a few Agent_customers
     * const { count } = await prisma.agent_customers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends agent_customersDeleteManyArgs>(args?: SelectSubset<T, agent_customersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Agent_customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agent_customersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Agent_customers
     * const agent_customers = await prisma.agent_customers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends agent_customersUpdateManyArgs>(args: SelectSubset<T, agent_customersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Agent_customers.
     * @param {agent_customersUpsertArgs} args - Arguments to update or create a Agent_customers.
     * @example
     * // Update or create a Agent_customers
     * const agent_customers = await prisma.agent_customers.upsert({
     *   create: {
     *     // ... data to create a Agent_customers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Agent_customers we want to update
     *   }
     * })
     */
    upsert<T extends agent_customersUpsertArgs>(args: SelectSubset<T, agent_customersUpsertArgs<ExtArgs>>): Prisma__agent_customersClient<$Result.GetResult<Prisma.$agent_customersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Agent_customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agent_customersCountArgs} args - Arguments to filter Agent_customers to count.
     * @example
     * // Count the number of Agent_customers
     * const count = await prisma.agent_customers.count({
     *   where: {
     *     // ... the filter for the Agent_customers we want to count
     *   }
     * })
    **/
    count<T extends agent_customersCountArgs>(
      args?: Subset<T, agent_customersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Agent_customersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Agent_customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Agent_customersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Agent_customersAggregateArgs>(args: Subset<T, Agent_customersAggregateArgs>): Prisma.PrismaPromise<GetAgent_customersAggregateType<T>>

    /**
     * Group by Agent_customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agent_customersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends agent_customersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: agent_customersGroupByArgs['orderBy'] }
        : { orderBy?: agent_customersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, agent_customersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgent_customersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the agent_customers model
   */
  readonly fields: agent_customersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for agent_customers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__agent_customersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the agent_customers model
   */
  interface agent_customersFieldRefs {
    readonly id: FieldRef<"agent_customers", 'String'>
    readonly agentId: FieldRef<"agent_customers", 'String'>
    readonly customerId: FieldRef<"agent_customers", 'String'>
    readonly assignedAt: FieldRef<"agent_customers", 'DateTime'>
    readonly isActive: FieldRef<"agent_customers", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * agent_customers findUnique
   */
  export type agent_customersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agent_customers
     */
    select?: agent_customersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agent_customers
     */
    omit?: agent_customersOmit<ExtArgs> | null
    /**
     * Filter, which agent_customers to fetch.
     */
    where: agent_customersWhereUniqueInput
  }

  /**
   * agent_customers findUniqueOrThrow
   */
  export type agent_customersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agent_customers
     */
    select?: agent_customersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agent_customers
     */
    omit?: agent_customersOmit<ExtArgs> | null
    /**
     * Filter, which agent_customers to fetch.
     */
    where: agent_customersWhereUniqueInput
  }

  /**
   * agent_customers findFirst
   */
  export type agent_customersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agent_customers
     */
    select?: agent_customersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agent_customers
     */
    omit?: agent_customersOmit<ExtArgs> | null
    /**
     * Filter, which agent_customers to fetch.
     */
    where?: agent_customersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of agent_customers to fetch.
     */
    orderBy?: agent_customersOrderByWithRelationInput | agent_customersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for agent_customers.
     */
    cursor?: agent_customersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` agent_customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` agent_customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of agent_customers.
     */
    distinct?: Agent_customersScalarFieldEnum | Agent_customersScalarFieldEnum[]
  }

  /**
   * agent_customers findFirstOrThrow
   */
  export type agent_customersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agent_customers
     */
    select?: agent_customersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agent_customers
     */
    omit?: agent_customersOmit<ExtArgs> | null
    /**
     * Filter, which agent_customers to fetch.
     */
    where?: agent_customersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of agent_customers to fetch.
     */
    orderBy?: agent_customersOrderByWithRelationInput | agent_customersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for agent_customers.
     */
    cursor?: agent_customersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` agent_customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` agent_customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of agent_customers.
     */
    distinct?: Agent_customersScalarFieldEnum | Agent_customersScalarFieldEnum[]
  }

  /**
   * agent_customers findMany
   */
  export type agent_customersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agent_customers
     */
    select?: agent_customersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agent_customers
     */
    omit?: agent_customersOmit<ExtArgs> | null
    /**
     * Filter, which agent_customers to fetch.
     */
    where?: agent_customersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of agent_customers to fetch.
     */
    orderBy?: agent_customersOrderByWithRelationInput | agent_customersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing agent_customers.
     */
    cursor?: agent_customersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` agent_customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` agent_customers.
     */
    skip?: number
    distinct?: Agent_customersScalarFieldEnum | Agent_customersScalarFieldEnum[]
  }

  /**
   * agent_customers create
   */
  export type agent_customersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agent_customers
     */
    select?: agent_customersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agent_customers
     */
    omit?: agent_customersOmit<ExtArgs> | null
    /**
     * The data needed to create a agent_customers.
     */
    data: XOR<agent_customersCreateInput, agent_customersUncheckedCreateInput>
  }

  /**
   * agent_customers createMany
   */
  export type agent_customersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many agent_customers.
     */
    data: agent_customersCreateManyInput | agent_customersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * agent_customers update
   */
  export type agent_customersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agent_customers
     */
    select?: agent_customersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agent_customers
     */
    omit?: agent_customersOmit<ExtArgs> | null
    /**
     * The data needed to update a agent_customers.
     */
    data: XOR<agent_customersUpdateInput, agent_customersUncheckedUpdateInput>
    /**
     * Choose, which agent_customers to update.
     */
    where: agent_customersWhereUniqueInput
  }

  /**
   * agent_customers updateMany
   */
  export type agent_customersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update agent_customers.
     */
    data: XOR<agent_customersUpdateManyMutationInput, agent_customersUncheckedUpdateManyInput>
    /**
     * Filter which agent_customers to update
     */
    where?: agent_customersWhereInput
    /**
     * Limit how many agent_customers to update.
     */
    limit?: number
  }

  /**
   * agent_customers upsert
   */
  export type agent_customersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agent_customers
     */
    select?: agent_customersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agent_customers
     */
    omit?: agent_customersOmit<ExtArgs> | null
    /**
     * The filter to search for the agent_customers to update in case it exists.
     */
    where: agent_customersWhereUniqueInput
    /**
     * In case the agent_customers found by the `where` argument doesn't exist, create a new agent_customers with this data.
     */
    create: XOR<agent_customersCreateInput, agent_customersUncheckedCreateInput>
    /**
     * In case the agent_customers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<agent_customersUpdateInput, agent_customersUncheckedUpdateInput>
  }

  /**
   * agent_customers delete
   */
  export type agent_customersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agent_customers
     */
    select?: agent_customersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agent_customers
     */
    omit?: agent_customersOmit<ExtArgs> | null
    /**
     * Filter which agent_customers to delete.
     */
    where: agent_customersWhereUniqueInput
  }

  /**
   * agent_customers deleteMany
   */
  export type agent_customersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which agent_customers to delete
     */
    where?: agent_customersWhereInput
    /**
     * Limit how many agent_customers to delete.
     */
    limit?: number
  }

  /**
   * agent_customers without action
   */
  export type agent_customersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agent_customers
     */
    select?: agent_customersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agent_customers
     */
    omit?: agent_customersOmit<ExtArgs> | null
  }


  /**
   * Model audit_logs
   */

  export type AggregateAudit_logs = {
    _count: Audit_logsCountAggregateOutputType | null
    _min: Audit_logsMinAggregateOutputType | null
    _max: Audit_logsMaxAggregateOutputType | null
  }

  export type Audit_logsMinAggregateOutputType = {
    id: string | null
    action: string | null
    entity: string | null
    entityId: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
    adminId: string | null
  }

  export type Audit_logsMaxAggregateOutputType = {
    id: string | null
    action: string | null
    entity: string | null
    entityId: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
    adminId: string | null
  }

  export type Audit_logsCountAggregateOutputType = {
    id: number
    action: number
    entity: number
    entityId: number
    oldData: number
    newData: number
    ipAddress: number
    userAgent: number
    createdAt: number
    adminId: number
    _all: number
  }


  export type Audit_logsMinAggregateInputType = {
    id?: true
    action?: true
    entity?: true
    entityId?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    adminId?: true
  }

  export type Audit_logsMaxAggregateInputType = {
    id?: true
    action?: true
    entity?: true
    entityId?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    adminId?: true
  }

  export type Audit_logsCountAggregateInputType = {
    id?: true
    action?: true
    entity?: true
    entityId?: true
    oldData?: true
    newData?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    adminId?: true
    _all?: true
  }

  export type Audit_logsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which audit_logs to aggregate.
     */
    where?: audit_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of audit_logs to fetch.
     */
    orderBy?: audit_logsOrderByWithRelationInput | audit_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: audit_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` audit_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` audit_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned audit_logs
    **/
    _count?: true | Audit_logsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Audit_logsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Audit_logsMaxAggregateInputType
  }

  export type GetAudit_logsAggregateType<T extends Audit_logsAggregateArgs> = {
        [P in keyof T & keyof AggregateAudit_logs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAudit_logs[P]>
      : GetScalarType<T[P], AggregateAudit_logs[P]>
  }




  export type audit_logsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: audit_logsWhereInput
    orderBy?: audit_logsOrderByWithAggregationInput | audit_logsOrderByWithAggregationInput[]
    by: Audit_logsScalarFieldEnum[] | Audit_logsScalarFieldEnum
    having?: audit_logsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Audit_logsCountAggregateInputType | true
    _min?: Audit_logsMinAggregateInputType
    _max?: Audit_logsMaxAggregateInputType
  }

  export type Audit_logsGroupByOutputType = {
    id: string
    action: string
    entity: string
    entityId: string
    oldData: JsonValue | null
    newData: JsonValue | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date
    adminId: string | null
    _count: Audit_logsCountAggregateOutputType | null
    _min: Audit_logsMinAggregateOutputType | null
    _max: Audit_logsMaxAggregateOutputType | null
  }

  type GetAudit_logsGroupByPayload<T extends audit_logsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Audit_logsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Audit_logsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Audit_logsGroupByOutputType[P]>
            : GetScalarType<T[P], Audit_logsGroupByOutputType[P]>
        }
      >
    >


  export type audit_logsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    oldData?: boolean
    newData?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    adminId?: boolean
  }, ExtArgs["result"]["audit_logs"]>



  export type audit_logsSelectScalar = {
    id?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    oldData?: boolean
    newData?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    adminId?: boolean
  }

  export type audit_logsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "action" | "entity" | "entityId" | "oldData" | "newData" | "ipAddress" | "userAgent" | "createdAt" | "adminId", ExtArgs["result"]["audit_logs"]>

  export type $audit_logsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "audit_logs"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      action: string
      entity: string
      entityId: string
      oldData: Prisma.JsonValue | null
      newData: Prisma.JsonValue | null
      ipAddress: string | null
      userAgent: string | null
      createdAt: Date
      adminId: string | null
    }, ExtArgs["result"]["audit_logs"]>
    composites: {}
  }

  type audit_logsGetPayload<S extends boolean | null | undefined | audit_logsDefaultArgs> = $Result.GetResult<Prisma.$audit_logsPayload, S>

  type audit_logsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<audit_logsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Audit_logsCountAggregateInputType | true
    }

  export interface audit_logsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['audit_logs'], meta: { name: 'audit_logs' } }
    /**
     * Find zero or one Audit_logs that matches the filter.
     * @param {audit_logsFindUniqueArgs} args - Arguments to find a Audit_logs
     * @example
     * // Get one Audit_logs
     * const audit_logs = await prisma.audit_logs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends audit_logsFindUniqueArgs>(args: SelectSubset<T, audit_logsFindUniqueArgs<ExtArgs>>): Prisma__audit_logsClient<$Result.GetResult<Prisma.$audit_logsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Audit_logs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {audit_logsFindUniqueOrThrowArgs} args - Arguments to find a Audit_logs
     * @example
     * // Get one Audit_logs
     * const audit_logs = await prisma.audit_logs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends audit_logsFindUniqueOrThrowArgs>(args: SelectSubset<T, audit_logsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__audit_logsClient<$Result.GetResult<Prisma.$audit_logsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Audit_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {audit_logsFindFirstArgs} args - Arguments to find a Audit_logs
     * @example
     * // Get one Audit_logs
     * const audit_logs = await prisma.audit_logs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends audit_logsFindFirstArgs>(args?: SelectSubset<T, audit_logsFindFirstArgs<ExtArgs>>): Prisma__audit_logsClient<$Result.GetResult<Prisma.$audit_logsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Audit_logs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {audit_logsFindFirstOrThrowArgs} args - Arguments to find a Audit_logs
     * @example
     * // Get one Audit_logs
     * const audit_logs = await prisma.audit_logs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends audit_logsFindFirstOrThrowArgs>(args?: SelectSubset<T, audit_logsFindFirstOrThrowArgs<ExtArgs>>): Prisma__audit_logsClient<$Result.GetResult<Prisma.$audit_logsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Audit_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {audit_logsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Audit_logs
     * const audit_logs = await prisma.audit_logs.findMany()
     * 
     * // Get first 10 Audit_logs
     * const audit_logs = await prisma.audit_logs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const audit_logsWithIdOnly = await prisma.audit_logs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends audit_logsFindManyArgs>(args?: SelectSubset<T, audit_logsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$audit_logsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Audit_logs.
     * @param {audit_logsCreateArgs} args - Arguments to create a Audit_logs.
     * @example
     * // Create one Audit_logs
     * const Audit_logs = await prisma.audit_logs.create({
     *   data: {
     *     // ... data to create a Audit_logs
     *   }
     * })
     * 
     */
    create<T extends audit_logsCreateArgs>(args: SelectSubset<T, audit_logsCreateArgs<ExtArgs>>): Prisma__audit_logsClient<$Result.GetResult<Prisma.$audit_logsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Audit_logs.
     * @param {audit_logsCreateManyArgs} args - Arguments to create many Audit_logs.
     * @example
     * // Create many Audit_logs
     * const audit_logs = await prisma.audit_logs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends audit_logsCreateManyArgs>(args?: SelectSubset<T, audit_logsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Audit_logs.
     * @param {audit_logsDeleteArgs} args - Arguments to delete one Audit_logs.
     * @example
     * // Delete one Audit_logs
     * const Audit_logs = await prisma.audit_logs.delete({
     *   where: {
     *     // ... filter to delete one Audit_logs
     *   }
     * })
     * 
     */
    delete<T extends audit_logsDeleteArgs>(args: SelectSubset<T, audit_logsDeleteArgs<ExtArgs>>): Prisma__audit_logsClient<$Result.GetResult<Prisma.$audit_logsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Audit_logs.
     * @param {audit_logsUpdateArgs} args - Arguments to update one Audit_logs.
     * @example
     * // Update one Audit_logs
     * const audit_logs = await prisma.audit_logs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends audit_logsUpdateArgs>(args: SelectSubset<T, audit_logsUpdateArgs<ExtArgs>>): Prisma__audit_logsClient<$Result.GetResult<Prisma.$audit_logsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Audit_logs.
     * @param {audit_logsDeleteManyArgs} args - Arguments to filter Audit_logs to delete.
     * @example
     * // Delete a few Audit_logs
     * const { count } = await prisma.audit_logs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends audit_logsDeleteManyArgs>(args?: SelectSubset<T, audit_logsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Audit_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {audit_logsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Audit_logs
     * const audit_logs = await prisma.audit_logs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends audit_logsUpdateManyArgs>(args: SelectSubset<T, audit_logsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Audit_logs.
     * @param {audit_logsUpsertArgs} args - Arguments to update or create a Audit_logs.
     * @example
     * // Update or create a Audit_logs
     * const audit_logs = await prisma.audit_logs.upsert({
     *   create: {
     *     // ... data to create a Audit_logs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Audit_logs we want to update
     *   }
     * })
     */
    upsert<T extends audit_logsUpsertArgs>(args: SelectSubset<T, audit_logsUpsertArgs<ExtArgs>>): Prisma__audit_logsClient<$Result.GetResult<Prisma.$audit_logsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Audit_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {audit_logsCountArgs} args - Arguments to filter Audit_logs to count.
     * @example
     * // Count the number of Audit_logs
     * const count = await prisma.audit_logs.count({
     *   where: {
     *     // ... the filter for the Audit_logs we want to count
     *   }
     * })
    **/
    count<T extends audit_logsCountArgs>(
      args?: Subset<T, audit_logsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Audit_logsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Audit_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Audit_logsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Audit_logsAggregateArgs>(args: Subset<T, Audit_logsAggregateArgs>): Prisma.PrismaPromise<GetAudit_logsAggregateType<T>>

    /**
     * Group by Audit_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {audit_logsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends audit_logsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: audit_logsGroupByArgs['orderBy'] }
        : { orderBy?: audit_logsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, audit_logsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAudit_logsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the audit_logs model
   */
  readonly fields: audit_logsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for audit_logs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__audit_logsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the audit_logs model
   */
  interface audit_logsFieldRefs {
    readonly id: FieldRef<"audit_logs", 'String'>
    readonly action: FieldRef<"audit_logs", 'String'>
    readonly entity: FieldRef<"audit_logs", 'String'>
    readonly entityId: FieldRef<"audit_logs", 'String'>
    readonly oldData: FieldRef<"audit_logs", 'Json'>
    readonly newData: FieldRef<"audit_logs", 'Json'>
    readonly ipAddress: FieldRef<"audit_logs", 'String'>
    readonly userAgent: FieldRef<"audit_logs", 'String'>
    readonly createdAt: FieldRef<"audit_logs", 'DateTime'>
    readonly adminId: FieldRef<"audit_logs", 'String'>
  }
    

  // Custom InputTypes
  /**
   * audit_logs findUnique
   */
  export type audit_logsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_logs
     */
    select?: audit_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_logs
     */
    omit?: audit_logsOmit<ExtArgs> | null
    /**
     * Filter, which audit_logs to fetch.
     */
    where: audit_logsWhereUniqueInput
  }

  /**
   * audit_logs findUniqueOrThrow
   */
  export type audit_logsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_logs
     */
    select?: audit_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_logs
     */
    omit?: audit_logsOmit<ExtArgs> | null
    /**
     * Filter, which audit_logs to fetch.
     */
    where: audit_logsWhereUniqueInput
  }

  /**
   * audit_logs findFirst
   */
  export type audit_logsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_logs
     */
    select?: audit_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_logs
     */
    omit?: audit_logsOmit<ExtArgs> | null
    /**
     * Filter, which audit_logs to fetch.
     */
    where?: audit_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of audit_logs to fetch.
     */
    orderBy?: audit_logsOrderByWithRelationInput | audit_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for audit_logs.
     */
    cursor?: audit_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` audit_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` audit_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of audit_logs.
     */
    distinct?: Audit_logsScalarFieldEnum | Audit_logsScalarFieldEnum[]
  }

  /**
   * audit_logs findFirstOrThrow
   */
  export type audit_logsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_logs
     */
    select?: audit_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_logs
     */
    omit?: audit_logsOmit<ExtArgs> | null
    /**
     * Filter, which audit_logs to fetch.
     */
    where?: audit_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of audit_logs to fetch.
     */
    orderBy?: audit_logsOrderByWithRelationInput | audit_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for audit_logs.
     */
    cursor?: audit_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` audit_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` audit_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of audit_logs.
     */
    distinct?: Audit_logsScalarFieldEnum | Audit_logsScalarFieldEnum[]
  }

  /**
   * audit_logs findMany
   */
  export type audit_logsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_logs
     */
    select?: audit_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_logs
     */
    omit?: audit_logsOmit<ExtArgs> | null
    /**
     * Filter, which audit_logs to fetch.
     */
    where?: audit_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of audit_logs to fetch.
     */
    orderBy?: audit_logsOrderByWithRelationInput | audit_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing audit_logs.
     */
    cursor?: audit_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` audit_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` audit_logs.
     */
    skip?: number
    distinct?: Audit_logsScalarFieldEnum | Audit_logsScalarFieldEnum[]
  }

  /**
   * audit_logs create
   */
  export type audit_logsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_logs
     */
    select?: audit_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_logs
     */
    omit?: audit_logsOmit<ExtArgs> | null
    /**
     * The data needed to create a audit_logs.
     */
    data: XOR<audit_logsCreateInput, audit_logsUncheckedCreateInput>
  }

  /**
   * audit_logs createMany
   */
  export type audit_logsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many audit_logs.
     */
    data: audit_logsCreateManyInput | audit_logsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * audit_logs update
   */
  export type audit_logsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_logs
     */
    select?: audit_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_logs
     */
    omit?: audit_logsOmit<ExtArgs> | null
    /**
     * The data needed to update a audit_logs.
     */
    data: XOR<audit_logsUpdateInput, audit_logsUncheckedUpdateInput>
    /**
     * Choose, which audit_logs to update.
     */
    where: audit_logsWhereUniqueInput
  }

  /**
   * audit_logs updateMany
   */
  export type audit_logsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update audit_logs.
     */
    data: XOR<audit_logsUpdateManyMutationInput, audit_logsUncheckedUpdateManyInput>
    /**
     * Filter which audit_logs to update
     */
    where?: audit_logsWhereInput
    /**
     * Limit how many audit_logs to update.
     */
    limit?: number
  }

  /**
   * audit_logs upsert
   */
  export type audit_logsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_logs
     */
    select?: audit_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_logs
     */
    omit?: audit_logsOmit<ExtArgs> | null
    /**
     * The filter to search for the audit_logs to update in case it exists.
     */
    where: audit_logsWhereUniqueInput
    /**
     * In case the audit_logs found by the `where` argument doesn't exist, create a new audit_logs with this data.
     */
    create: XOR<audit_logsCreateInput, audit_logsUncheckedCreateInput>
    /**
     * In case the audit_logs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<audit_logsUpdateInput, audit_logsUncheckedUpdateInput>
  }

  /**
   * audit_logs delete
   */
  export type audit_logsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_logs
     */
    select?: audit_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_logs
     */
    omit?: audit_logsOmit<ExtArgs> | null
    /**
     * Filter which audit_logs to delete.
     */
    where: audit_logsWhereUniqueInput
  }

  /**
   * audit_logs deleteMany
   */
  export type audit_logsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which audit_logs to delete
     */
    where?: audit_logsWhereInput
    /**
     * Limit how many audit_logs to delete.
     */
    limit?: number
  }

  /**
   * audit_logs without action
   */
  export type audit_logsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_logs
     */
    select?: audit_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_logs
     */
    omit?: audit_logsOmit<ExtArgs> | null
  }


  /**
   * Model banners
   */

  export type AggregateBanners = {
    _count: BannersCountAggregateOutputType | null
    _avg: BannersAvgAggregateOutputType | null
    _sum: BannersSumAggregateOutputType | null
    _min: BannersMinAggregateOutputType | null
    _max: BannersMaxAggregateOutputType | null
  }

  export type BannersAvgAggregateOutputType = {
    sortOrder: number | null
  }

  export type BannersSumAggregateOutputType = {
    sortOrder: number | null
  }

  export type BannersMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    imageUrl: string | null
    actionUrl: string | null
    isActive: boolean | null
    sortOrder: number | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BannersMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    imageUrl: string | null
    actionUrl: string | null
    isActive: boolean | null
    sortOrder: number | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BannersCountAggregateOutputType = {
    id: number
    title: number
    description: number
    imageUrl: number
    actionUrl: number
    isActive: number
    sortOrder: number
    targetUserTypes: number
    startDate: number
    endDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BannersAvgAggregateInputType = {
    sortOrder?: true
  }

  export type BannersSumAggregateInputType = {
    sortOrder?: true
  }

  export type BannersMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    imageUrl?: true
    actionUrl?: true
    isActive?: true
    sortOrder?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BannersMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    imageUrl?: true
    actionUrl?: true
    isActive?: true
    sortOrder?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BannersCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    imageUrl?: true
    actionUrl?: true
    isActive?: true
    sortOrder?: true
    targetUserTypes?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BannersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which banners to aggregate.
     */
    where?: bannersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of banners to fetch.
     */
    orderBy?: bannersOrderByWithRelationInput | bannersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: bannersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` banners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` banners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned banners
    **/
    _count?: true | BannersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BannersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BannersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BannersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BannersMaxAggregateInputType
  }

  export type GetBannersAggregateType<T extends BannersAggregateArgs> = {
        [P in keyof T & keyof AggregateBanners]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBanners[P]>
      : GetScalarType<T[P], AggregateBanners[P]>
  }




  export type bannersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bannersWhereInput
    orderBy?: bannersOrderByWithAggregationInput | bannersOrderByWithAggregationInput[]
    by: BannersScalarFieldEnum[] | BannersScalarFieldEnum
    having?: bannersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BannersCountAggregateInputType | true
    _avg?: BannersAvgAggregateInputType
    _sum?: BannersSumAggregateInputType
    _min?: BannersMinAggregateInputType
    _max?: BannersMaxAggregateInputType
  }

  export type BannersGroupByOutputType = {
    id: string
    title: string
    description: string | null
    imageUrl: string
    actionUrl: string | null
    isActive: boolean
    sortOrder: number
    targetUserTypes: JsonValue
    startDate: Date | null
    endDate: Date | null
    createdAt: Date
    updatedAt: Date
    _count: BannersCountAggregateOutputType | null
    _avg: BannersAvgAggregateOutputType | null
    _sum: BannersSumAggregateOutputType | null
    _min: BannersMinAggregateOutputType | null
    _max: BannersMaxAggregateOutputType | null
  }

  type GetBannersGroupByPayload<T extends bannersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BannersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BannersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BannersGroupByOutputType[P]>
            : GetScalarType<T[P], BannersGroupByOutputType[P]>
        }
      >
    >


  export type bannersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    imageUrl?: boolean
    actionUrl?: boolean
    isActive?: boolean
    sortOrder?: boolean
    targetUserTypes?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["banners"]>



  export type bannersSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    imageUrl?: boolean
    actionUrl?: boolean
    isActive?: boolean
    sortOrder?: boolean
    targetUserTypes?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type bannersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "imageUrl" | "actionUrl" | "isActive" | "sortOrder" | "targetUserTypes" | "startDate" | "endDate" | "createdAt" | "updatedAt", ExtArgs["result"]["banners"]>

  export type $bannersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "banners"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      imageUrl: string
      actionUrl: string | null
      isActive: boolean
      sortOrder: number
      targetUserTypes: Prisma.JsonValue
      startDate: Date | null
      endDate: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["banners"]>
    composites: {}
  }

  type bannersGetPayload<S extends boolean | null | undefined | bannersDefaultArgs> = $Result.GetResult<Prisma.$bannersPayload, S>

  type bannersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<bannersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BannersCountAggregateInputType | true
    }

  export interface bannersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['banners'], meta: { name: 'banners' } }
    /**
     * Find zero or one Banners that matches the filter.
     * @param {bannersFindUniqueArgs} args - Arguments to find a Banners
     * @example
     * // Get one Banners
     * const banners = await prisma.banners.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends bannersFindUniqueArgs>(args: SelectSubset<T, bannersFindUniqueArgs<ExtArgs>>): Prisma__bannersClient<$Result.GetResult<Prisma.$bannersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Banners that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {bannersFindUniqueOrThrowArgs} args - Arguments to find a Banners
     * @example
     * // Get one Banners
     * const banners = await prisma.banners.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends bannersFindUniqueOrThrowArgs>(args: SelectSubset<T, bannersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__bannersClient<$Result.GetResult<Prisma.$bannersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Banners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bannersFindFirstArgs} args - Arguments to find a Banners
     * @example
     * // Get one Banners
     * const banners = await prisma.banners.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends bannersFindFirstArgs>(args?: SelectSubset<T, bannersFindFirstArgs<ExtArgs>>): Prisma__bannersClient<$Result.GetResult<Prisma.$bannersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Banners that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bannersFindFirstOrThrowArgs} args - Arguments to find a Banners
     * @example
     * // Get one Banners
     * const banners = await prisma.banners.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends bannersFindFirstOrThrowArgs>(args?: SelectSubset<T, bannersFindFirstOrThrowArgs<ExtArgs>>): Prisma__bannersClient<$Result.GetResult<Prisma.$bannersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Banners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bannersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Banners
     * const banners = await prisma.banners.findMany()
     * 
     * // Get first 10 Banners
     * const banners = await prisma.banners.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bannersWithIdOnly = await prisma.banners.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends bannersFindManyArgs>(args?: SelectSubset<T, bannersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bannersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Banners.
     * @param {bannersCreateArgs} args - Arguments to create a Banners.
     * @example
     * // Create one Banners
     * const Banners = await prisma.banners.create({
     *   data: {
     *     // ... data to create a Banners
     *   }
     * })
     * 
     */
    create<T extends bannersCreateArgs>(args: SelectSubset<T, bannersCreateArgs<ExtArgs>>): Prisma__bannersClient<$Result.GetResult<Prisma.$bannersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Banners.
     * @param {bannersCreateManyArgs} args - Arguments to create many Banners.
     * @example
     * // Create many Banners
     * const banners = await prisma.banners.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends bannersCreateManyArgs>(args?: SelectSubset<T, bannersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Banners.
     * @param {bannersDeleteArgs} args - Arguments to delete one Banners.
     * @example
     * // Delete one Banners
     * const Banners = await prisma.banners.delete({
     *   where: {
     *     // ... filter to delete one Banners
     *   }
     * })
     * 
     */
    delete<T extends bannersDeleteArgs>(args: SelectSubset<T, bannersDeleteArgs<ExtArgs>>): Prisma__bannersClient<$Result.GetResult<Prisma.$bannersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Banners.
     * @param {bannersUpdateArgs} args - Arguments to update one Banners.
     * @example
     * // Update one Banners
     * const banners = await prisma.banners.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends bannersUpdateArgs>(args: SelectSubset<T, bannersUpdateArgs<ExtArgs>>): Prisma__bannersClient<$Result.GetResult<Prisma.$bannersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Banners.
     * @param {bannersDeleteManyArgs} args - Arguments to filter Banners to delete.
     * @example
     * // Delete a few Banners
     * const { count } = await prisma.banners.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends bannersDeleteManyArgs>(args?: SelectSubset<T, bannersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Banners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bannersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Banners
     * const banners = await prisma.banners.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends bannersUpdateManyArgs>(args: SelectSubset<T, bannersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Banners.
     * @param {bannersUpsertArgs} args - Arguments to update or create a Banners.
     * @example
     * // Update or create a Banners
     * const banners = await prisma.banners.upsert({
     *   create: {
     *     // ... data to create a Banners
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Banners we want to update
     *   }
     * })
     */
    upsert<T extends bannersUpsertArgs>(args: SelectSubset<T, bannersUpsertArgs<ExtArgs>>): Prisma__bannersClient<$Result.GetResult<Prisma.$bannersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Banners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bannersCountArgs} args - Arguments to filter Banners to count.
     * @example
     * // Count the number of Banners
     * const count = await prisma.banners.count({
     *   where: {
     *     // ... the filter for the Banners we want to count
     *   }
     * })
    **/
    count<T extends bannersCountArgs>(
      args?: Subset<T, bannersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BannersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Banners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BannersAggregateArgs>(args: Subset<T, BannersAggregateArgs>): Prisma.PrismaPromise<GetBannersAggregateType<T>>

    /**
     * Group by Banners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bannersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends bannersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: bannersGroupByArgs['orderBy'] }
        : { orderBy?: bannersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, bannersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBannersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the banners model
   */
  readonly fields: bannersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for banners.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__bannersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the banners model
   */
  interface bannersFieldRefs {
    readonly id: FieldRef<"banners", 'String'>
    readonly title: FieldRef<"banners", 'String'>
    readonly description: FieldRef<"banners", 'String'>
    readonly imageUrl: FieldRef<"banners", 'String'>
    readonly actionUrl: FieldRef<"banners", 'String'>
    readonly isActive: FieldRef<"banners", 'Boolean'>
    readonly sortOrder: FieldRef<"banners", 'Int'>
    readonly targetUserTypes: FieldRef<"banners", 'Json'>
    readonly startDate: FieldRef<"banners", 'DateTime'>
    readonly endDate: FieldRef<"banners", 'DateTime'>
    readonly createdAt: FieldRef<"banners", 'DateTime'>
    readonly updatedAt: FieldRef<"banners", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * banners findUnique
   */
  export type bannersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banners
     */
    select?: bannersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the banners
     */
    omit?: bannersOmit<ExtArgs> | null
    /**
     * Filter, which banners to fetch.
     */
    where: bannersWhereUniqueInput
  }

  /**
   * banners findUniqueOrThrow
   */
  export type bannersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banners
     */
    select?: bannersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the banners
     */
    omit?: bannersOmit<ExtArgs> | null
    /**
     * Filter, which banners to fetch.
     */
    where: bannersWhereUniqueInput
  }

  /**
   * banners findFirst
   */
  export type bannersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banners
     */
    select?: bannersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the banners
     */
    omit?: bannersOmit<ExtArgs> | null
    /**
     * Filter, which banners to fetch.
     */
    where?: bannersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of banners to fetch.
     */
    orderBy?: bannersOrderByWithRelationInput | bannersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for banners.
     */
    cursor?: bannersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` banners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` banners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of banners.
     */
    distinct?: BannersScalarFieldEnum | BannersScalarFieldEnum[]
  }

  /**
   * banners findFirstOrThrow
   */
  export type bannersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banners
     */
    select?: bannersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the banners
     */
    omit?: bannersOmit<ExtArgs> | null
    /**
     * Filter, which banners to fetch.
     */
    where?: bannersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of banners to fetch.
     */
    orderBy?: bannersOrderByWithRelationInput | bannersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for banners.
     */
    cursor?: bannersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` banners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` banners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of banners.
     */
    distinct?: BannersScalarFieldEnum | BannersScalarFieldEnum[]
  }

  /**
   * banners findMany
   */
  export type bannersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banners
     */
    select?: bannersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the banners
     */
    omit?: bannersOmit<ExtArgs> | null
    /**
     * Filter, which banners to fetch.
     */
    where?: bannersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of banners to fetch.
     */
    orderBy?: bannersOrderByWithRelationInput | bannersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing banners.
     */
    cursor?: bannersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` banners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` banners.
     */
    skip?: number
    distinct?: BannersScalarFieldEnum | BannersScalarFieldEnum[]
  }

  /**
   * banners create
   */
  export type bannersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banners
     */
    select?: bannersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the banners
     */
    omit?: bannersOmit<ExtArgs> | null
    /**
     * The data needed to create a banners.
     */
    data: XOR<bannersCreateInput, bannersUncheckedCreateInput>
  }

  /**
   * banners createMany
   */
  export type bannersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many banners.
     */
    data: bannersCreateManyInput | bannersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * banners update
   */
  export type bannersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banners
     */
    select?: bannersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the banners
     */
    omit?: bannersOmit<ExtArgs> | null
    /**
     * The data needed to update a banners.
     */
    data: XOR<bannersUpdateInput, bannersUncheckedUpdateInput>
    /**
     * Choose, which banners to update.
     */
    where: bannersWhereUniqueInput
  }

  /**
   * banners updateMany
   */
  export type bannersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update banners.
     */
    data: XOR<bannersUpdateManyMutationInput, bannersUncheckedUpdateManyInput>
    /**
     * Filter which banners to update
     */
    where?: bannersWhereInput
    /**
     * Limit how many banners to update.
     */
    limit?: number
  }

  /**
   * banners upsert
   */
  export type bannersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banners
     */
    select?: bannersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the banners
     */
    omit?: bannersOmit<ExtArgs> | null
    /**
     * The filter to search for the banners to update in case it exists.
     */
    where: bannersWhereUniqueInput
    /**
     * In case the banners found by the `where` argument doesn't exist, create a new banners with this data.
     */
    create: XOR<bannersCreateInput, bannersUncheckedCreateInput>
    /**
     * In case the banners was found with the provided `where` argument, update it with this data.
     */
    update: XOR<bannersUpdateInput, bannersUncheckedUpdateInput>
  }

  /**
   * banners delete
   */
  export type bannersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banners
     */
    select?: bannersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the banners
     */
    omit?: bannersOmit<ExtArgs> | null
    /**
     * Filter which banners to delete.
     */
    where: bannersWhereUniqueInput
  }

  /**
   * banners deleteMany
   */
  export type bannersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which banners to delete
     */
    where?: bannersWhereInput
    /**
     * Limit how many banners to delete.
     */
    limit?: number
  }

  /**
   * banners without action
   */
  export type bannersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banners
     */
    select?: bannersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the banners
     */
    omit?: bannersOmit<ExtArgs> | null
  }


  /**
   * Model coin_transactions
   */

  export type AggregateCoin_transactions = {
    _count: Coin_transactionsCountAggregateOutputType | null
    _avg: Coin_transactionsAvgAggregateOutputType | null
    _sum: Coin_transactionsSumAggregateOutputType | null
    _min: Coin_transactionsMinAggregateOutputType | null
    _max: Coin_transactionsMaxAggregateOutputType | null
  }

  export type Coin_transactionsAvgAggregateOutputType = {
    amount: number | null
  }

  export type Coin_transactionsSumAggregateOutputType = {
    amount: number | null
  }

  export type Coin_transactionsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.coin_transactions_type | null
    amount: number | null
    description: string | null
    loanId: string | null
    rewardId: string | null
    createdAt: Date | null
  }

  export type Coin_transactionsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.coin_transactions_type | null
    amount: number | null
    description: string | null
    loanId: string | null
    rewardId: string | null
    createdAt: Date | null
  }

  export type Coin_transactionsCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    amount: number
    description: number
    loanId: number
    rewardId: number
    createdAt: number
    _all: number
  }


  export type Coin_transactionsAvgAggregateInputType = {
    amount?: true
  }

  export type Coin_transactionsSumAggregateInputType = {
    amount?: true
  }

  export type Coin_transactionsMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    amount?: true
    description?: true
    loanId?: true
    rewardId?: true
    createdAt?: true
  }

  export type Coin_transactionsMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    amount?: true
    description?: true
    loanId?: true
    rewardId?: true
    createdAt?: true
  }

  export type Coin_transactionsCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    amount?: true
    description?: true
    loanId?: true
    rewardId?: true
    createdAt?: true
    _all?: true
  }

  export type Coin_transactionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which coin_transactions to aggregate.
     */
    where?: coin_transactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of coin_transactions to fetch.
     */
    orderBy?: coin_transactionsOrderByWithRelationInput | coin_transactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: coin_transactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` coin_transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` coin_transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned coin_transactions
    **/
    _count?: true | Coin_transactionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Coin_transactionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Coin_transactionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Coin_transactionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Coin_transactionsMaxAggregateInputType
  }

  export type GetCoin_transactionsAggregateType<T extends Coin_transactionsAggregateArgs> = {
        [P in keyof T & keyof AggregateCoin_transactions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCoin_transactions[P]>
      : GetScalarType<T[P], AggregateCoin_transactions[P]>
  }




  export type coin_transactionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: coin_transactionsWhereInput
    orderBy?: coin_transactionsOrderByWithAggregationInput | coin_transactionsOrderByWithAggregationInput[]
    by: Coin_transactionsScalarFieldEnum[] | Coin_transactionsScalarFieldEnum
    having?: coin_transactionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Coin_transactionsCountAggregateInputType | true
    _avg?: Coin_transactionsAvgAggregateInputType
    _sum?: Coin_transactionsSumAggregateInputType
    _min?: Coin_transactionsMinAggregateInputType
    _max?: Coin_transactionsMaxAggregateInputType
  }

  export type Coin_transactionsGroupByOutputType = {
    id: string
    userId: string
    type: $Enums.coin_transactions_type
    amount: number
    description: string
    loanId: string | null
    rewardId: string | null
    createdAt: Date
    _count: Coin_transactionsCountAggregateOutputType | null
    _avg: Coin_transactionsAvgAggregateOutputType | null
    _sum: Coin_transactionsSumAggregateOutputType | null
    _min: Coin_transactionsMinAggregateOutputType | null
    _max: Coin_transactionsMaxAggregateOutputType | null
  }

  type GetCoin_transactionsGroupByPayload<T extends coin_transactionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Coin_transactionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Coin_transactionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Coin_transactionsGroupByOutputType[P]>
            : GetScalarType<T[P], Coin_transactionsGroupByOutputType[P]>
        }
      >
    >


  export type coin_transactionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    amount?: boolean
    description?: boolean
    loanId?: boolean
    rewardId?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["coin_transactions"]>



  export type coin_transactionsSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    amount?: boolean
    description?: boolean
    loanId?: boolean
    rewardId?: boolean
    createdAt?: boolean
  }

  export type coin_transactionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "amount" | "description" | "loanId" | "rewardId" | "createdAt", ExtArgs["result"]["coin_transactions"]>

  export type $coin_transactionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "coin_transactions"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: $Enums.coin_transactions_type
      amount: number
      description: string
      loanId: string | null
      rewardId: string | null
      createdAt: Date
    }, ExtArgs["result"]["coin_transactions"]>
    composites: {}
  }

  type coin_transactionsGetPayload<S extends boolean | null | undefined | coin_transactionsDefaultArgs> = $Result.GetResult<Prisma.$coin_transactionsPayload, S>

  type coin_transactionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<coin_transactionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Coin_transactionsCountAggregateInputType | true
    }

  export interface coin_transactionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['coin_transactions'], meta: { name: 'coin_transactions' } }
    /**
     * Find zero or one Coin_transactions that matches the filter.
     * @param {coin_transactionsFindUniqueArgs} args - Arguments to find a Coin_transactions
     * @example
     * // Get one Coin_transactions
     * const coin_transactions = await prisma.coin_transactions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends coin_transactionsFindUniqueArgs>(args: SelectSubset<T, coin_transactionsFindUniqueArgs<ExtArgs>>): Prisma__coin_transactionsClient<$Result.GetResult<Prisma.$coin_transactionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Coin_transactions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {coin_transactionsFindUniqueOrThrowArgs} args - Arguments to find a Coin_transactions
     * @example
     * // Get one Coin_transactions
     * const coin_transactions = await prisma.coin_transactions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends coin_transactionsFindUniqueOrThrowArgs>(args: SelectSubset<T, coin_transactionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__coin_transactionsClient<$Result.GetResult<Prisma.$coin_transactionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Coin_transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {coin_transactionsFindFirstArgs} args - Arguments to find a Coin_transactions
     * @example
     * // Get one Coin_transactions
     * const coin_transactions = await prisma.coin_transactions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends coin_transactionsFindFirstArgs>(args?: SelectSubset<T, coin_transactionsFindFirstArgs<ExtArgs>>): Prisma__coin_transactionsClient<$Result.GetResult<Prisma.$coin_transactionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Coin_transactions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {coin_transactionsFindFirstOrThrowArgs} args - Arguments to find a Coin_transactions
     * @example
     * // Get one Coin_transactions
     * const coin_transactions = await prisma.coin_transactions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends coin_transactionsFindFirstOrThrowArgs>(args?: SelectSubset<T, coin_transactionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__coin_transactionsClient<$Result.GetResult<Prisma.$coin_transactionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Coin_transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {coin_transactionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Coin_transactions
     * const coin_transactions = await prisma.coin_transactions.findMany()
     * 
     * // Get first 10 Coin_transactions
     * const coin_transactions = await prisma.coin_transactions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const coin_transactionsWithIdOnly = await prisma.coin_transactions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends coin_transactionsFindManyArgs>(args?: SelectSubset<T, coin_transactionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$coin_transactionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Coin_transactions.
     * @param {coin_transactionsCreateArgs} args - Arguments to create a Coin_transactions.
     * @example
     * // Create one Coin_transactions
     * const Coin_transactions = await prisma.coin_transactions.create({
     *   data: {
     *     // ... data to create a Coin_transactions
     *   }
     * })
     * 
     */
    create<T extends coin_transactionsCreateArgs>(args: SelectSubset<T, coin_transactionsCreateArgs<ExtArgs>>): Prisma__coin_transactionsClient<$Result.GetResult<Prisma.$coin_transactionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Coin_transactions.
     * @param {coin_transactionsCreateManyArgs} args - Arguments to create many Coin_transactions.
     * @example
     * // Create many Coin_transactions
     * const coin_transactions = await prisma.coin_transactions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends coin_transactionsCreateManyArgs>(args?: SelectSubset<T, coin_transactionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Coin_transactions.
     * @param {coin_transactionsDeleteArgs} args - Arguments to delete one Coin_transactions.
     * @example
     * // Delete one Coin_transactions
     * const Coin_transactions = await prisma.coin_transactions.delete({
     *   where: {
     *     // ... filter to delete one Coin_transactions
     *   }
     * })
     * 
     */
    delete<T extends coin_transactionsDeleteArgs>(args: SelectSubset<T, coin_transactionsDeleteArgs<ExtArgs>>): Prisma__coin_transactionsClient<$Result.GetResult<Prisma.$coin_transactionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Coin_transactions.
     * @param {coin_transactionsUpdateArgs} args - Arguments to update one Coin_transactions.
     * @example
     * // Update one Coin_transactions
     * const coin_transactions = await prisma.coin_transactions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends coin_transactionsUpdateArgs>(args: SelectSubset<T, coin_transactionsUpdateArgs<ExtArgs>>): Prisma__coin_transactionsClient<$Result.GetResult<Prisma.$coin_transactionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Coin_transactions.
     * @param {coin_transactionsDeleteManyArgs} args - Arguments to filter Coin_transactions to delete.
     * @example
     * // Delete a few Coin_transactions
     * const { count } = await prisma.coin_transactions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends coin_transactionsDeleteManyArgs>(args?: SelectSubset<T, coin_transactionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Coin_transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {coin_transactionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Coin_transactions
     * const coin_transactions = await prisma.coin_transactions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends coin_transactionsUpdateManyArgs>(args: SelectSubset<T, coin_transactionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Coin_transactions.
     * @param {coin_transactionsUpsertArgs} args - Arguments to update or create a Coin_transactions.
     * @example
     * // Update or create a Coin_transactions
     * const coin_transactions = await prisma.coin_transactions.upsert({
     *   create: {
     *     // ... data to create a Coin_transactions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Coin_transactions we want to update
     *   }
     * })
     */
    upsert<T extends coin_transactionsUpsertArgs>(args: SelectSubset<T, coin_transactionsUpsertArgs<ExtArgs>>): Prisma__coin_transactionsClient<$Result.GetResult<Prisma.$coin_transactionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Coin_transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {coin_transactionsCountArgs} args - Arguments to filter Coin_transactions to count.
     * @example
     * // Count the number of Coin_transactions
     * const count = await prisma.coin_transactions.count({
     *   where: {
     *     // ... the filter for the Coin_transactions we want to count
     *   }
     * })
    **/
    count<T extends coin_transactionsCountArgs>(
      args?: Subset<T, coin_transactionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Coin_transactionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Coin_transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Coin_transactionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Coin_transactionsAggregateArgs>(args: Subset<T, Coin_transactionsAggregateArgs>): Prisma.PrismaPromise<GetCoin_transactionsAggregateType<T>>

    /**
     * Group by Coin_transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {coin_transactionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends coin_transactionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: coin_transactionsGroupByArgs['orderBy'] }
        : { orderBy?: coin_transactionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, coin_transactionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCoin_transactionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the coin_transactions model
   */
  readonly fields: coin_transactionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for coin_transactions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__coin_transactionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the coin_transactions model
   */
  interface coin_transactionsFieldRefs {
    readonly id: FieldRef<"coin_transactions", 'String'>
    readonly userId: FieldRef<"coin_transactions", 'String'>
    readonly type: FieldRef<"coin_transactions", 'coin_transactions_type'>
    readonly amount: FieldRef<"coin_transactions", 'Int'>
    readonly description: FieldRef<"coin_transactions", 'String'>
    readonly loanId: FieldRef<"coin_transactions", 'String'>
    readonly rewardId: FieldRef<"coin_transactions", 'String'>
    readonly createdAt: FieldRef<"coin_transactions", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * coin_transactions findUnique
   */
  export type coin_transactionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coin_transactions
     */
    select?: coin_transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coin_transactions
     */
    omit?: coin_transactionsOmit<ExtArgs> | null
    /**
     * Filter, which coin_transactions to fetch.
     */
    where: coin_transactionsWhereUniqueInput
  }

  /**
   * coin_transactions findUniqueOrThrow
   */
  export type coin_transactionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coin_transactions
     */
    select?: coin_transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coin_transactions
     */
    omit?: coin_transactionsOmit<ExtArgs> | null
    /**
     * Filter, which coin_transactions to fetch.
     */
    where: coin_transactionsWhereUniqueInput
  }

  /**
   * coin_transactions findFirst
   */
  export type coin_transactionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coin_transactions
     */
    select?: coin_transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coin_transactions
     */
    omit?: coin_transactionsOmit<ExtArgs> | null
    /**
     * Filter, which coin_transactions to fetch.
     */
    where?: coin_transactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of coin_transactions to fetch.
     */
    orderBy?: coin_transactionsOrderByWithRelationInput | coin_transactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for coin_transactions.
     */
    cursor?: coin_transactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` coin_transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` coin_transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of coin_transactions.
     */
    distinct?: Coin_transactionsScalarFieldEnum | Coin_transactionsScalarFieldEnum[]
  }

  /**
   * coin_transactions findFirstOrThrow
   */
  export type coin_transactionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coin_transactions
     */
    select?: coin_transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coin_transactions
     */
    omit?: coin_transactionsOmit<ExtArgs> | null
    /**
     * Filter, which coin_transactions to fetch.
     */
    where?: coin_transactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of coin_transactions to fetch.
     */
    orderBy?: coin_transactionsOrderByWithRelationInput | coin_transactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for coin_transactions.
     */
    cursor?: coin_transactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` coin_transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` coin_transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of coin_transactions.
     */
    distinct?: Coin_transactionsScalarFieldEnum | Coin_transactionsScalarFieldEnum[]
  }

  /**
   * coin_transactions findMany
   */
  export type coin_transactionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coin_transactions
     */
    select?: coin_transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coin_transactions
     */
    omit?: coin_transactionsOmit<ExtArgs> | null
    /**
     * Filter, which coin_transactions to fetch.
     */
    where?: coin_transactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of coin_transactions to fetch.
     */
    orderBy?: coin_transactionsOrderByWithRelationInput | coin_transactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing coin_transactions.
     */
    cursor?: coin_transactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` coin_transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` coin_transactions.
     */
    skip?: number
    distinct?: Coin_transactionsScalarFieldEnum | Coin_transactionsScalarFieldEnum[]
  }

  /**
   * coin_transactions create
   */
  export type coin_transactionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coin_transactions
     */
    select?: coin_transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coin_transactions
     */
    omit?: coin_transactionsOmit<ExtArgs> | null
    /**
     * The data needed to create a coin_transactions.
     */
    data: XOR<coin_transactionsCreateInput, coin_transactionsUncheckedCreateInput>
  }

  /**
   * coin_transactions createMany
   */
  export type coin_transactionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many coin_transactions.
     */
    data: coin_transactionsCreateManyInput | coin_transactionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * coin_transactions update
   */
  export type coin_transactionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coin_transactions
     */
    select?: coin_transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coin_transactions
     */
    omit?: coin_transactionsOmit<ExtArgs> | null
    /**
     * The data needed to update a coin_transactions.
     */
    data: XOR<coin_transactionsUpdateInput, coin_transactionsUncheckedUpdateInput>
    /**
     * Choose, which coin_transactions to update.
     */
    where: coin_transactionsWhereUniqueInput
  }

  /**
   * coin_transactions updateMany
   */
  export type coin_transactionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update coin_transactions.
     */
    data: XOR<coin_transactionsUpdateManyMutationInput, coin_transactionsUncheckedUpdateManyInput>
    /**
     * Filter which coin_transactions to update
     */
    where?: coin_transactionsWhereInput
    /**
     * Limit how many coin_transactions to update.
     */
    limit?: number
  }

  /**
   * coin_transactions upsert
   */
  export type coin_transactionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coin_transactions
     */
    select?: coin_transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coin_transactions
     */
    omit?: coin_transactionsOmit<ExtArgs> | null
    /**
     * The filter to search for the coin_transactions to update in case it exists.
     */
    where: coin_transactionsWhereUniqueInput
    /**
     * In case the coin_transactions found by the `where` argument doesn't exist, create a new coin_transactions with this data.
     */
    create: XOR<coin_transactionsCreateInput, coin_transactionsUncheckedCreateInput>
    /**
     * In case the coin_transactions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<coin_transactionsUpdateInput, coin_transactionsUncheckedUpdateInput>
  }

  /**
   * coin_transactions delete
   */
  export type coin_transactionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coin_transactions
     */
    select?: coin_transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coin_transactions
     */
    omit?: coin_transactionsOmit<ExtArgs> | null
    /**
     * Filter which coin_transactions to delete.
     */
    where: coin_transactionsWhereUniqueInput
  }

  /**
   * coin_transactions deleteMany
   */
  export type coin_transactionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which coin_transactions to delete
     */
    where?: coin_transactionsWhereInput
    /**
     * Limit how many coin_transactions to delete.
     */
    limit?: number
  }

  /**
   * coin_transactions without action
   */
  export type coin_transactionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coin_transactions
     */
    select?: coin_transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coin_transactions
     */
    omit?: coin_transactionsOmit<ExtArgs> | null
  }


  /**
   * Model loan_applications
   */

  export type AggregateLoan_applications = {
    _count: Loan_applicationsCountAggregateOutputType | null
    _avg: Loan_applicationsAvgAggregateOutputType | null
    _sum: Loan_applicationsSumAggregateOutputType | null
    _min: Loan_applicationsMinAggregateOutputType | null
    _max: Loan_applicationsMaxAggregateOutputType | null
  }

  export type Loan_applicationsAvgAggregateOutputType = {
    currentStep: number | null
    requestedAmount: Decimal | null
    approvedAmount: Decimal | null
    maxApprovedAmount: Decimal | null
    propertyValue: Decimal | null
  }

  export type Loan_applicationsSumAggregateOutputType = {
    currentStep: number | null
    requestedAmount: Decimal | null
    approvedAmount: Decimal | null
    maxApprovedAmount: Decimal | null
    propertyValue: Decimal | null
  }

  export type Loan_applicationsMinAggregateOutputType = {
    id: string | null
    customerId: string | null
    agentId: string | null
    loanType: $Enums.loan_applications_loanType | null
    status: $Enums.loan_applications_status | null
    currentStep: number | null
    isNewUser: boolean | null
    submittedByAgent: boolean | null
    titleDeedImage: string | null
    idCardFrontImage: string | null
    idCardBackImage: string | null
    requestedAmount: Decimal | null
    approvedAmount: Decimal | null
    maxApprovedAmount: Decimal | null
    propertyType: string | null
    propertyValue: Decimal | null
    propertyArea: string | null
    propertyLocation: string | null
    landNumber: string | null
    ownerName: string | null
    submittedAt: Date | null
    reviewedAt: Date | null
    reviewedBy: string | null
    reviewNotes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Loan_applicationsMaxAggregateOutputType = {
    id: string | null
    customerId: string | null
    agentId: string | null
    loanType: $Enums.loan_applications_loanType | null
    status: $Enums.loan_applications_status | null
    currentStep: number | null
    isNewUser: boolean | null
    submittedByAgent: boolean | null
    titleDeedImage: string | null
    idCardFrontImage: string | null
    idCardBackImage: string | null
    requestedAmount: Decimal | null
    approvedAmount: Decimal | null
    maxApprovedAmount: Decimal | null
    propertyType: string | null
    propertyValue: Decimal | null
    propertyArea: string | null
    propertyLocation: string | null
    landNumber: string | null
    ownerName: string | null
    submittedAt: Date | null
    reviewedAt: Date | null
    reviewedBy: string | null
    reviewNotes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Loan_applicationsCountAggregateOutputType = {
    id: number
    customerId: number
    agentId: number
    loanType: number
    status: number
    currentStep: number
    completedSteps: number
    isNewUser: number
    submittedByAgent: number
    titleDeedImage: number
    titleDeedData: number
    supportingImages: number
    idCardFrontImage: number
    idCardBackImage: number
    requestedAmount: number
    approvedAmount: number
    maxApprovedAmount: number
    propertyType: number
    propertyValue: number
    propertyArea: number
    propertyLocation: number
    landNumber: number
    ownerName: number
    submittedAt: number
    reviewedAt: number
    reviewedBy: number
    reviewNotes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Loan_applicationsAvgAggregateInputType = {
    currentStep?: true
    requestedAmount?: true
    approvedAmount?: true
    maxApprovedAmount?: true
    propertyValue?: true
  }

  export type Loan_applicationsSumAggregateInputType = {
    currentStep?: true
    requestedAmount?: true
    approvedAmount?: true
    maxApprovedAmount?: true
    propertyValue?: true
  }

  export type Loan_applicationsMinAggregateInputType = {
    id?: true
    customerId?: true
    agentId?: true
    loanType?: true
    status?: true
    currentStep?: true
    isNewUser?: true
    submittedByAgent?: true
    titleDeedImage?: true
    idCardFrontImage?: true
    idCardBackImage?: true
    requestedAmount?: true
    approvedAmount?: true
    maxApprovedAmount?: true
    propertyType?: true
    propertyValue?: true
    propertyArea?: true
    propertyLocation?: true
    landNumber?: true
    ownerName?: true
    submittedAt?: true
    reviewedAt?: true
    reviewedBy?: true
    reviewNotes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Loan_applicationsMaxAggregateInputType = {
    id?: true
    customerId?: true
    agentId?: true
    loanType?: true
    status?: true
    currentStep?: true
    isNewUser?: true
    submittedByAgent?: true
    titleDeedImage?: true
    idCardFrontImage?: true
    idCardBackImage?: true
    requestedAmount?: true
    approvedAmount?: true
    maxApprovedAmount?: true
    propertyType?: true
    propertyValue?: true
    propertyArea?: true
    propertyLocation?: true
    landNumber?: true
    ownerName?: true
    submittedAt?: true
    reviewedAt?: true
    reviewedBy?: true
    reviewNotes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Loan_applicationsCountAggregateInputType = {
    id?: true
    customerId?: true
    agentId?: true
    loanType?: true
    status?: true
    currentStep?: true
    completedSteps?: true
    isNewUser?: true
    submittedByAgent?: true
    titleDeedImage?: true
    titleDeedData?: true
    supportingImages?: true
    idCardFrontImage?: true
    idCardBackImage?: true
    requestedAmount?: true
    approvedAmount?: true
    maxApprovedAmount?: true
    propertyType?: true
    propertyValue?: true
    propertyArea?: true
    propertyLocation?: true
    landNumber?: true
    ownerName?: true
    submittedAt?: true
    reviewedAt?: true
    reviewedBy?: true
    reviewNotes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Loan_applicationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which loan_applications to aggregate.
     */
    where?: loan_applicationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of loan_applications to fetch.
     */
    orderBy?: loan_applicationsOrderByWithRelationInput | loan_applicationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: loan_applicationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` loan_applications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` loan_applications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned loan_applications
    **/
    _count?: true | Loan_applicationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Loan_applicationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Loan_applicationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Loan_applicationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Loan_applicationsMaxAggregateInputType
  }

  export type GetLoan_applicationsAggregateType<T extends Loan_applicationsAggregateArgs> = {
        [P in keyof T & keyof AggregateLoan_applications]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLoan_applications[P]>
      : GetScalarType<T[P], AggregateLoan_applications[P]>
  }




  export type loan_applicationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: loan_applicationsWhereInput
    orderBy?: loan_applicationsOrderByWithAggregationInput | loan_applicationsOrderByWithAggregationInput[]
    by: Loan_applicationsScalarFieldEnum[] | Loan_applicationsScalarFieldEnum
    having?: loan_applicationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Loan_applicationsCountAggregateInputType | true
    _avg?: Loan_applicationsAvgAggregateInputType
    _sum?: Loan_applicationsSumAggregateInputType
    _min?: Loan_applicationsMinAggregateInputType
    _max?: Loan_applicationsMaxAggregateInputType
  }

  export type Loan_applicationsGroupByOutputType = {
    id: string
    customerId: string
    agentId: string | null
    loanType: $Enums.loan_applications_loanType
    status: $Enums.loan_applications_status
    currentStep: number
    completedSteps: JsonValue
    isNewUser: boolean
    submittedByAgent: boolean
    titleDeedImage: string | null
    titleDeedData: JsonValue | null
    supportingImages: JsonValue
    idCardFrontImage: string | null
    idCardBackImage: string | null
    requestedAmount: Decimal
    approvedAmount: Decimal | null
    maxApprovedAmount: Decimal | null
    propertyType: string | null
    propertyValue: Decimal | null
    propertyArea: string | null
    propertyLocation: string | null
    landNumber: string | null
    ownerName: string | null
    submittedAt: Date | null
    reviewedAt: Date | null
    reviewedBy: string | null
    reviewNotes: string | null
    createdAt: Date
    updatedAt: Date
    _count: Loan_applicationsCountAggregateOutputType | null
    _avg: Loan_applicationsAvgAggregateOutputType | null
    _sum: Loan_applicationsSumAggregateOutputType | null
    _min: Loan_applicationsMinAggregateOutputType | null
    _max: Loan_applicationsMaxAggregateOutputType | null
  }

  type GetLoan_applicationsGroupByPayload<T extends loan_applicationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Loan_applicationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Loan_applicationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Loan_applicationsGroupByOutputType[P]>
            : GetScalarType<T[P], Loan_applicationsGroupByOutputType[P]>
        }
      >
    >


  export type loan_applicationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    agentId?: boolean
    loanType?: boolean
    status?: boolean
    currentStep?: boolean
    completedSteps?: boolean
    isNewUser?: boolean
    submittedByAgent?: boolean
    titleDeedImage?: boolean
    titleDeedData?: boolean
    supportingImages?: boolean
    idCardFrontImage?: boolean
    idCardBackImage?: boolean
    requestedAmount?: boolean
    approvedAmount?: boolean
    maxApprovedAmount?: boolean
    propertyType?: boolean
    propertyValue?: boolean
    propertyArea?: boolean
    propertyLocation?: boolean
    landNumber?: boolean
    ownerName?: boolean
    submittedAt?: boolean
    reviewedAt?: boolean
    reviewedBy?: boolean
    reviewNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["loan_applications"]>



  export type loan_applicationsSelectScalar = {
    id?: boolean
    customerId?: boolean
    agentId?: boolean
    loanType?: boolean
    status?: boolean
    currentStep?: boolean
    completedSteps?: boolean
    isNewUser?: boolean
    submittedByAgent?: boolean
    titleDeedImage?: boolean
    titleDeedData?: boolean
    supportingImages?: boolean
    idCardFrontImage?: boolean
    idCardBackImage?: boolean
    requestedAmount?: boolean
    approvedAmount?: boolean
    maxApprovedAmount?: boolean
    propertyType?: boolean
    propertyValue?: boolean
    propertyArea?: boolean
    propertyLocation?: boolean
    landNumber?: boolean
    ownerName?: boolean
    submittedAt?: boolean
    reviewedAt?: boolean
    reviewedBy?: boolean
    reviewNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type loan_applicationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "customerId" | "agentId" | "loanType" | "status" | "currentStep" | "completedSteps" | "isNewUser" | "submittedByAgent" | "titleDeedImage" | "titleDeedData" | "supportingImages" | "idCardFrontImage" | "idCardBackImage" | "requestedAmount" | "approvedAmount" | "maxApprovedAmount" | "propertyType" | "propertyValue" | "propertyArea" | "propertyLocation" | "landNumber" | "ownerName" | "submittedAt" | "reviewedAt" | "reviewedBy" | "reviewNotes" | "createdAt" | "updatedAt", ExtArgs["result"]["loan_applications"]>

  export type $loan_applicationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "loan_applications"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      customerId: string
      agentId: string | null
      loanType: $Enums.loan_applications_loanType
      status: $Enums.loan_applications_status
      currentStep: number
      completedSteps: Prisma.JsonValue
      isNewUser: boolean
      submittedByAgent: boolean
      titleDeedImage: string | null
      titleDeedData: Prisma.JsonValue | null
      supportingImages: Prisma.JsonValue
      idCardFrontImage: string | null
      idCardBackImage: string | null
      requestedAmount: Prisma.Decimal
      approvedAmount: Prisma.Decimal | null
      maxApprovedAmount: Prisma.Decimal | null
      propertyType: string | null
      propertyValue: Prisma.Decimal | null
      propertyArea: string | null
      propertyLocation: string | null
      landNumber: string | null
      ownerName: string | null
      submittedAt: Date | null
      reviewedAt: Date | null
      reviewedBy: string | null
      reviewNotes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["loan_applications"]>
    composites: {}
  }

  type loan_applicationsGetPayload<S extends boolean | null | undefined | loan_applicationsDefaultArgs> = $Result.GetResult<Prisma.$loan_applicationsPayload, S>

  type loan_applicationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<loan_applicationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Loan_applicationsCountAggregateInputType | true
    }

  export interface loan_applicationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['loan_applications'], meta: { name: 'loan_applications' } }
    /**
     * Find zero or one Loan_applications that matches the filter.
     * @param {loan_applicationsFindUniqueArgs} args - Arguments to find a Loan_applications
     * @example
     * // Get one Loan_applications
     * const loan_applications = await prisma.loan_applications.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends loan_applicationsFindUniqueArgs>(args: SelectSubset<T, loan_applicationsFindUniqueArgs<ExtArgs>>): Prisma__loan_applicationsClient<$Result.GetResult<Prisma.$loan_applicationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Loan_applications that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {loan_applicationsFindUniqueOrThrowArgs} args - Arguments to find a Loan_applications
     * @example
     * // Get one Loan_applications
     * const loan_applications = await prisma.loan_applications.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends loan_applicationsFindUniqueOrThrowArgs>(args: SelectSubset<T, loan_applicationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__loan_applicationsClient<$Result.GetResult<Prisma.$loan_applicationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Loan_applications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {loan_applicationsFindFirstArgs} args - Arguments to find a Loan_applications
     * @example
     * // Get one Loan_applications
     * const loan_applications = await prisma.loan_applications.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends loan_applicationsFindFirstArgs>(args?: SelectSubset<T, loan_applicationsFindFirstArgs<ExtArgs>>): Prisma__loan_applicationsClient<$Result.GetResult<Prisma.$loan_applicationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Loan_applications that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {loan_applicationsFindFirstOrThrowArgs} args - Arguments to find a Loan_applications
     * @example
     * // Get one Loan_applications
     * const loan_applications = await prisma.loan_applications.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends loan_applicationsFindFirstOrThrowArgs>(args?: SelectSubset<T, loan_applicationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__loan_applicationsClient<$Result.GetResult<Prisma.$loan_applicationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Loan_applications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {loan_applicationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Loan_applications
     * const loan_applications = await prisma.loan_applications.findMany()
     * 
     * // Get first 10 Loan_applications
     * const loan_applications = await prisma.loan_applications.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const loan_applicationsWithIdOnly = await prisma.loan_applications.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends loan_applicationsFindManyArgs>(args?: SelectSubset<T, loan_applicationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$loan_applicationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Loan_applications.
     * @param {loan_applicationsCreateArgs} args - Arguments to create a Loan_applications.
     * @example
     * // Create one Loan_applications
     * const Loan_applications = await prisma.loan_applications.create({
     *   data: {
     *     // ... data to create a Loan_applications
     *   }
     * })
     * 
     */
    create<T extends loan_applicationsCreateArgs>(args: SelectSubset<T, loan_applicationsCreateArgs<ExtArgs>>): Prisma__loan_applicationsClient<$Result.GetResult<Prisma.$loan_applicationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Loan_applications.
     * @param {loan_applicationsCreateManyArgs} args - Arguments to create many Loan_applications.
     * @example
     * // Create many Loan_applications
     * const loan_applications = await prisma.loan_applications.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends loan_applicationsCreateManyArgs>(args?: SelectSubset<T, loan_applicationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Loan_applications.
     * @param {loan_applicationsDeleteArgs} args - Arguments to delete one Loan_applications.
     * @example
     * // Delete one Loan_applications
     * const Loan_applications = await prisma.loan_applications.delete({
     *   where: {
     *     // ... filter to delete one Loan_applications
     *   }
     * })
     * 
     */
    delete<T extends loan_applicationsDeleteArgs>(args: SelectSubset<T, loan_applicationsDeleteArgs<ExtArgs>>): Prisma__loan_applicationsClient<$Result.GetResult<Prisma.$loan_applicationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Loan_applications.
     * @param {loan_applicationsUpdateArgs} args - Arguments to update one Loan_applications.
     * @example
     * // Update one Loan_applications
     * const loan_applications = await prisma.loan_applications.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends loan_applicationsUpdateArgs>(args: SelectSubset<T, loan_applicationsUpdateArgs<ExtArgs>>): Prisma__loan_applicationsClient<$Result.GetResult<Prisma.$loan_applicationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Loan_applications.
     * @param {loan_applicationsDeleteManyArgs} args - Arguments to filter Loan_applications to delete.
     * @example
     * // Delete a few Loan_applications
     * const { count } = await prisma.loan_applications.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends loan_applicationsDeleteManyArgs>(args?: SelectSubset<T, loan_applicationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Loan_applications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {loan_applicationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Loan_applications
     * const loan_applications = await prisma.loan_applications.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends loan_applicationsUpdateManyArgs>(args: SelectSubset<T, loan_applicationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Loan_applications.
     * @param {loan_applicationsUpsertArgs} args - Arguments to update or create a Loan_applications.
     * @example
     * // Update or create a Loan_applications
     * const loan_applications = await prisma.loan_applications.upsert({
     *   create: {
     *     // ... data to create a Loan_applications
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Loan_applications we want to update
     *   }
     * })
     */
    upsert<T extends loan_applicationsUpsertArgs>(args: SelectSubset<T, loan_applicationsUpsertArgs<ExtArgs>>): Prisma__loan_applicationsClient<$Result.GetResult<Prisma.$loan_applicationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Loan_applications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {loan_applicationsCountArgs} args - Arguments to filter Loan_applications to count.
     * @example
     * // Count the number of Loan_applications
     * const count = await prisma.loan_applications.count({
     *   where: {
     *     // ... the filter for the Loan_applications we want to count
     *   }
     * })
    **/
    count<T extends loan_applicationsCountArgs>(
      args?: Subset<T, loan_applicationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Loan_applicationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Loan_applications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Loan_applicationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Loan_applicationsAggregateArgs>(args: Subset<T, Loan_applicationsAggregateArgs>): Prisma.PrismaPromise<GetLoan_applicationsAggregateType<T>>

    /**
     * Group by Loan_applications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {loan_applicationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends loan_applicationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: loan_applicationsGroupByArgs['orderBy'] }
        : { orderBy?: loan_applicationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, loan_applicationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLoan_applicationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the loan_applications model
   */
  readonly fields: loan_applicationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for loan_applications.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__loan_applicationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the loan_applications model
   */
  interface loan_applicationsFieldRefs {
    readonly id: FieldRef<"loan_applications", 'String'>
    readonly customerId: FieldRef<"loan_applications", 'String'>
    readonly agentId: FieldRef<"loan_applications", 'String'>
    readonly loanType: FieldRef<"loan_applications", 'loan_applications_loanType'>
    readonly status: FieldRef<"loan_applications", 'loan_applications_status'>
    readonly currentStep: FieldRef<"loan_applications", 'Int'>
    readonly completedSteps: FieldRef<"loan_applications", 'Json'>
    readonly isNewUser: FieldRef<"loan_applications", 'Boolean'>
    readonly submittedByAgent: FieldRef<"loan_applications", 'Boolean'>
    readonly titleDeedImage: FieldRef<"loan_applications", 'String'>
    readonly titleDeedData: FieldRef<"loan_applications", 'Json'>
    readonly supportingImages: FieldRef<"loan_applications", 'Json'>
    readonly idCardFrontImage: FieldRef<"loan_applications", 'String'>
    readonly idCardBackImage: FieldRef<"loan_applications", 'String'>
    readonly requestedAmount: FieldRef<"loan_applications", 'Decimal'>
    readonly approvedAmount: FieldRef<"loan_applications", 'Decimal'>
    readonly maxApprovedAmount: FieldRef<"loan_applications", 'Decimal'>
    readonly propertyType: FieldRef<"loan_applications", 'String'>
    readonly propertyValue: FieldRef<"loan_applications", 'Decimal'>
    readonly propertyArea: FieldRef<"loan_applications", 'String'>
    readonly propertyLocation: FieldRef<"loan_applications", 'String'>
    readonly landNumber: FieldRef<"loan_applications", 'String'>
    readonly ownerName: FieldRef<"loan_applications", 'String'>
    readonly submittedAt: FieldRef<"loan_applications", 'DateTime'>
    readonly reviewedAt: FieldRef<"loan_applications", 'DateTime'>
    readonly reviewedBy: FieldRef<"loan_applications", 'String'>
    readonly reviewNotes: FieldRef<"loan_applications", 'String'>
    readonly createdAt: FieldRef<"loan_applications", 'DateTime'>
    readonly updatedAt: FieldRef<"loan_applications", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * loan_applications findUnique
   */
  export type loan_applicationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the loan_applications
     */
    select?: loan_applicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the loan_applications
     */
    omit?: loan_applicationsOmit<ExtArgs> | null
    /**
     * Filter, which loan_applications to fetch.
     */
    where: loan_applicationsWhereUniqueInput
  }

  /**
   * loan_applications findUniqueOrThrow
   */
  export type loan_applicationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the loan_applications
     */
    select?: loan_applicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the loan_applications
     */
    omit?: loan_applicationsOmit<ExtArgs> | null
    /**
     * Filter, which loan_applications to fetch.
     */
    where: loan_applicationsWhereUniqueInput
  }

  /**
   * loan_applications findFirst
   */
  export type loan_applicationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the loan_applications
     */
    select?: loan_applicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the loan_applications
     */
    omit?: loan_applicationsOmit<ExtArgs> | null
    /**
     * Filter, which loan_applications to fetch.
     */
    where?: loan_applicationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of loan_applications to fetch.
     */
    orderBy?: loan_applicationsOrderByWithRelationInput | loan_applicationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for loan_applications.
     */
    cursor?: loan_applicationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` loan_applications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` loan_applications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of loan_applications.
     */
    distinct?: Loan_applicationsScalarFieldEnum | Loan_applicationsScalarFieldEnum[]
  }

  /**
   * loan_applications findFirstOrThrow
   */
  export type loan_applicationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the loan_applications
     */
    select?: loan_applicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the loan_applications
     */
    omit?: loan_applicationsOmit<ExtArgs> | null
    /**
     * Filter, which loan_applications to fetch.
     */
    where?: loan_applicationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of loan_applications to fetch.
     */
    orderBy?: loan_applicationsOrderByWithRelationInput | loan_applicationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for loan_applications.
     */
    cursor?: loan_applicationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` loan_applications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` loan_applications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of loan_applications.
     */
    distinct?: Loan_applicationsScalarFieldEnum | Loan_applicationsScalarFieldEnum[]
  }

  /**
   * loan_applications findMany
   */
  export type loan_applicationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the loan_applications
     */
    select?: loan_applicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the loan_applications
     */
    omit?: loan_applicationsOmit<ExtArgs> | null
    /**
     * Filter, which loan_applications to fetch.
     */
    where?: loan_applicationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of loan_applications to fetch.
     */
    orderBy?: loan_applicationsOrderByWithRelationInput | loan_applicationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing loan_applications.
     */
    cursor?: loan_applicationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` loan_applications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` loan_applications.
     */
    skip?: number
    distinct?: Loan_applicationsScalarFieldEnum | Loan_applicationsScalarFieldEnum[]
  }

  /**
   * loan_applications create
   */
  export type loan_applicationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the loan_applications
     */
    select?: loan_applicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the loan_applications
     */
    omit?: loan_applicationsOmit<ExtArgs> | null
    /**
     * The data needed to create a loan_applications.
     */
    data: XOR<loan_applicationsCreateInput, loan_applicationsUncheckedCreateInput>
  }

  /**
   * loan_applications createMany
   */
  export type loan_applicationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many loan_applications.
     */
    data: loan_applicationsCreateManyInput | loan_applicationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * loan_applications update
   */
  export type loan_applicationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the loan_applications
     */
    select?: loan_applicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the loan_applications
     */
    omit?: loan_applicationsOmit<ExtArgs> | null
    /**
     * The data needed to update a loan_applications.
     */
    data: XOR<loan_applicationsUpdateInput, loan_applicationsUncheckedUpdateInput>
    /**
     * Choose, which loan_applications to update.
     */
    where: loan_applicationsWhereUniqueInput
  }

  /**
   * loan_applications updateMany
   */
  export type loan_applicationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update loan_applications.
     */
    data: XOR<loan_applicationsUpdateManyMutationInput, loan_applicationsUncheckedUpdateManyInput>
    /**
     * Filter which loan_applications to update
     */
    where?: loan_applicationsWhereInput
    /**
     * Limit how many loan_applications to update.
     */
    limit?: number
  }

  /**
   * loan_applications upsert
   */
  export type loan_applicationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the loan_applications
     */
    select?: loan_applicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the loan_applications
     */
    omit?: loan_applicationsOmit<ExtArgs> | null
    /**
     * The filter to search for the loan_applications to update in case it exists.
     */
    where: loan_applicationsWhereUniqueInput
    /**
     * In case the loan_applications found by the `where` argument doesn't exist, create a new loan_applications with this data.
     */
    create: XOR<loan_applicationsCreateInput, loan_applicationsUncheckedCreateInput>
    /**
     * In case the loan_applications was found with the provided `where` argument, update it with this data.
     */
    update: XOR<loan_applicationsUpdateInput, loan_applicationsUncheckedUpdateInput>
  }

  /**
   * loan_applications delete
   */
  export type loan_applicationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the loan_applications
     */
    select?: loan_applicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the loan_applications
     */
    omit?: loan_applicationsOmit<ExtArgs> | null
    /**
     * Filter which loan_applications to delete.
     */
    where: loan_applicationsWhereUniqueInput
  }

  /**
   * loan_applications deleteMany
   */
  export type loan_applicationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which loan_applications to delete
     */
    where?: loan_applicationsWhereInput
    /**
     * Limit how many loan_applications to delete.
     */
    limit?: number
  }

  /**
   * loan_applications without action
   */
  export type loan_applicationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the loan_applications
     */
    select?: loan_applicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the loan_applications
     */
    omit?: loan_applicationsOmit<ExtArgs> | null
  }


  /**
   * Model loan_installments
   */

  export type AggregateLoan_installments = {
    _count: Loan_installmentsCountAggregateOutputType | null
    _avg: Loan_installmentsAvgAggregateOutputType | null
    _sum: Loan_installmentsSumAggregateOutputType | null
    _min: Loan_installmentsMinAggregateOutputType | null
    _max: Loan_installmentsMaxAggregateOutputType | null
  }

  export type Loan_installmentsAvgAggregateOutputType = {
    installmentNumber: number | null
    principalAmount: Decimal | null
    interestAmount: Decimal | null
    totalAmount: Decimal | null
    paidAmount: Decimal | null
    lateDays: number | null
    lateFee: Decimal | null
  }

  export type Loan_installmentsSumAggregateOutputType = {
    installmentNumber: number | null
    principalAmount: Decimal | null
    interestAmount: Decimal | null
    totalAmount: Decimal | null
    paidAmount: Decimal | null
    lateDays: number | null
    lateFee: Decimal | null
  }

  export type Loan_installmentsMinAggregateOutputType = {
    id: string | null
    loanId: string | null
    installmentNumber: number | null
    dueDate: Date | null
    principalAmount: Decimal | null
    interestAmount: Decimal | null
    totalAmount: Decimal | null
    isPaid: boolean | null
    paidDate: Date | null
    paidAmount: Decimal | null
    isLate: boolean | null
    lateDays: number | null
    lateFee: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Loan_installmentsMaxAggregateOutputType = {
    id: string | null
    loanId: string | null
    installmentNumber: number | null
    dueDate: Date | null
    principalAmount: Decimal | null
    interestAmount: Decimal | null
    totalAmount: Decimal | null
    isPaid: boolean | null
    paidDate: Date | null
    paidAmount: Decimal | null
    isLate: boolean | null
    lateDays: number | null
    lateFee: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Loan_installmentsCountAggregateOutputType = {
    id: number
    loanId: number
    installmentNumber: number
    dueDate: number
    principalAmount: number
    interestAmount: number
    totalAmount: number
    isPaid: number
    paidDate: number
    paidAmount: number
    isLate: number
    lateDays: number
    lateFee: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Loan_installmentsAvgAggregateInputType = {
    installmentNumber?: true
    principalAmount?: true
    interestAmount?: true
    totalAmount?: true
    paidAmount?: true
    lateDays?: true
    lateFee?: true
  }

  export type Loan_installmentsSumAggregateInputType = {
    installmentNumber?: true
    principalAmount?: true
    interestAmount?: true
    totalAmount?: true
    paidAmount?: true
    lateDays?: true
    lateFee?: true
  }

  export type Loan_installmentsMinAggregateInputType = {
    id?: true
    loanId?: true
    installmentNumber?: true
    dueDate?: true
    principalAmount?: true
    interestAmount?: true
    totalAmount?: true
    isPaid?: true
    paidDate?: true
    paidAmount?: true
    isLate?: true
    lateDays?: true
    lateFee?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Loan_installmentsMaxAggregateInputType = {
    id?: true
    loanId?: true
    installmentNumber?: true
    dueDate?: true
    principalAmount?: true
    interestAmount?: true
    totalAmount?: true
    isPaid?: true
    paidDate?: true
    paidAmount?: true
    isLate?: true
    lateDays?: true
    lateFee?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Loan_installmentsCountAggregateInputType = {
    id?: true
    loanId?: true
    installmentNumber?: true
    dueDate?: true
    principalAmount?: true
    interestAmount?: true
    totalAmount?: true
    isPaid?: true
    paidDate?: true
    paidAmount?: true
    isLate?: true
    lateDays?: true
    lateFee?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Loan_installmentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which loan_installments to aggregate.
     */
    where?: loan_installmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of loan_installments to fetch.
     */
    orderBy?: loan_installmentsOrderByWithRelationInput | loan_installmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: loan_installmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` loan_installments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` loan_installments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned loan_installments
    **/
    _count?: true | Loan_installmentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Loan_installmentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Loan_installmentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Loan_installmentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Loan_installmentsMaxAggregateInputType
  }

  export type GetLoan_installmentsAggregateType<T extends Loan_installmentsAggregateArgs> = {
        [P in keyof T & keyof AggregateLoan_installments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLoan_installments[P]>
      : GetScalarType<T[P], AggregateLoan_installments[P]>
  }




  export type loan_installmentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: loan_installmentsWhereInput
    orderBy?: loan_installmentsOrderByWithAggregationInput | loan_installmentsOrderByWithAggregationInput[]
    by: Loan_installmentsScalarFieldEnum[] | Loan_installmentsScalarFieldEnum
    having?: loan_installmentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Loan_installmentsCountAggregateInputType | true
    _avg?: Loan_installmentsAvgAggregateInputType
    _sum?: Loan_installmentsSumAggregateInputType
    _min?: Loan_installmentsMinAggregateInputType
    _max?: Loan_installmentsMaxAggregateInputType
  }

  export type Loan_installmentsGroupByOutputType = {
    id: string
    loanId: string
    installmentNumber: number
    dueDate: Date
    principalAmount: Decimal
    interestAmount: Decimal
    totalAmount: Decimal
    isPaid: boolean
    paidDate: Date | null
    paidAmount: Decimal | null
    isLate: boolean
    lateDays: number | null
    lateFee: Decimal | null
    createdAt: Date
    updatedAt: Date
    _count: Loan_installmentsCountAggregateOutputType | null
    _avg: Loan_installmentsAvgAggregateOutputType | null
    _sum: Loan_installmentsSumAggregateOutputType | null
    _min: Loan_installmentsMinAggregateOutputType | null
    _max: Loan_installmentsMaxAggregateOutputType | null
  }

  type GetLoan_installmentsGroupByPayload<T extends loan_installmentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Loan_installmentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Loan_installmentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Loan_installmentsGroupByOutputType[P]>
            : GetScalarType<T[P], Loan_installmentsGroupByOutputType[P]>
        }
      >
    >


  export type loan_installmentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    loanId?: boolean
    installmentNumber?: boolean
    dueDate?: boolean
    principalAmount?: boolean
    interestAmount?: boolean
    totalAmount?: boolean
    isPaid?: boolean
    paidDate?: boolean
    paidAmount?: boolean
    isLate?: boolean
    lateDays?: boolean
    lateFee?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["loan_installments"]>



  export type loan_installmentsSelectScalar = {
    id?: boolean
    loanId?: boolean
    installmentNumber?: boolean
    dueDate?: boolean
    principalAmount?: boolean
    interestAmount?: boolean
    totalAmount?: boolean
    isPaid?: boolean
    paidDate?: boolean
    paidAmount?: boolean
    isLate?: boolean
    lateDays?: boolean
    lateFee?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type loan_installmentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "loanId" | "installmentNumber" | "dueDate" | "principalAmount" | "interestAmount" | "totalAmount" | "isPaid" | "paidDate" | "paidAmount" | "isLate" | "lateDays" | "lateFee" | "createdAt" | "updatedAt", ExtArgs["result"]["loan_installments"]>

  export type $loan_installmentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "loan_installments"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      loanId: string
      installmentNumber: number
      dueDate: Date
      principalAmount: Prisma.Decimal
      interestAmount: Prisma.Decimal
      totalAmount: Prisma.Decimal
      isPaid: boolean
      paidDate: Date | null
      paidAmount: Prisma.Decimal | null
      isLate: boolean
      lateDays: number | null
      lateFee: Prisma.Decimal | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["loan_installments"]>
    composites: {}
  }

  type loan_installmentsGetPayload<S extends boolean | null | undefined | loan_installmentsDefaultArgs> = $Result.GetResult<Prisma.$loan_installmentsPayload, S>

  type loan_installmentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<loan_installmentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Loan_installmentsCountAggregateInputType | true
    }

  export interface loan_installmentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['loan_installments'], meta: { name: 'loan_installments' } }
    /**
     * Find zero or one Loan_installments that matches the filter.
     * @param {loan_installmentsFindUniqueArgs} args - Arguments to find a Loan_installments
     * @example
     * // Get one Loan_installments
     * const loan_installments = await prisma.loan_installments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends loan_installmentsFindUniqueArgs>(args: SelectSubset<T, loan_installmentsFindUniqueArgs<ExtArgs>>): Prisma__loan_installmentsClient<$Result.GetResult<Prisma.$loan_installmentsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Loan_installments that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {loan_installmentsFindUniqueOrThrowArgs} args - Arguments to find a Loan_installments
     * @example
     * // Get one Loan_installments
     * const loan_installments = await prisma.loan_installments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends loan_installmentsFindUniqueOrThrowArgs>(args: SelectSubset<T, loan_installmentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__loan_installmentsClient<$Result.GetResult<Prisma.$loan_installmentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Loan_installments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {loan_installmentsFindFirstArgs} args - Arguments to find a Loan_installments
     * @example
     * // Get one Loan_installments
     * const loan_installments = await prisma.loan_installments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends loan_installmentsFindFirstArgs>(args?: SelectSubset<T, loan_installmentsFindFirstArgs<ExtArgs>>): Prisma__loan_installmentsClient<$Result.GetResult<Prisma.$loan_installmentsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Loan_installments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {loan_installmentsFindFirstOrThrowArgs} args - Arguments to find a Loan_installments
     * @example
     * // Get one Loan_installments
     * const loan_installments = await prisma.loan_installments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends loan_installmentsFindFirstOrThrowArgs>(args?: SelectSubset<T, loan_installmentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__loan_installmentsClient<$Result.GetResult<Prisma.$loan_installmentsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Loan_installments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {loan_installmentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Loan_installments
     * const loan_installments = await prisma.loan_installments.findMany()
     * 
     * // Get first 10 Loan_installments
     * const loan_installments = await prisma.loan_installments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const loan_installmentsWithIdOnly = await prisma.loan_installments.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends loan_installmentsFindManyArgs>(args?: SelectSubset<T, loan_installmentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$loan_installmentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Loan_installments.
     * @param {loan_installmentsCreateArgs} args - Arguments to create a Loan_installments.
     * @example
     * // Create one Loan_installments
     * const Loan_installments = await prisma.loan_installments.create({
     *   data: {
     *     // ... data to create a Loan_installments
     *   }
     * })
     * 
     */
    create<T extends loan_installmentsCreateArgs>(args: SelectSubset<T, loan_installmentsCreateArgs<ExtArgs>>): Prisma__loan_installmentsClient<$Result.GetResult<Prisma.$loan_installmentsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Loan_installments.
     * @param {loan_installmentsCreateManyArgs} args - Arguments to create many Loan_installments.
     * @example
     * // Create many Loan_installments
     * const loan_installments = await prisma.loan_installments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends loan_installmentsCreateManyArgs>(args?: SelectSubset<T, loan_installmentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Loan_installments.
     * @param {loan_installmentsDeleteArgs} args - Arguments to delete one Loan_installments.
     * @example
     * // Delete one Loan_installments
     * const Loan_installments = await prisma.loan_installments.delete({
     *   where: {
     *     // ... filter to delete one Loan_installments
     *   }
     * })
     * 
     */
    delete<T extends loan_installmentsDeleteArgs>(args: SelectSubset<T, loan_installmentsDeleteArgs<ExtArgs>>): Prisma__loan_installmentsClient<$Result.GetResult<Prisma.$loan_installmentsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Loan_installments.
     * @param {loan_installmentsUpdateArgs} args - Arguments to update one Loan_installments.
     * @example
     * // Update one Loan_installments
     * const loan_installments = await prisma.loan_installments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends loan_installmentsUpdateArgs>(args: SelectSubset<T, loan_installmentsUpdateArgs<ExtArgs>>): Prisma__loan_installmentsClient<$Result.GetResult<Prisma.$loan_installmentsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Loan_installments.
     * @param {loan_installmentsDeleteManyArgs} args - Arguments to filter Loan_installments to delete.
     * @example
     * // Delete a few Loan_installments
     * const { count } = await prisma.loan_installments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends loan_installmentsDeleteManyArgs>(args?: SelectSubset<T, loan_installmentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Loan_installments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {loan_installmentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Loan_installments
     * const loan_installments = await prisma.loan_installments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends loan_installmentsUpdateManyArgs>(args: SelectSubset<T, loan_installmentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Loan_installments.
     * @param {loan_installmentsUpsertArgs} args - Arguments to update or create a Loan_installments.
     * @example
     * // Update or create a Loan_installments
     * const loan_installments = await prisma.loan_installments.upsert({
     *   create: {
     *     // ... data to create a Loan_installments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Loan_installments we want to update
     *   }
     * })
     */
    upsert<T extends loan_installmentsUpsertArgs>(args: SelectSubset<T, loan_installmentsUpsertArgs<ExtArgs>>): Prisma__loan_installmentsClient<$Result.GetResult<Prisma.$loan_installmentsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Loan_installments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {loan_installmentsCountArgs} args - Arguments to filter Loan_installments to count.
     * @example
     * // Count the number of Loan_installments
     * const count = await prisma.loan_installments.count({
     *   where: {
     *     // ... the filter for the Loan_installments we want to count
     *   }
     * })
    **/
    count<T extends loan_installmentsCountArgs>(
      args?: Subset<T, loan_installmentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Loan_installmentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Loan_installments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Loan_installmentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Loan_installmentsAggregateArgs>(args: Subset<T, Loan_installmentsAggregateArgs>): Prisma.PrismaPromise<GetLoan_installmentsAggregateType<T>>

    /**
     * Group by Loan_installments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {loan_installmentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends loan_installmentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: loan_installmentsGroupByArgs['orderBy'] }
        : { orderBy?: loan_installmentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, loan_installmentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLoan_installmentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the loan_installments model
   */
  readonly fields: loan_installmentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for loan_installments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__loan_installmentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the loan_installments model
   */
  interface loan_installmentsFieldRefs {
    readonly id: FieldRef<"loan_installments", 'String'>
    readonly loanId: FieldRef<"loan_installments", 'String'>
    readonly installmentNumber: FieldRef<"loan_installments", 'Int'>
    readonly dueDate: FieldRef<"loan_installments", 'DateTime'>
    readonly principalAmount: FieldRef<"loan_installments", 'Decimal'>
    readonly interestAmount: FieldRef<"loan_installments", 'Decimal'>
    readonly totalAmount: FieldRef<"loan_installments", 'Decimal'>
    readonly isPaid: FieldRef<"loan_installments", 'Boolean'>
    readonly paidDate: FieldRef<"loan_installments", 'DateTime'>
    readonly paidAmount: FieldRef<"loan_installments", 'Decimal'>
    readonly isLate: FieldRef<"loan_installments", 'Boolean'>
    readonly lateDays: FieldRef<"loan_installments", 'Int'>
    readonly lateFee: FieldRef<"loan_installments", 'Decimal'>
    readonly createdAt: FieldRef<"loan_installments", 'DateTime'>
    readonly updatedAt: FieldRef<"loan_installments", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * loan_installments findUnique
   */
  export type loan_installmentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the loan_installments
     */
    select?: loan_installmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the loan_installments
     */
    omit?: loan_installmentsOmit<ExtArgs> | null
    /**
     * Filter, which loan_installments to fetch.
     */
    where: loan_installmentsWhereUniqueInput
  }

  /**
   * loan_installments findUniqueOrThrow
   */
  export type loan_installmentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the loan_installments
     */
    select?: loan_installmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the loan_installments
     */
    omit?: loan_installmentsOmit<ExtArgs> | null
    /**
     * Filter, which loan_installments to fetch.
     */
    where: loan_installmentsWhereUniqueInput
  }

  /**
   * loan_installments findFirst
   */
  export type loan_installmentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the loan_installments
     */
    select?: loan_installmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the loan_installments
     */
    omit?: loan_installmentsOmit<ExtArgs> | null
    /**
     * Filter, which loan_installments to fetch.
     */
    where?: loan_installmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of loan_installments to fetch.
     */
    orderBy?: loan_installmentsOrderByWithRelationInput | loan_installmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for loan_installments.
     */
    cursor?: loan_installmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` loan_installments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` loan_installments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of loan_installments.
     */
    distinct?: Loan_installmentsScalarFieldEnum | Loan_installmentsScalarFieldEnum[]
  }

  /**
   * loan_installments findFirstOrThrow
   */
  export type loan_installmentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the loan_installments
     */
    select?: loan_installmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the loan_installments
     */
    omit?: loan_installmentsOmit<ExtArgs> | null
    /**
     * Filter, which loan_installments to fetch.
     */
    where?: loan_installmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of loan_installments to fetch.
     */
    orderBy?: loan_installmentsOrderByWithRelationInput | loan_installmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for loan_installments.
     */
    cursor?: loan_installmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` loan_installments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` loan_installments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of loan_installments.
     */
    distinct?: Loan_installmentsScalarFieldEnum | Loan_installmentsScalarFieldEnum[]
  }

  /**
   * loan_installments findMany
   */
  export type loan_installmentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the loan_installments
     */
    select?: loan_installmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the loan_installments
     */
    omit?: loan_installmentsOmit<ExtArgs> | null
    /**
     * Filter, which loan_installments to fetch.
     */
    where?: loan_installmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of loan_installments to fetch.
     */
    orderBy?: loan_installmentsOrderByWithRelationInput | loan_installmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing loan_installments.
     */
    cursor?: loan_installmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` loan_installments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` loan_installments.
     */
    skip?: number
    distinct?: Loan_installmentsScalarFieldEnum | Loan_installmentsScalarFieldEnum[]
  }

  /**
   * loan_installments create
   */
  export type loan_installmentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the loan_installments
     */
    select?: loan_installmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the loan_installments
     */
    omit?: loan_installmentsOmit<ExtArgs> | null
    /**
     * The data needed to create a loan_installments.
     */
    data: XOR<loan_installmentsCreateInput, loan_installmentsUncheckedCreateInput>
  }

  /**
   * loan_installments createMany
   */
  export type loan_installmentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many loan_installments.
     */
    data: loan_installmentsCreateManyInput | loan_installmentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * loan_installments update
   */
  export type loan_installmentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the loan_installments
     */
    select?: loan_installmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the loan_installments
     */
    omit?: loan_installmentsOmit<ExtArgs> | null
    /**
     * The data needed to update a loan_installments.
     */
    data: XOR<loan_installmentsUpdateInput, loan_installmentsUncheckedUpdateInput>
    /**
     * Choose, which loan_installments to update.
     */
    where: loan_installmentsWhereUniqueInput
  }

  /**
   * loan_installments updateMany
   */
  export type loan_installmentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update loan_installments.
     */
    data: XOR<loan_installmentsUpdateManyMutationInput, loan_installmentsUncheckedUpdateManyInput>
    /**
     * Filter which loan_installments to update
     */
    where?: loan_installmentsWhereInput
    /**
     * Limit how many loan_installments to update.
     */
    limit?: number
  }

  /**
   * loan_installments upsert
   */
  export type loan_installmentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the loan_installments
     */
    select?: loan_installmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the loan_installments
     */
    omit?: loan_installmentsOmit<ExtArgs> | null
    /**
     * The filter to search for the loan_installments to update in case it exists.
     */
    where: loan_installmentsWhereUniqueInput
    /**
     * In case the loan_installments found by the `where` argument doesn't exist, create a new loan_installments with this data.
     */
    create: XOR<loan_installmentsCreateInput, loan_installmentsUncheckedCreateInput>
    /**
     * In case the loan_installments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<loan_installmentsUpdateInput, loan_installmentsUncheckedUpdateInput>
  }

  /**
   * loan_installments delete
   */
  export type loan_installmentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the loan_installments
     */
    select?: loan_installmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the loan_installments
     */
    omit?: loan_installmentsOmit<ExtArgs> | null
    /**
     * Filter which loan_installments to delete.
     */
    where: loan_installmentsWhereUniqueInput
  }

  /**
   * loan_installments deleteMany
   */
  export type loan_installmentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which loan_installments to delete
     */
    where?: loan_installmentsWhereInput
    /**
     * Limit how many loan_installments to delete.
     */
    limit?: number
  }

  /**
   * loan_installments without action
   */
  export type loan_installmentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the loan_installments
     */
    select?: loan_installmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the loan_installments
     */
    omit?: loan_installmentsOmit<ExtArgs> | null
  }


  /**
   * Model loans
   */

  export type AggregateLoans = {
    _count: LoansCountAggregateOutputType | null
    _avg: LoansAvgAggregateOutputType | null
    _sum: LoansSumAggregateOutputType | null
    _min: LoansMinAggregateOutputType | null
    _max: LoansMaxAggregateOutputType | null
  }

  export type LoansAvgAggregateOutputType = {
    principalAmount: Decimal | null
    interestRate: Decimal | null
    termMonths: number | null
    monthlyPayment: Decimal | null
    currentInstallment: number | null
    totalInstallments: number | null
    remainingBalance: Decimal | null
    collateralValue: Decimal | null
    landAccountId: number | null
  }

  export type LoansSumAggregateOutputType = {
    principalAmount: Decimal | null
    interestRate: Decimal | null
    termMonths: number | null
    monthlyPayment: Decimal | null
    currentInstallment: number | null
    totalInstallments: number | null
    remainingBalance: Decimal | null
    collateralValue: Decimal | null
    landAccountId: number | null
  }

  export type LoansMinAggregateOutputType = {
    id: string | null
    loanNumber: string | null
    customerId: string | null
    agentId: string | null
    applicationId: string | null
    loanType: $Enums.loans_loanType | null
    status: $Enums.loans_status | null
    principalAmount: Decimal | null
    interestRate: Decimal | null
    termMonths: number | null
    monthlyPayment: Decimal | null
    currentInstallment: number | null
    totalInstallments: number | null
    remainingBalance: Decimal | null
    nextPaymentDate: Date | null
    contractDate: Date | null
    expiryDate: Date | null
    titleDeedNumber: string | null
    collateralValue: Decimal | null
    linkMap: string | null
    landAccountId: number | null
    landAccountName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LoansMaxAggregateOutputType = {
    id: string | null
    loanNumber: string | null
    customerId: string | null
    agentId: string | null
    applicationId: string | null
    loanType: $Enums.loans_loanType | null
    status: $Enums.loans_status | null
    principalAmount: Decimal | null
    interestRate: Decimal | null
    termMonths: number | null
    monthlyPayment: Decimal | null
    currentInstallment: number | null
    totalInstallments: number | null
    remainingBalance: Decimal | null
    nextPaymentDate: Date | null
    contractDate: Date | null
    expiryDate: Date | null
    titleDeedNumber: string | null
    collateralValue: Decimal | null
    linkMap: string | null
    landAccountId: number | null
    landAccountName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LoansCountAggregateOutputType = {
    id: number
    loanNumber: number
    customerId: number
    agentId: number
    applicationId: number
    loanType: number
    status: number
    principalAmount: number
    interestRate: number
    termMonths: number
    monthlyPayment: number
    currentInstallment: number
    totalInstallments: number
    remainingBalance: number
    nextPaymentDate: number
    contractDate: number
    expiryDate: number
    titleDeedNumber: number
    collateralValue: number
    collateralDetails: number
    linkMap: number
    landAccountId: number
    landAccountName: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LoansAvgAggregateInputType = {
    principalAmount?: true
    interestRate?: true
    termMonths?: true
    monthlyPayment?: true
    currentInstallment?: true
    totalInstallments?: true
    remainingBalance?: true
    collateralValue?: true
    landAccountId?: true
  }

  export type LoansSumAggregateInputType = {
    principalAmount?: true
    interestRate?: true
    termMonths?: true
    monthlyPayment?: true
    currentInstallment?: true
    totalInstallments?: true
    remainingBalance?: true
    collateralValue?: true
    landAccountId?: true
  }

  export type LoansMinAggregateInputType = {
    id?: true
    loanNumber?: true
    customerId?: true
    agentId?: true
    applicationId?: true
    loanType?: true
    status?: true
    principalAmount?: true
    interestRate?: true
    termMonths?: true
    monthlyPayment?: true
    currentInstallment?: true
    totalInstallments?: true
    remainingBalance?: true
    nextPaymentDate?: true
    contractDate?: true
    expiryDate?: true
    titleDeedNumber?: true
    collateralValue?: true
    linkMap?: true
    landAccountId?: true
    landAccountName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LoansMaxAggregateInputType = {
    id?: true
    loanNumber?: true
    customerId?: true
    agentId?: true
    applicationId?: true
    loanType?: true
    status?: true
    principalAmount?: true
    interestRate?: true
    termMonths?: true
    monthlyPayment?: true
    currentInstallment?: true
    totalInstallments?: true
    remainingBalance?: true
    nextPaymentDate?: true
    contractDate?: true
    expiryDate?: true
    titleDeedNumber?: true
    collateralValue?: true
    linkMap?: true
    landAccountId?: true
    landAccountName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LoansCountAggregateInputType = {
    id?: true
    loanNumber?: true
    customerId?: true
    agentId?: true
    applicationId?: true
    loanType?: true
    status?: true
    principalAmount?: true
    interestRate?: true
    termMonths?: true
    monthlyPayment?: true
    currentInstallment?: true
    totalInstallments?: true
    remainingBalance?: true
    nextPaymentDate?: true
    contractDate?: true
    expiryDate?: true
    titleDeedNumber?: true
    collateralValue?: true
    collateralDetails?: true
    linkMap?: true
    landAccountId?: true
    landAccountName?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LoansAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which loans to aggregate.
     */
    where?: loansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of loans to fetch.
     */
    orderBy?: loansOrderByWithRelationInput | loansOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: loansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` loans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` loans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned loans
    **/
    _count?: true | LoansCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LoansAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LoansSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LoansMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LoansMaxAggregateInputType
  }

  export type GetLoansAggregateType<T extends LoansAggregateArgs> = {
        [P in keyof T & keyof AggregateLoans]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLoans[P]>
      : GetScalarType<T[P], AggregateLoans[P]>
  }




  export type loansGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: loansWhereInput
    orderBy?: loansOrderByWithAggregationInput | loansOrderByWithAggregationInput[]
    by: LoansScalarFieldEnum[] | LoansScalarFieldEnum
    having?: loansScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LoansCountAggregateInputType | true
    _avg?: LoansAvgAggregateInputType
    _sum?: LoansSumAggregateInputType
    _min?: LoansMinAggregateInputType
    _max?: LoansMaxAggregateInputType
  }

  export type LoansGroupByOutputType = {
    id: string
    loanNumber: string
    customerId: string
    agentId: string | null
    applicationId: string
    loanType: $Enums.loans_loanType
    status: $Enums.loans_status
    principalAmount: Decimal
    interestRate: Decimal
    termMonths: number
    monthlyPayment: Decimal
    currentInstallment: number
    totalInstallments: number
    remainingBalance: Decimal
    nextPaymentDate: Date
    contractDate: Date
    expiryDate: Date
    titleDeedNumber: string | null
    collateralValue: Decimal | null
    collateralDetails: JsonValue | null
    linkMap: string | null
    landAccountId: number | null
    landAccountName: string | null
    createdAt: Date
    updatedAt: Date
    _count: LoansCountAggregateOutputType | null
    _avg: LoansAvgAggregateOutputType | null
    _sum: LoansSumAggregateOutputType | null
    _min: LoansMinAggregateOutputType | null
    _max: LoansMaxAggregateOutputType | null
  }

  type GetLoansGroupByPayload<T extends loansGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LoansGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LoansGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LoansGroupByOutputType[P]>
            : GetScalarType<T[P], LoansGroupByOutputType[P]>
        }
      >
    >


  export type loansSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    loanNumber?: boolean
    customerId?: boolean
    agentId?: boolean
    applicationId?: boolean
    loanType?: boolean
    status?: boolean
    principalAmount?: boolean
    interestRate?: boolean
    termMonths?: boolean
    monthlyPayment?: boolean
    currentInstallment?: boolean
    totalInstallments?: boolean
    remainingBalance?: boolean
    nextPaymentDate?: boolean
    contractDate?: boolean
    expiryDate?: boolean
    titleDeedNumber?: boolean
    collateralValue?: boolean
    collateralDetails?: boolean
    linkMap?: boolean
    landAccountId?: boolean
    landAccountName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["loans"]>



  export type loansSelectScalar = {
    id?: boolean
    loanNumber?: boolean
    customerId?: boolean
    agentId?: boolean
    applicationId?: boolean
    loanType?: boolean
    status?: boolean
    principalAmount?: boolean
    interestRate?: boolean
    termMonths?: boolean
    monthlyPayment?: boolean
    currentInstallment?: boolean
    totalInstallments?: boolean
    remainingBalance?: boolean
    nextPaymentDate?: boolean
    contractDate?: boolean
    expiryDate?: boolean
    titleDeedNumber?: boolean
    collateralValue?: boolean
    collateralDetails?: boolean
    linkMap?: boolean
    landAccountId?: boolean
    landAccountName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type loansOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "loanNumber" | "customerId" | "agentId" | "applicationId" | "loanType" | "status" | "principalAmount" | "interestRate" | "termMonths" | "monthlyPayment" | "currentInstallment" | "totalInstallments" | "remainingBalance" | "nextPaymentDate" | "contractDate" | "expiryDate" | "titleDeedNumber" | "collateralValue" | "collateralDetails" | "linkMap" | "landAccountId" | "landAccountName" | "createdAt" | "updatedAt", ExtArgs["result"]["loans"]>

  export type $loansPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "loans"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      loanNumber: string
      customerId: string
      agentId: string | null
      applicationId: string
      loanType: $Enums.loans_loanType
      status: $Enums.loans_status
      principalAmount: Prisma.Decimal
      interestRate: Prisma.Decimal
      termMonths: number
      monthlyPayment: Prisma.Decimal
      currentInstallment: number
      totalInstallments: number
      remainingBalance: Prisma.Decimal
      nextPaymentDate: Date
      contractDate: Date
      expiryDate: Date
      titleDeedNumber: string | null
      collateralValue: Prisma.Decimal | null
      collateralDetails: Prisma.JsonValue | null
      linkMap: string | null
      landAccountId: number | null
      landAccountName: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["loans"]>
    composites: {}
  }

  type loansGetPayload<S extends boolean | null | undefined | loansDefaultArgs> = $Result.GetResult<Prisma.$loansPayload, S>

  type loansCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<loansFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LoansCountAggregateInputType | true
    }

  export interface loansDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['loans'], meta: { name: 'loans' } }
    /**
     * Find zero or one Loans that matches the filter.
     * @param {loansFindUniqueArgs} args - Arguments to find a Loans
     * @example
     * // Get one Loans
     * const loans = await prisma.loans.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends loansFindUniqueArgs>(args: SelectSubset<T, loansFindUniqueArgs<ExtArgs>>): Prisma__loansClient<$Result.GetResult<Prisma.$loansPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Loans that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {loansFindUniqueOrThrowArgs} args - Arguments to find a Loans
     * @example
     * // Get one Loans
     * const loans = await prisma.loans.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends loansFindUniqueOrThrowArgs>(args: SelectSubset<T, loansFindUniqueOrThrowArgs<ExtArgs>>): Prisma__loansClient<$Result.GetResult<Prisma.$loansPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Loans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {loansFindFirstArgs} args - Arguments to find a Loans
     * @example
     * // Get one Loans
     * const loans = await prisma.loans.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends loansFindFirstArgs>(args?: SelectSubset<T, loansFindFirstArgs<ExtArgs>>): Prisma__loansClient<$Result.GetResult<Prisma.$loansPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Loans that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {loansFindFirstOrThrowArgs} args - Arguments to find a Loans
     * @example
     * // Get one Loans
     * const loans = await prisma.loans.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends loansFindFirstOrThrowArgs>(args?: SelectSubset<T, loansFindFirstOrThrowArgs<ExtArgs>>): Prisma__loansClient<$Result.GetResult<Prisma.$loansPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Loans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {loansFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Loans
     * const loans = await prisma.loans.findMany()
     * 
     * // Get first 10 Loans
     * const loans = await prisma.loans.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const loansWithIdOnly = await prisma.loans.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends loansFindManyArgs>(args?: SelectSubset<T, loansFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$loansPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Loans.
     * @param {loansCreateArgs} args - Arguments to create a Loans.
     * @example
     * // Create one Loans
     * const Loans = await prisma.loans.create({
     *   data: {
     *     // ... data to create a Loans
     *   }
     * })
     * 
     */
    create<T extends loansCreateArgs>(args: SelectSubset<T, loansCreateArgs<ExtArgs>>): Prisma__loansClient<$Result.GetResult<Prisma.$loansPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Loans.
     * @param {loansCreateManyArgs} args - Arguments to create many Loans.
     * @example
     * // Create many Loans
     * const loans = await prisma.loans.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends loansCreateManyArgs>(args?: SelectSubset<T, loansCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Loans.
     * @param {loansDeleteArgs} args - Arguments to delete one Loans.
     * @example
     * // Delete one Loans
     * const Loans = await prisma.loans.delete({
     *   where: {
     *     // ... filter to delete one Loans
     *   }
     * })
     * 
     */
    delete<T extends loansDeleteArgs>(args: SelectSubset<T, loansDeleteArgs<ExtArgs>>): Prisma__loansClient<$Result.GetResult<Prisma.$loansPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Loans.
     * @param {loansUpdateArgs} args - Arguments to update one Loans.
     * @example
     * // Update one Loans
     * const loans = await prisma.loans.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends loansUpdateArgs>(args: SelectSubset<T, loansUpdateArgs<ExtArgs>>): Prisma__loansClient<$Result.GetResult<Prisma.$loansPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Loans.
     * @param {loansDeleteManyArgs} args - Arguments to filter Loans to delete.
     * @example
     * // Delete a few Loans
     * const { count } = await prisma.loans.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends loansDeleteManyArgs>(args?: SelectSubset<T, loansDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Loans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {loansUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Loans
     * const loans = await prisma.loans.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends loansUpdateManyArgs>(args: SelectSubset<T, loansUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Loans.
     * @param {loansUpsertArgs} args - Arguments to update or create a Loans.
     * @example
     * // Update or create a Loans
     * const loans = await prisma.loans.upsert({
     *   create: {
     *     // ... data to create a Loans
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Loans we want to update
     *   }
     * })
     */
    upsert<T extends loansUpsertArgs>(args: SelectSubset<T, loansUpsertArgs<ExtArgs>>): Prisma__loansClient<$Result.GetResult<Prisma.$loansPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Loans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {loansCountArgs} args - Arguments to filter Loans to count.
     * @example
     * // Count the number of Loans
     * const count = await prisma.loans.count({
     *   where: {
     *     // ... the filter for the Loans we want to count
     *   }
     * })
    **/
    count<T extends loansCountArgs>(
      args?: Subset<T, loansCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LoansCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Loans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoansAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LoansAggregateArgs>(args: Subset<T, LoansAggregateArgs>): Prisma.PrismaPromise<GetLoansAggregateType<T>>

    /**
     * Group by Loans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {loansGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends loansGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: loansGroupByArgs['orderBy'] }
        : { orderBy?: loansGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, loansGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLoansGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the loans model
   */
  readonly fields: loansFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for loans.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__loansClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the loans model
   */
  interface loansFieldRefs {
    readonly id: FieldRef<"loans", 'String'>
    readonly loanNumber: FieldRef<"loans", 'String'>
    readonly customerId: FieldRef<"loans", 'String'>
    readonly agentId: FieldRef<"loans", 'String'>
    readonly applicationId: FieldRef<"loans", 'String'>
    readonly loanType: FieldRef<"loans", 'loans_loanType'>
    readonly status: FieldRef<"loans", 'loans_status'>
    readonly principalAmount: FieldRef<"loans", 'Decimal'>
    readonly interestRate: FieldRef<"loans", 'Decimal'>
    readonly termMonths: FieldRef<"loans", 'Int'>
    readonly monthlyPayment: FieldRef<"loans", 'Decimal'>
    readonly currentInstallment: FieldRef<"loans", 'Int'>
    readonly totalInstallments: FieldRef<"loans", 'Int'>
    readonly remainingBalance: FieldRef<"loans", 'Decimal'>
    readonly nextPaymentDate: FieldRef<"loans", 'DateTime'>
    readonly contractDate: FieldRef<"loans", 'DateTime'>
    readonly expiryDate: FieldRef<"loans", 'DateTime'>
    readonly titleDeedNumber: FieldRef<"loans", 'String'>
    readonly collateralValue: FieldRef<"loans", 'Decimal'>
    readonly collateralDetails: FieldRef<"loans", 'Json'>
    readonly linkMap: FieldRef<"loans", 'String'>
    readonly landAccountId: FieldRef<"loans", 'Int'>
    readonly landAccountName: FieldRef<"loans", 'String'>
    readonly createdAt: FieldRef<"loans", 'DateTime'>
    readonly updatedAt: FieldRef<"loans", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * loans findUnique
   */
  export type loansFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the loans
     */
    select?: loansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the loans
     */
    omit?: loansOmit<ExtArgs> | null
    /**
     * Filter, which loans to fetch.
     */
    where: loansWhereUniqueInput
  }

  /**
   * loans findUniqueOrThrow
   */
  export type loansFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the loans
     */
    select?: loansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the loans
     */
    omit?: loansOmit<ExtArgs> | null
    /**
     * Filter, which loans to fetch.
     */
    where: loansWhereUniqueInput
  }

  /**
   * loans findFirst
   */
  export type loansFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the loans
     */
    select?: loansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the loans
     */
    omit?: loansOmit<ExtArgs> | null
    /**
     * Filter, which loans to fetch.
     */
    where?: loansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of loans to fetch.
     */
    orderBy?: loansOrderByWithRelationInput | loansOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for loans.
     */
    cursor?: loansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` loans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` loans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of loans.
     */
    distinct?: LoansScalarFieldEnum | LoansScalarFieldEnum[]
  }

  /**
   * loans findFirstOrThrow
   */
  export type loansFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the loans
     */
    select?: loansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the loans
     */
    omit?: loansOmit<ExtArgs> | null
    /**
     * Filter, which loans to fetch.
     */
    where?: loansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of loans to fetch.
     */
    orderBy?: loansOrderByWithRelationInput | loansOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for loans.
     */
    cursor?: loansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` loans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` loans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of loans.
     */
    distinct?: LoansScalarFieldEnum | LoansScalarFieldEnum[]
  }

  /**
   * loans findMany
   */
  export type loansFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the loans
     */
    select?: loansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the loans
     */
    omit?: loansOmit<ExtArgs> | null
    /**
     * Filter, which loans to fetch.
     */
    where?: loansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of loans to fetch.
     */
    orderBy?: loansOrderByWithRelationInput | loansOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing loans.
     */
    cursor?: loansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` loans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` loans.
     */
    skip?: number
    distinct?: LoansScalarFieldEnum | LoansScalarFieldEnum[]
  }

  /**
   * loans create
   */
  export type loansCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the loans
     */
    select?: loansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the loans
     */
    omit?: loansOmit<ExtArgs> | null
    /**
     * The data needed to create a loans.
     */
    data: XOR<loansCreateInput, loansUncheckedCreateInput>
  }

  /**
   * loans createMany
   */
  export type loansCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many loans.
     */
    data: loansCreateManyInput | loansCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * loans update
   */
  export type loansUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the loans
     */
    select?: loansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the loans
     */
    omit?: loansOmit<ExtArgs> | null
    /**
     * The data needed to update a loans.
     */
    data: XOR<loansUpdateInput, loansUncheckedUpdateInput>
    /**
     * Choose, which loans to update.
     */
    where: loansWhereUniqueInput
  }

  /**
   * loans updateMany
   */
  export type loansUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update loans.
     */
    data: XOR<loansUpdateManyMutationInput, loansUncheckedUpdateManyInput>
    /**
     * Filter which loans to update
     */
    where?: loansWhereInput
    /**
     * Limit how many loans to update.
     */
    limit?: number
  }

  /**
   * loans upsert
   */
  export type loansUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the loans
     */
    select?: loansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the loans
     */
    omit?: loansOmit<ExtArgs> | null
    /**
     * The filter to search for the loans to update in case it exists.
     */
    where: loansWhereUniqueInput
    /**
     * In case the loans found by the `where` argument doesn't exist, create a new loans with this data.
     */
    create: XOR<loansCreateInput, loansUncheckedCreateInput>
    /**
     * In case the loans was found with the provided `where` argument, update it with this data.
     */
    update: XOR<loansUpdateInput, loansUncheckedUpdateInput>
  }

  /**
   * loans delete
   */
  export type loansDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the loans
     */
    select?: loansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the loans
     */
    omit?: loansOmit<ExtArgs> | null
    /**
     * Filter which loans to delete.
     */
    where: loansWhereUniqueInput
  }

  /**
   * loans deleteMany
   */
  export type loansDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which loans to delete
     */
    where?: loansWhereInput
    /**
     * Limit how many loans to delete.
     */
    limit?: number
  }

  /**
   * loans without action
   */
  export type loansDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the loans
     */
    select?: loansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the loans
     */
    omit?: loansOmit<ExtArgs> | null
  }


  /**
   * Model notifications
   */

  export type AggregateNotifications = {
    _count: NotificationsCountAggregateOutputType | null
    _min: NotificationsMinAggregateOutputType | null
    _max: NotificationsMaxAggregateOutputType | null
  }

  export type NotificationsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.notifications_type | null
    title: string | null
    message: string | null
    actionUrl: string | null
    isRead: boolean | null
    readAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.notifications_type | null
    title: string | null
    message: string | null
    actionUrl: string | null
    isRead: boolean | null
    readAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationsCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    title: number
    message: number
    actionUrl: number
    isRead: number
    readAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationsMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    actionUrl?: true
    isRead?: true
    readAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationsMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    actionUrl?: true
    isRead?: true
    readAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationsCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    actionUrl?: true
    isRead?: true
    readAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notifications to aggregate.
     */
    where?: notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned notifications
    **/
    _count?: true | NotificationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationsMaxAggregateInputType
  }

  export type GetNotificationsAggregateType<T extends NotificationsAggregateArgs> = {
        [P in keyof T & keyof AggregateNotifications]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotifications[P]>
      : GetScalarType<T[P], AggregateNotifications[P]>
  }




  export type notificationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notificationsWhereInput
    orderBy?: notificationsOrderByWithAggregationInput | notificationsOrderByWithAggregationInput[]
    by: NotificationsScalarFieldEnum[] | NotificationsScalarFieldEnum
    having?: notificationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationsCountAggregateInputType | true
    _min?: NotificationsMinAggregateInputType
    _max?: NotificationsMaxAggregateInputType
  }

  export type NotificationsGroupByOutputType = {
    id: string
    userId: string
    type: $Enums.notifications_type
    title: string
    message: string
    actionUrl: string | null
    isRead: boolean
    readAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: NotificationsCountAggregateOutputType | null
    _min: NotificationsMinAggregateOutputType | null
    _max: NotificationsMaxAggregateOutputType | null
  }

  type GetNotificationsGroupByPayload<T extends notificationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationsGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationsGroupByOutputType[P]>
        }
      >
    >


  export type notificationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    actionUrl?: boolean
    isRead?: boolean
    readAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["notifications"]>



  export type notificationsSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    actionUrl?: boolean
    isRead?: boolean
    readAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type notificationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "title" | "message" | "actionUrl" | "isRead" | "readAt" | "createdAt" | "updatedAt", ExtArgs["result"]["notifications"]>

  export type $notificationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "notifications"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: $Enums.notifications_type
      title: string
      message: string
      actionUrl: string | null
      isRead: boolean
      readAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notifications"]>
    composites: {}
  }

  type notificationsGetPayload<S extends boolean | null | undefined | notificationsDefaultArgs> = $Result.GetResult<Prisma.$notificationsPayload, S>

  type notificationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<notificationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationsCountAggregateInputType | true
    }

  export interface notificationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['notifications'], meta: { name: 'notifications' } }
    /**
     * Find zero or one Notifications that matches the filter.
     * @param {notificationsFindUniqueArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends notificationsFindUniqueArgs>(args: SelectSubset<T, notificationsFindUniqueArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notifications that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {notificationsFindUniqueOrThrowArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends notificationsFindUniqueOrThrowArgs>(args: SelectSubset<T, notificationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsFindFirstArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends notificationsFindFirstArgs>(args?: SelectSubset<T, notificationsFindFirstArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notifications that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsFindFirstOrThrowArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends notificationsFindFirstOrThrowArgs>(args?: SelectSubset<T, notificationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notifications.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notifications.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationsWithIdOnly = await prisma.notifications.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends notificationsFindManyArgs>(args?: SelectSubset<T, notificationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notifications.
     * @param {notificationsCreateArgs} args - Arguments to create a Notifications.
     * @example
     * // Create one Notifications
     * const Notifications = await prisma.notifications.create({
     *   data: {
     *     // ... data to create a Notifications
     *   }
     * })
     * 
     */
    create<T extends notificationsCreateArgs>(args: SelectSubset<T, notificationsCreateArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {notificationsCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notifications = await prisma.notifications.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends notificationsCreateManyArgs>(args?: SelectSubset<T, notificationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Notifications.
     * @param {notificationsDeleteArgs} args - Arguments to delete one Notifications.
     * @example
     * // Delete one Notifications
     * const Notifications = await prisma.notifications.delete({
     *   where: {
     *     // ... filter to delete one Notifications
     *   }
     * })
     * 
     */
    delete<T extends notificationsDeleteArgs>(args: SelectSubset<T, notificationsDeleteArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notifications.
     * @param {notificationsUpdateArgs} args - Arguments to update one Notifications.
     * @example
     * // Update one Notifications
     * const notifications = await prisma.notifications.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends notificationsUpdateArgs>(args: SelectSubset<T, notificationsUpdateArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {notificationsDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notifications.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends notificationsDeleteManyArgs>(args?: SelectSubset<T, notificationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notifications = await prisma.notifications.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends notificationsUpdateManyArgs>(args: SelectSubset<T, notificationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notifications.
     * @param {notificationsUpsertArgs} args - Arguments to update or create a Notifications.
     * @example
     * // Update or create a Notifications
     * const notifications = await prisma.notifications.upsert({
     *   create: {
     *     // ... data to create a Notifications
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notifications we want to update
     *   }
     * })
     */
    upsert<T extends notificationsUpsertArgs>(args: SelectSubset<T, notificationsUpsertArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notifications.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends notificationsCountArgs>(
      args?: Subset<T, notificationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationsAggregateArgs>(args: Subset<T, NotificationsAggregateArgs>): Prisma.PrismaPromise<GetNotificationsAggregateType<T>>

    /**
     * Group by Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends notificationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: notificationsGroupByArgs['orderBy'] }
        : { orderBy?: notificationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, notificationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the notifications model
   */
  readonly fields: notificationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for notifications.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__notificationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the notifications model
   */
  interface notificationsFieldRefs {
    readonly id: FieldRef<"notifications", 'String'>
    readonly userId: FieldRef<"notifications", 'String'>
    readonly type: FieldRef<"notifications", 'notifications_type'>
    readonly title: FieldRef<"notifications", 'String'>
    readonly message: FieldRef<"notifications", 'String'>
    readonly actionUrl: FieldRef<"notifications", 'String'>
    readonly isRead: FieldRef<"notifications", 'Boolean'>
    readonly readAt: FieldRef<"notifications", 'DateTime'>
    readonly createdAt: FieldRef<"notifications", 'DateTime'>
    readonly updatedAt: FieldRef<"notifications", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * notifications findUnique
   */
  export type notificationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where: notificationsWhereUniqueInput
  }

  /**
   * notifications findUniqueOrThrow
   */
  export type notificationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where: notificationsWhereUniqueInput
  }

  /**
   * notifications findFirst
   */
  export type notificationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where?: notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notifications.
     */
    cursor?: notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notifications.
     */
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * notifications findFirstOrThrow
   */
  export type notificationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where?: notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notifications.
     */
    cursor?: notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notifications.
     */
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * notifications findMany
   */
  export type notificationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where?: notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing notifications.
     */
    cursor?: notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * notifications create
   */
  export type notificationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * The data needed to create a notifications.
     */
    data: XOR<notificationsCreateInput, notificationsUncheckedCreateInput>
  }

  /**
   * notifications createMany
   */
  export type notificationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many notifications.
     */
    data: notificationsCreateManyInput | notificationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * notifications update
   */
  export type notificationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * The data needed to update a notifications.
     */
    data: XOR<notificationsUpdateInput, notificationsUncheckedUpdateInput>
    /**
     * Choose, which notifications to update.
     */
    where: notificationsWhereUniqueInput
  }

  /**
   * notifications updateMany
   */
  export type notificationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update notifications.
     */
    data: XOR<notificationsUpdateManyMutationInput, notificationsUncheckedUpdateManyInput>
    /**
     * Filter which notifications to update
     */
    where?: notificationsWhereInput
    /**
     * Limit how many notifications to update.
     */
    limit?: number
  }

  /**
   * notifications upsert
   */
  export type notificationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * The filter to search for the notifications to update in case it exists.
     */
    where: notificationsWhereUniqueInput
    /**
     * In case the notifications found by the `where` argument doesn't exist, create a new notifications with this data.
     */
    create: XOR<notificationsCreateInput, notificationsUncheckedCreateInput>
    /**
     * In case the notifications was found with the provided `where` argument, update it with this data.
     */
    update: XOR<notificationsUpdateInput, notificationsUncheckedUpdateInput>
  }

  /**
   * notifications delete
   */
  export type notificationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Filter which notifications to delete.
     */
    where: notificationsWhereUniqueInput
  }

  /**
   * notifications deleteMany
   */
  export type notificationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notifications to delete
     */
    where?: notificationsWhereInput
    /**
     * Limit how many notifications to delete.
     */
    limit?: number
  }

  /**
   * notifications without action
   */
  export type notificationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
  }


  /**
   * Model payments
   */

  export type AggregatePayments = {
    _count: PaymentsCountAggregateOutputType | null
    _avg: PaymentsAvgAggregateOutputType | null
    _sum: PaymentsSumAggregateOutputType | null
    _min: PaymentsMinAggregateOutputType | null
    _max: PaymentsMaxAggregateOutputType | null
  }

  export type PaymentsAvgAggregateOutputType = {
    amount: Decimal | null
    principalAmount: Decimal | null
    interestAmount: Decimal | null
    feeAmount: Decimal | null
  }

  export type PaymentsSumAggregateOutputType = {
    amount: Decimal | null
    principalAmount: Decimal | null
    interestAmount: Decimal | null
    feeAmount: Decimal | null
  }

  export type PaymentsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    loanId: string | null
    installmentId: string | null
    amount: Decimal | null
    paymentMethod: $Enums.payments_paymentMethod | null
    status: $Enums.payments_status | null
    referenceNumber: string | null
    transactionId: string | null
    qrCode: string | null
    barcodeNumber: string | null
    bankName: string | null
    accountNumber: string | null
    accountName: string | null
    dueDate: Date | null
    paidDate: Date | null
    principalAmount: Decimal | null
    interestAmount: Decimal | null
    feeAmount: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    loanId: string | null
    installmentId: string | null
    amount: Decimal | null
    paymentMethod: $Enums.payments_paymentMethod | null
    status: $Enums.payments_status | null
    referenceNumber: string | null
    transactionId: string | null
    qrCode: string | null
    barcodeNumber: string | null
    bankName: string | null
    accountNumber: string | null
    accountName: string | null
    dueDate: Date | null
    paidDate: Date | null
    principalAmount: Decimal | null
    interestAmount: Decimal | null
    feeAmount: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentsCountAggregateOutputType = {
    id: number
    userId: number
    loanId: number
    installmentId: number
    amount: number
    paymentMethod: number
    status: number
    referenceNumber: number
    transactionId: number
    qrCode: number
    barcodeNumber: number
    bankName: number
    accountNumber: number
    accountName: number
    dueDate: number
    paidDate: number
    principalAmount: number
    interestAmount: number
    feeAmount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentsAvgAggregateInputType = {
    amount?: true
    principalAmount?: true
    interestAmount?: true
    feeAmount?: true
  }

  export type PaymentsSumAggregateInputType = {
    amount?: true
    principalAmount?: true
    interestAmount?: true
    feeAmount?: true
  }

  export type PaymentsMinAggregateInputType = {
    id?: true
    userId?: true
    loanId?: true
    installmentId?: true
    amount?: true
    paymentMethod?: true
    status?: true
    referenceNumber?: true
    transactionId?: true
    qrCode?: true
    barcodeNumber?: true
    bankName?: true
    accountNumber?: true
    accountName?: true
    dueDate?: true
    paidDate?: true
    principalAmount?: true
    interestAmount?: true
    feeAmount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentsMaxAggregateInputType = {
    id?: true
    userId?: true
    loanId?: true
    installmentId?: true
    amount?: true
    paymentMethod?: true
    status?: true
    referenceNumber?: true
    transactionId?: true
    qrCode?: true
    barcodeNumber?: true
    bankName?: true
    accountNumber?: true
    accountName?: true
    dueDate?: true
    paidDate?: true
    principalAmount?: true
    interestAmount?: true
    feeAmount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentsCountAggregateInputType = {
    id?: true
    userId?: true
    loanId?: true
    installmentId?: true
    amount?: true
    paymentMethod?: true
    status?: true
    referenceNumber?: true
    transactionId?: true
    qrCode?: true
    barcodeNumber?: true
    bankName?: true
    accountNumber?: true
    accountName?: true
    dueDate?: true
    paidDate?: true
    principalAmount?: true
    interestAmount?: true
    feeAmount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payments to aggregate.
     */
    where?: paymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: paymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned payments
    **/
    _count?: true | PaymentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentsMaxAggregateInputType
  }

  export type GetPaymentsAggregateType<T extends PaymentsAggregateArgs> = {
        [P in keyof T & keyof AggregatePayments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayments[P]>
      : GetScalarType<T[P], AggregatePayments[P]>
  }




  export type paymentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: paymentsWhereInput
    orderBy?: paymentsOrderByWithAggregationInput | paymentsOrderByWithAggregationInput[]
    by: PaymentsScalarFieldEnum[] | PaymentsScalarFieldEnum
    having?: paymentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentsCountAggregateInputType | true
    _avg?: PaymentsAvgAggregateInputType
    _sum?: PaymentsSumAggregateInputType
    _min?: PaymentsMinAggregateInputType
    _max?: PaymentsMaxAggregateInputType
  }

  export type PaymentsGroupByOutputType = {
    id: string
    userId: string
    loanId: string
    installmentId: string | null
    amount: Decimal
    paymentMethod: $Enums.payments_paymentMethod
    status: $Enums.payments_status
    referenceNumber: string
    transactionId: string | null
    qrCode: string | null
    barcodeNumber: string | null
    bankName: string | null
    accountNumber: string | null
    accountName: string | null
    dueDate: Date
    paidDate: Date | null
    principalAmount: Decimal
    interestAmount: Decimal
    feeAmount: Decimal
    createdAt: Date
    updatedAt: Date
    _count: PaymentsCountAggregateOutputType | null
    _avg: PaymentsAvgAggregateOutputType | null
    _sum: PaymentsSumAggregateOutputType | null
    _min: PaymentsMinAggregateOutputType | null
    _max: PaymentsMaxAggregateOutputType | null
  }

  type GetPaymentsGroupByPayload<T extends paymentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentsGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentsGroupByOutputType[P]>
        }
      >
    >


  export type paymentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    loanId?: boolean
    installmentId?: boolean
    amount?: boolean
    paymentMethod?: boolean
    status?: boolean
    referenceNumber?: boolean
    transactionId?: boolean
    qrCode?: boolean
    barcodeNumber?: boolean
    bankName?: boolean
    accountNumber?: boolean
    accountName?: boolean
    dueDate?: boolean
    paidDate?: boolean
    principalAmount?: boolean
    interestAmount?: boolean
    feeAmount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["payments"]>



  export type paymentsSelectScalar = {
    id?: boolean
    userId?: boolean
    loanId?: boolean
    installmentId?: boolean
    amount?: boolean
    paymentMethod?: boolean
    status?: boolean
    referenceNumber?: boolean
    transactionId?: boolean
    qrCode?: boolean
    barcodeNumber?: boolean
    bankName?: boolean
    accountNumber?: boolean
    accountName?: boolean
    dueDate?: boolean
    paidDate?: boolean
    principalAmount?: boolean
    interestAmount?: boolean
    feeAmount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type paymentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "loanId" | "installmentId" | "amount" | "paymentMethod" | "status" | "referenceNumber" | "transactionId" | "qrCode" | "barcodeNumber" | "bankName" | "accountNumber" | "accountName" | "dueDate" | "paidDate" | "principalAmount" | "interestAmount" | "feeAmount" | "createdAt" | "updatedAt", ExtArgs["result"]["payments"]>

  export type $paymentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "payments"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      loanId: string
      installmentId: string | null
      amount: Prisma.Decimal
      paymentMethod: $Enums.payments_paymentMethod
      status: $Enums.payments_status
      referenceNumber: string
      transactionId: string | null
      qrCode: string | null
      barcodeNumber: string | null
      bankName: string | null
      accountNumber: string | null
      accountName: string | null
      dueDate: Date
      paidDate: Date | null
      principalAmount: Prisma.Decimal
      interestAmount: Prisma.Decimal
      feeAmount: Prisma.Decimal
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["payments"]>
    composites: {}
  }

  type paymentsGetPayload<S extends boolean | null | undefined | paymentsDefaultArgs> = $Result.GetResult<Prisma.$paymentsPayload, S>

  type paymentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<paymentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentsCountAggregateInputType | true
    }

  export interface paymentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['payments'], meta: { name: 'payments' } }
    /**
     * Find zero or one Payments that matches the filter.
     * @param {paymentsFindUniqueArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends paymentsFindUniqueArgs>(args: SelectSubset<T, paymentsFindUniqueArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payments that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {paymentsFindUniqueOrThrowArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends paymentsFindUniqueOrThrowArgs>(args: SelectSubset<T, paymentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsFindFirstArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends paymentsFindFirstArgs>(args?: SelectSubset<T, paymentsFindFirstArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsFindFirstOrThrowArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends paymentsFindFirstOrThrowArgs>(args?: SelectSubset<T, paymentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payments.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentsWithIdOnly = await prisma.payments.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends paymentsFindManyArgs>(args?: SelectSubset<T, paymentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payments.
     * @param {paymentsCreateArgs} args - Arguments to create a Payments.
     * @example
     * // Create one Payments
     * const Payments = await prisma.payments.create({
     *   data: {
     *     // ... data to create a Payments
     *   }
     * })
     * 
     */
    create<T extends paymentsCreateArgs>(args: SelectSubset<T, paymentsCreateArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {paymentsCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payments = await prisma.payments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends paymentsCreateManyArgs>(args?: SelectSubset<T, paymentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Payments.
     * @param {paymentsDeleteArgs} args - Arguments to delete one Payments.
     * @example
     * // Delete one Payments
     * const Payments = await prisma.payments.delete({
     *   where: {
     *     // ... filter to delete one Payments
     *   }
     * })
     * 
     */
    delete<T extends paymentsDeleteArgs>(args: SelectSubset<T, paymentsDeleteArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payments.
     * @param {paymentsUpdateArgs} args - Arguments to update one Payments.
     * @example
     * // Update one Payments
     * const payments = await prisma.payments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends paymentsUpdateArgs>(args: SelectSubset<T, paymentsUpdateArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {paymentsDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends paymentsDeleteManyArgs>(args?: SelectSubset<T, paymentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payments = await prisma.payments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends paymentsUpdateManyArgs>(args: SelectSubset<T, paymentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payments.
     * @param {paymentsUpsertArgs} args - Arguments to update or create a Payments.
     * @example
     * // Update or create a Payments
     * const payments = await prisma.payments.upsert({
     *   create: {
     *     // ... data to create a Payments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payments we want to update
     *   }
     * })
     */
    upsert<T extends paymentsUpsertArgs>(args: SelectSubset<T, paymentsUpsertArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payments.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends paymentsCountArgs>(
      args?: Subset<T, paymentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentsAggregateArgs>(args: Subset<T, PaymentsAggregateArgs>): Prisma.PrismaPromise<GetPaymentsAggregateType<T>>

    /**
     * Group by Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends paymentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: paymentsGroupByArgs['orderBy'] }
        : { orderBy?: paymentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, paymentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the payments model
   */
  readonly fields: paymentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for payments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__paymentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the payments model
   */
  interface paymentsFieldRefs {
    readonly id: FieldRef<"payments", 'String'>
    readonly userId: FieldRef<"payments", 'String'>
    readonly loanId: FieldRef<"payments", 'String'>
    readonly installmentId: FieldRef<"payments", 'String'>
    readonly amount: FieldRef<"payments", 'Decimal'>
    readonly paymentMethod: FieldRef<"payments", 'payments_paymentMethod'>
    readonly status: FieldRef<"payments", 'payments_status'>
    readonly referenceNumber: FieldRef<"payments", 'String'>
    readonly transactionId: FieldRef<"payments", 'String'>
    readonly qrCode: FieldRef<"payments", 'String'>
    readonly barcodeNumber: FieldRef<"payments", 'String'>
    readonly bankName: FieldRef<"payments", 'String'>
    readonly accountNumber: FieldRef<"payments", 'String'>
    readonly accountName: FieldRef<"payments", 'String'>
    readonly dueDate: FieldRef<"payments", 'DateTime'>
    readonly paidDate: FieldRef<"payments", 'DateTime'>
    readonly principalAmount: FieldRef<"payments", 'Decimal'>
    readonly interestAmount: FieldRef<"payments", 'Decimal'>
    readonly feeAmount: FieldRef<"payments", 'Decimal'>
    readonly createdAt: FieldRef<"payments", 'DateTime'>
    readonly updatedAt: FieldRef<"payments", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * payments findUnique
   */
  export type paymentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where: paymentsWhereUniqueInput
  }

  /**
   * payments findUniqueOrThrow
   */
  export type paymentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where: paymentsWhereUniqueInput
  }

  /**
   * payments findFirst
   */
  export type paymentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where?: paymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payments.
     */
    cursor?: paymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payments.
     */
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * payments findFirstOrThrow
   */
  export type paymentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where?: paymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payments.
     */
    cursor?: paymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payments.
     */
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * payments findMany
   */
  export type paymentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where?: paymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing payments.
     */
    cursor?: paymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * payments create
   */
  export type paymentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * The data needed to create a payments.
     */
    data: XOR<paymentsCreateInput, paymentsUncheckedCreateInput>
  }

  /**
   * payments createMany
   */
  export type paymentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many payments.
     */
    data: paymentsCreateManyInput | paymentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * payments update
   */
  export type paymentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * The data needed to update a payments.
     */
    data: XOR<paymentsUpdateInput, paymentsUncheckedUpdateInput>
    /**
     * Choose, which payments to update.
     */
    where: paymentsWhereUniqueInput
  }

  /**
   * payments updateMany
   */
  export type paymentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update payments.
     */
    data: XOR<paymentsUpdateManyMutationInput, paymentsUncheckedUpdateManyInput>
    /**
     * Filter which payments to update
     */
    where?: paymentsWhereInput
    /**
     * Limit how many payments to update.
     */
    limit?: number
  }

  /**
   * payments upsert
   */
  export type paymentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * The filter to search for the payments to update in case it exists.
     */
    where: paymentsWhereUniqueInput
    /**
     * In case the payments found by the `where` argument doesn't exist, create a new payments with this data.
     */
    create: XOR<paymentsCreateInput, paymentsUncheckedCreateInput>
    /**
     * In case the payments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<paymentsUpdateInput, paymentsUncheckedUpdateInput>
  }

  /**
   * payments delete
   */
  export type paymentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Filter which payments to delete.
     */
    where: paymentsWhereUniqueInput
  }

  /**
   * payments deleteMany
   */
  export type paymentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payments to delete
     */
    where?: paymentsWhereInput
    /**
     * Limit how many payments to delete.
     */
    limit?: number
  }

  /**
   * payments without action
   */
  export type paymentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
  }


  /**
   * Model privileges
   */

  export type AggregatePrivileges = {
    _count: PrivilegesCountAggregateOutputType | null
    _avg: PrivilegesAvgAggregateOutputType | null
    _sum: PrivilegesSumAggregateOutputType | null
    _min: PrivilegesMinAggregateOutputType | null
    _max: PrivilegesMaxAggregateOutputType | null
  }

  export type PrivilegesAvgAggregateOutputType = {
    sortOrder: number | null
    coinCost: number | null
  }

  export type PrivilegesSumAggregateOutputType = {
    sortOrder: number | null
    coinCost: number | null
  }

  export type PrivilegesMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    imageUrl: string | null
    actionUrl: string | null
    isActive: boolean | null
    sortOrder: number | null
    coinCost: number | null
    requiresLoan: boolean | null
    validFrom: Date | null
    validUntil: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PrivilegesMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    imageUrl: string | null
    actionUrl: string | null
    isActive: boolean | null
    sortOrder: number | null
    coinCost: number | null
    requiresLoan: boolean | null
    validFrom: Date | null
    validUntil: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PrivilegesCountAggregateOutputType = {
    id: number
    title: number
    description: number
    imageUrl: number
    actionUrl: number
    isActive: number
    sortOrder: number
    targetUserTypes: number
    coinCost: number
    requiresLoan: number
    validFrom: number
    validUntil: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PrivilegesAvgAggregateInputType = {
    sortOrder?: true
    coinCost?: true
  }

  export type PrivilegesSumAggregateInputType = {
    sortOrder?: true
    coinCost?: true
  }

  export type PrivilegesMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    imageUrl?: true
    actionUrl?: true
    isActive?: true
    sortOrder?: true
    coinCost?: true
    requiresLoan?: true
    validFrom?: true
    validUntil?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PrivilegesMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    imageUrl?: true
    actionUrl?: true
    isActive?: true
    sortOrder?: true
    coinCost?: true
    requiresLoan?: true
    validFrom?: true
    validUntil?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PrivilegesCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    imageUrl?: true
    actionUrl?: true
    isActive?: true
    sortOrder?: true
    targetUserTypes?: true
    coinCost?: true
    requiresLoan?: true
    validFrom?: true
    validUntil?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PrivilegesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which privileges to aggregate.
     */
    where?: privilegesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of privileges to fetch.
     */
    orderBy?: privilegesOrderByWithRelationInput | privilegesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: privilegesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` privileges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` privileges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned privileges
    **/
    _count?: true | PrivilegesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PrivilegesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PrivilegesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PrivilegesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PrivilegesMaxAggregateInputType
  }

  export type GetPrivilegesAggregateType<T extends PrivilegesAggregateArgs> = {
        [P in keyof T & keyof AggregatePrivileges]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrivileges[P]>
      : GetScalarType<T[P], AggregatePrivileges[P]>
  }




  export type privilegesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: privilegesWhereInput
    orderBy?: privilegesOrderByWithAggregationInput | privilegesOrderByWithAggregationInput[]
    by: PrivilegesScalarFieldEnum[] | PrivilegesScalarFieldEnum
    having?: privilegesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PrivilegesCountAggregateInputType | true
    _avg?: PrivilegesAvgAggregateInputType
    _sum?: PrivilegesSumAggregateInputType
    _min?: PrivilegesMinAggregateInputType
    _max?: PrivilegesMaxAggregateInputType
  }

  export type PrivilegesGroupByOutputType = {
    id: string
    title: string
    description: string
    imageUrl: string | null
    actionUrl: string | null
    isActive: boolean
    sortOrder: number
    targetUserTypes: JsonValue
    coinCost: number | null
    requiresLoan: boolean
    validFrom: Date | null
    validUntil: Date | null
    createdAt: Date
    updatedAt: Date
    _count: PrivilegesCountAggregateOutputType | null
    _avg: PrivilegesAvgAggregateOutputType | null
    _sum: PrivilegesSumAggregateOutputType | null
    _min: PrivilegesMinAggregateOutputType | null
    _max: PrivilegesMaxAggregateOutputType | null
  }

  type GetPrivilegesGroupByPayload<T extends privilegesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PrivilegesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PrivilegesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PrivilegesGroupByOutputType[P]>
            : GetScalarType<T[P], PrivilegesGroupByOutputType[P]>
        }
      >
    >


  export type privilegesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    imageUrl?: boolean
    actionUrl?: boolean
    isActive?: boolean
    sortOrder?: boolean
    targetUserTypes?: boolean
    coinCost?: boolean
    requiresLoan?: boolean
    validFrom?: boolean
    validUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["privileges"]>



  export type privilegesSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    imageUrl?: boolean
    actionUrl?: boolean
    isActive?: boolean
    sortOrder?: boolean
    targetUserTypes?: boolean
    coinCost?: boolean
    requiresLoan?: boolean
    validFrom?: boolean
    validUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type privilegesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "imageUrl" | "actionUrl" | "isActive" | "sortOrder" | "targetUserTypes" | "coinCost" | "requiresLoan" | "validFrom" | "validUntil" | "createdAt" | "updatedAt", ExtArgs["result"]["privileges"]>

  export type $privilegesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "privileges"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      imageUrl: string | null
      actionUrl: string | null
      isActive: boolean
      sortOrder: number
      targetUserTypes: Prisma.JsonValue
      coinCost: number | null
      requiresLoan: boolean
      validFrom: Date | null
      validUntil: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["privileges"]>
    composites: {}
  }

  type privilegesGetPayload<S extends boolean | null | undefined | privilegesDefaultArgs> = $Result.GetResult<Prisma.$privilegesPayload, S>

  type privilegesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<privilegesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PrivilegesCountAggregateInputType | true
    }

  export interface privilegesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['privileges'], meta: { name: 'privileges' } }
    /**
     * Find zero or one Privileges that matches the filter.
     * @param {privilegesFindUniqueArgs} args - Arguments to find a Privileges
     * @example
     * // Get one Privileges
     * const privileges = await prisma.privileges.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends privilegesFindUniqueArgs>(args: SelectSubset<T, privilegesFindUniqueArgs<ExtArgs>>): Prisma__privilegesClient<$Result.GetResult<Prisma.$privilegesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Privileges that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {privilegesFindUniqueOrThrowArgs} args - Arguments to find a Privileges
     * @example
     * // Get one Privileges
     * const privileges = await prisma.privileges.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends privilegesFindUniqueOrThrowArgs>(args: SelectSubset<T, privilegesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__privilegesClient<$Result.GetResult<Prisma.$privilegesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Privileges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {privilegesFindFirstArgs} args - Arguments to find a Privileges
     * @example
     * // Get one Privileges
     * const privileges = await prisma.privileges.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends privilegesFindFirstArgs>(args?: SelectSubset<T, privilegesFindFirstArgs<ExtArgs>>): Prisma__privilegesClient<$Result.GetResult<Prisma.$privilegesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Privileges that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {privilegesFindFirstOrThrowArgs} args - Arguments to find a Privileges
     * @example
     * // Get one Privileges
     * const privileges = await prisma.privileges.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends privilegesFindFirstOrThrowArgs>(args?: SelectSubset<T, privilegesFindFirstOrThrowArgs<ExtArgs>>): Prisma__privilegesClient<$Result.GetResult<Prisma.$privilegesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Privileges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {privilegesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Privileges
     * const privileges = await prisma.privileges.findMany()
     * 
     * // Get first 10 Privileges
     * const privileges = await prisma.privileges.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const privilegesWithIdOnly = await prisma.privileges.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends privilegesFindManyArgs>(args?: SelectSubset<T, privilegesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$privilegesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Privileges.
     * @param {privilegesCreateArgs} args - Arguments to create a Privileges.
     * @example
     * // Create one Privileges
     * const Privileges = await prisma.privileges.create({
     *   data: {
     *     // ... data to create a Privileges
     *   }
     * })
     * 
     */
    create<T extends privilegesCreateArgs>(args: SelectSubset<T, privilegesCreateArgs<ExtArgs>>): Prisma__privilegesClient<$Result.GetResult<Prisma.$privilegesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Privileges.
     * @param {privilegesCreateManyArgs} args - Arguments to create many Privileges.
     * @example
     * // Create many Privileges
     * const privileges = await prisma.privileges.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends privilegesCreateManyArgs>(args?: SelectSubset<T, privilegesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Privileges.
     * @param {privilegesDeleteArgs} args - Arguments to delete one Privileges.
     * @example
     * // Delete one Privileges
     * const Privileges = await prisma.privileges.delete({
     *   where: {
     *     // ... filter to delete one Privileges
     *   }
     * })
     * 
     */
    delete<T extends privilegesDeleteArgs>(args: SelectSubset<T, privilegesDeleteArgs<ExtArgs>>): Prisma__privilegesClient<$Result.GetResult<Prisma.$privilegesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Privileges.
     * @param {privilegesUpdateArgs} args - Arguments to update one Privileges.
     * @example
     * // Update one Privileges
     * const privileges = await prisma.privileges.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends privilegesUpdateArgs>(args: SelectSubset<T, privilegesUpdateArgs<ExtArgs>>): Prisma__privilegesClient<$Result.GetResult<Prisma.$privilegesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Privileges.
     * @param {privilegesDeleteManyArgs} args - Arguments to filter Privileges to delete.
     * @example
     * // Delete a few Privileges
     * const { count } = await prisma.privileges.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends privilegesDeleteManyArgs>(args?: SelectSubset<T, privilegesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Privileges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {privilegesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Privileges
     * const privileges = await prisma.privileges.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends privilegesUpdateManyArgs>(args: SelectSubset<T, privilegesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Privileges.
     * @param {privilegesUpsertArgs} args - Arguments to update or create a Privileges.
     * @example
     * // Update or create a Privileges
     * const privileges = await prisma.privileges.upsert({
     *   create: {
     *     // ... data to create a Privileges
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Privileges we want to update
     *   }
     * })
     */
    upsert<T extends privilegesUpsertArgs>(args: SelectSubset<T, privilegesUpsertArgs<ExtArgs>>): Prisma__privilegesClient<$Result.GetResult<Prisma.$privilegesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Privileges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {privilegesCountArgs} args - Arguments to filter Privileges to count.
     * @example
     * // Count the number of Privileges
     * const count = await prisma.privileges.count({
     *   where: {
     *     // ... the filter for the Privileges we want to count
     *   }
     * })
    **/
    count<T extends privilegesCountArgs>(
      args?: Subset<T, privilegesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PrivilegesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Privileges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivilegesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PrivilegesAggregateArgs>(args: Subset<T, PrivilegesAggregateArgs>): Prisma.PrismaPromise<GetPrivilegesAggregateType<T>>

    /**
     * Group by Privileges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {privilegesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends privilegesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: privilegesGroupByArgs['orderBy'] }
        : { orderBy?: privilegesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, privilegesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrivilegesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the privileges model
   */
  readonly fields: privilegesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for privileges.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__privilegesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the privileges model
   */
  interface privilegesFieldRefs {
    readonly id: FieldRef<"privileges", 'String'>
    readonly title: FieldRef<"privileges", 'String'>
    readonly description: FieldRef<"privileges", 'String'>
    readonly imageUrl: FieldRef<"privileges", 'String'>
    readonly actionUrl: FieldRef<"privileges", 'String'>
    readonly isActive: FieldRef<"privileges", 'Boolean'>
    readonly sortOrder: FieldRef<"privileges", 'Int'>
    readonly targetUserTypes: FieldRef<"privileges", 'Json'>
    readonly coinCost: FieldRef<"privileges", 'Int'>
    readonly requiresLoan: FieldRef<"privileges", 'Boolean'>
    readonly validFrom: FieldRef<"privileges", 'DateTime'>
    readonly validUntil: FieldRef<"privileges", 'DateTime'>
    readonly createdAt: FieldRef<"privileges", 'DateTime'>
    readonly updatedAt: FieldRef<"privileges", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * privileges findUnique
   */
  export type privilegesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the privileges
     */
    select?: privilegesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the privileges
     */
    omit?: privilegesOmit<ExtArgs> | null
    /**
     * Filter, which privileges to fetch.
     */
    where: privilegesWhereUniqueInput
  }

  /**
   * privileges findUniqueOrThrow
   */
  export type privilegesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the privileges
     */
    select?: privilegesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the privileges
     */
    omit?: privilegesOmit<ExtArgs> | null
    /**
     * Filter, which privileges to fetch.
     */
    where: privilegesWhereUniqueInput
  }

  /**
   * privileges findFirst
   */
  export type privilegesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the privileges
     */
    select?: privilegesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the privileges
     */
    omit?: privilegesOmit<ExtArgs> | null
    /**
     * Filter, which privileges to fetch.
     */
    where?: privilegesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of privileges to fetch.
     */
    orderBy?: privilegesOrderByWithRelationInput | privilegesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for privileges.
     */
    cursor?: privilegesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` privileges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` privileges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of privileges.
     */
    distinct?: PrivilegesScalarFieldEnum | PrivilegesScalarFieldEnum[]
  }

  /**
   * privileges findFirstOrThrow
   */
  export type privilegesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the privileges
     */
    select?: privilegesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the privileges
     */
    omit?: privilegesOmit<ExtArgs> | null
    /**
     * Filter, which privileges to fetch.
     */
    where?: privilegesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of privileges to fetch.
     */
    orderBy?: privilegesOrderByWithRelationInput | privilegesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for privileges.
     */
    cursor?: privilegesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` privileges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` privileges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of privileges.
     */
    distinct?: PrivilegesScalarFieldEnum | PrivilegesScalarFieldEnum[]
  }

  /**
   * privileges findMany
   */
  export type privilegesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the privileges
     */
    select?: privilegesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the privileges
     */
    omit?: privilegesOmit<ExtArgs> | null
    /**
     * Filter, which privileges to fetch.
     */
    where?: privilegesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of privileges to fetch.
     */
    orderBy?: privilegesOrderByWithRelationInput | privilegesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing privileges.
     */
    cursor?: privilegesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` privileges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` privileges.
     */
    skip?: number
    distinct?: PrivilegesScalarFieldEnum | PrivilegesScalarFieldEnum[]
  }

  /**
   * privileges create
   */
  export type privilegesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the privileges
     */
    select?: privilegesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the privileges
     */
    omit?: privilegesOmit<ExtArgs> | null
    /**
     * The data needed to create a privileges.
     */
    data: XOR<privilegesCreateInput, privilegesUncheckedCreateInput>
  }

  /**
   * privileges createMany
   */
  export type privilegesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many privileges.
     */
    data: privilegesCreateManyInput | privilegesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * privileges update
   */
  export type privilegesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the privileges
     */
    select?: privilegesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the privileges
     */
    omit?: privilegesOmit<ExtArgs> | null
    /**
     * The data needed to update a privileges.
     */
    data: XOR<privilegesUpdateInput, privilegesUncheckedUpdateInput>
    /**
     * Choose, which privileges to update.
     */
    where: privilegesWhereUniqueInput
  }

  /**
   * privileges updateMany
   */
  export type privilegesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update privileges.
     */
    data: XOR<privilegesUpdateManyMutationInput, privilegesUncheckedUpdateManyInput>
    /**
     * Filter which privileges to update
     */
    where?: privilegesWhereInput
    /**
     * Limit how many privileges to update.
     */
    limit?: number
  }

  /**
   * privileges upsert
   */
  export type privilegesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the privileges
     */
    select?: privilegesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the privileges
     */
    omit?: privilegesOmit<ExtArgs> | null
    /**
     * The filter to search for the privileges to update in case it exists.
     */
    where: privilegesWhereUniqueInput
    /**
     * In case the privileges found by the `where` argument doesn't exist, create a new privileges with this data.
     */
    create: XOR<privilegesCreateInput, privilegesUncheckedCreateInput>
    /**
     * In case the privileges was found with the provided `where` argument, update it with this data.
     */
    update: XOR<privilegesUpdateInput, privilegesUncheckedUpdateInput>
  }

  /**
   * privileges delete
   */
  export type privilegesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the privileges
     */
    select?: privilegesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the privileges
     */
    omit?: privilegesOmit<ExtArgs> | null
    /**
     * Filter which privileges to delete.
     */
    where: privilegesWhereUniqueInput
  }

  /**
   * privileges deleteMany
   */
  export type privilegesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which privileges to delete
     */
    where?: privilegesWhereInput
    /**
     * Limit how many privileges to delete.
     */
    limit?: number
  }

  /**
   * privileges without action
   */
  export type privilegesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the privileges
     */
    select?: privilegesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the privileges
     */
    omit?: privilegesOmit<ExtArgs> | null
  }


  /**
   * Model reward_redemptions
   */

  export type AggregateReward_redemptions = {
    _count: Reward_redemptionsCountAggregateOutputType | null
    _avg: Reward_redemptionsAvgAggregateOutputType | null
    _sum: Reward_redemptionsSumAggregateOutputType | null
    _min: Reward_redemptionsMinAggregateOutputType | null
    _max: Reward_redemptionsMaxAggregateOutputType | null
  }

  export type Reward_redemptionsAvgAggregateOutputType = {
    coinSpent: number | null
  }

  export type Reward_redemptionsSumAggregateOutputType = {
    coinSpent: number | null
  }

  export type Reward_redemptionsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    rewardId: string | null
    coinSpent: number | null
    status: $Enums.reward_redemptions_status | null
    deliveryAddress: string | null
    trackingNumber: string | null
    redeemedAt: Date | null
    deliveredAt: Date | null
  }

  export type Reward_redemptionsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    rewardId: string | null
    coinSpent: number | null
    status: $Enums.reward_redemptions_status | null
    deliveryAddress: string | null
    trackingNumber: string | null
    redeemedAt: Date | null
    deliveredAt: Date | null
  }

  export type Reward_redemptionsCountAggregateOutputType = {
    id: number
    userId: number
    rewardId: number
    coinSpent: number
    status: number
    deliveryAddress: number
    trackingNumber: number
    redeemedAt: number
    deliveredAt: number
    _all: number
  }


  export type Reward_redemptionsAvgAggregateInputType = {
    coinSpent?: true
  }

  export type Reward_redemptionsSumAggregateInputType = {
    coinSpent?: true
  }

  export type Reward_redemptionsMinAggregateInputType = {
    id?: true
    userId?: true
    rewardId?: true
    coinSpent?: true
    status?: true
    deliveryAddress?: true
    trackingNumber?: true
    redeemedAt?: true
    deliveredAt?: true
  }

  export type Reward_redemptionsMaxAggregateInputType = {
    id?: true
    userId?: true
    rewardId?: true
    coinSpent?: true
    status?: true
    deliveryAddress?: true
    trackingNumber?: true
    redeemedAt?: true
    deliveredAt?: true
  }

  export type Reward_redemptionsCountAggregateInputType = {
    id?: true
    userId?: true
    rewardId?: true
    coinSpent?: true
    status?: true
    deliveryAddress?: true
    trackingNumber?: true
    redeemedAt?: true
    deliveredAt?: true
    _all?: true
  }

  export type Reward_redemptionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which reward_redemptions to aggregate.
     */
    where?: reward_redemptionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reward_redemptions to fetch.
     */
    orderBy?: reward_redemptionsOrderByWithRelationInput | reward_redemptionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: reward_redemptionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reward_redemptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reward_redemptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned reward_redemptions
    **/
    _count?: true | Reward_redemptionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Reward_redemptionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Reward_redemptionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Reward_redemptionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Reward_redemptionsMaxAggregateInputType
  }

  export type GetReward_redemptionsAggregateType<T extends Reward_redemptionsAggregateArgs> = {
        [P in keyof T & keyof AggregateReward_redemptions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReward_redemptions[P]>
      : GetScalarType<T[P], AggregateReward_redemptions[P]>
  }




  export type reward_redemptionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: reward_redemptionsWhereInput
    orderBy?: reward_redemptionsOrderByWithAggregationInput | reward_redemptionsOrderByWithAggregationInput[]
    by: Reward_redemptionsScalarFieldEnum[] | Reward_redemptionsScalarFieldEnum
    having?: reward_redemptionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Reward_redemptionsCountAggregateInputType | true
    _avg?: Reward_redemptionsAvgAggregateInputType
    _sum?: Reward_redemptionsSumAggregateInputType
    _min?: Reward_redemptionsMinAggregateInputType
    _max?: Reward_redemptionsMaxAggregateInputType
  }

  export type Reward_redemptionsGroupByOutputType = {
    id: string
    userId: string
    rewardId: string
    coinSpent: number
    status: $Enums.reward_redemptions_status
    deliveryAddress: string | null
    trackingNumber: string | null
    redeemedAt: Date
    deliveredAt: Date | null
    _count: Reward_redemptionsCountAggregateOutputType | null
    _avg: Reward_redemptionsAvgAggregateOutputType | null
    _sum: Reward_redemptionsSumAggregateOutputType | null
    _min: Reward_redemptionsMinAggregateOutputType | null
    _max: Reward_redemptionsMaxAggregateOutputType | null
  }

  type GetReward_redemptionsGroupByPayload<T extends reward_redemptionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Reward_redemptionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Reward_redemptionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Reward_redemptionsGroupByOutputType[P]>
            : GetScalarType<T[P], Reward_redemptionsGroupByOutputType[P]>
        }
      >
    >


  export type reward_redemptionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    rewardId?: boolean
    coinSpent?: boolean
    status?: boolean
    deliveryAddress?: boolean
    trackingNumber?: boolean
    redeemedAt?: boolean
    deliveredAt?: boolean
  }, ExtArgs["result"]["reward_redemptions"]>



  export type reward_redemptionsSelectScalar = {
    id?: boolean
    userId?: boolean
    rewardId?: boolean
    coinSpent?: boolean
    status?: boolean
    deliveryAddress?: boolean
    trackingNumber?: boolean
    redeemedAt?: boolean
    deliveredAt?: boolean
  }

  export type reward_redemptionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "rewardId" | "coinSpent" | "status" | "deliveryAddress" | "trackingNumber" | "redeemedAt" | "deliveredAt", ExtArgs["result"]["reward_redemptions"]>

  export type $reward_redemptionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "reward_redemptions"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      rewardId: string
      coinSpent: number
      status: $Enums.reward_redemptions_status
      deliveryAddress: string | null
      trackingNumber: string | null
      redeemedAt: Date
      deliveredAt: Date | null
    }, ExtArgs["result"]["reward_redemptions"]>
    composites: {}
  }

  type reward_redemptionsGetPayload<S extends boolean | null | undefined | reward_redemptionsDefaultArgs> = $Result.GetResult<Prisma.$reward_redemptionsPayload, S>

  type reward_redemptionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<reward_redemptionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Reward_redemptionsCountAggregateInputType | true
    }

  export interface reward_redemptionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['reward_redemptions'], meta: { name: 'reward_redemptions' } }
    /**
     * Find zero or one Reward_redemptions that matches the filter.
     * @param {reward_redemptionsFindUniqueArgs} args - Arguments to find a Reward_redemptions
     * @example
     * // Get one Reward_redemptions
     * const reward_redemptions = await prisma.reward_redemptions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends reward_redemptionsFindUniqueArgs>(args: SelectSubset<T, reward_redemptionsFindUniqueArgs<ExtArgs>>): Prisma__reward_redemptionsClient<$Result.GetResult<Prisma.$reward_redemptionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Reward_redemptions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {reward_redemptionsFindUniqueOrThrowArgs} args - Arguments to find a Reward_redemptions
     * @example
     * // Get one Reward_redemptions
     * const reward_redemptions = await prisma.reward_redemptions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends reward_redemptionsFindUniqueOrThrowArgs>(args: SelectSubset<T, reward_redemptionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__reward_redemptionsClient<$Result.GetResult<Prisma.$reward_redemptionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reward_redemptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reward_redemptionsFindFirstArgs} args - Arguments to find a Reward_redemptions
     * @example
     * // Get one Reward_redemptions
     * const reward_redemptions = await prisma.reward_redemptions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends reward_redemptionsFindFirstArgs>(args?: SelectSubset<T, reward_redemptionsFindFirstArgs<ExtArgs>>): Prisma__reward_redemptionsClient<$Result.GetResult<Prisma.$reward_redemptionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reward_redemptions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reward_redemptionsFindFirstOrThrowArgs} args - Arguments to find a Reward_redemptions
     * @example
     * // Get one Reward_redemptions
     * const reward_redemptions = await prisma.reward_redemptions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends reward_redemptionsFindFirstOrThrowArgs>(args?: SelectSubset<T, reward_redemptionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__reward_redemptionsClient<$Result.GetResult<Prisma.$reward_redemptionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reward_redemptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reward_redemptionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reward_redemptions
     * const reward_redemptions = await prisma.reward_redemptions.findMany()
     * 
     * // Get first 10 Reward_redemptions
     * const reward_redemptions = await prisma.reward_redemptions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reward_redemptionsWithIdOnly = await prisma.reward_redemptions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends reward_redemptionsFindManyArgs>(args?: SelectSubset<T, reward_redemptionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reward_redemptionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Reward_redemptions.
     * @param {reward_redemptionsCreateArgs} args - Arguments to create a Reward_redemptions.
     * @example
     * // Create one Reward_redemptions
     * const Reward_redemptions = await prisma.reward_redemptions.create({
     *   data: {
     *     // ... data to create a Reward_redemptions
     *   }
     * })
     * 
     */
    create<T extends reward_redemptionsCreateArgs>(args: SelectSubset<T, reward_redemptionsCreateArgs<ExtArgs>>): Prisma__reward_redemptionsClient<$Result.GetResult<Prisma.$reward_redemptionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reward_redemptions.
     * @param {reward_redemptionsCreateManyArgs} args - Arguments to create many Reward_redemptions.
     * @example
     * // Create many Reward_redemptions
     * const reward_redemptions = await prisma.reward_redemptions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends reward_redemptionsCreateManyArgs>(args?: SelectSubset<T, reward_redemptionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Reward_redemptions.
     * @param {reward_redemptionsDeleteArgs} args - Arguments to delete one Reward_redemptions.
     * @example
     * // Delete one Reward_redemptions
     * const Reward_redemptions = await prisma.reward_redemptions.delete({
     *   where: {
     *     // ... filter to delete one Reward_redemptions
     *   }
     * })
     * 
     */
    delete<T extends reward_redemptionsDeleteArgs>(args: SelectSubset<T, reward_redemptionsDeleteArgs<ExtArgs>>): Prisma__reward_redemptionsClient<$Result.GetResult<Prisma.$reward_redemptionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Reward_redemptions.
     * @param {reward_redemptionsUpdateArgs} args - Arguments to update one Reward_redemptions.
     * @example
     * // Update one Reward_redemptions
     * const reward_redemptions = await prisma.reward_redemptions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends reward_redemptionsUpdateArgs>(args: SelectSubset<T, reward_redemptionsUpdateArgs<ExtArgs>>): Prisma__reward_redemptionsClient<$Result.GetResult<Prisma.$reward_redemptionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reward_redemptions.
     * @param {reward_redemptionsDeleteManyArgs} args - Arguments to filter Reward_redemptions to delete.
     * @example
     * // Delete a few Reward_redemptions
     * const { count } = await prisma.reward_redemptions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends reward_redemptionsDeleteManyArgs>(args?: SelectSubset<T, reward_redemptionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reward_redemptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reward_redemptionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reward_redemptions
     * const reward_redemptions = await prisma.reward_redemptions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends reward_redemptionsUpdateManyArgs>(args: SelectSubset<T, reward_redemptionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Reward_redemptions.
     * @param {reward_redemptionsUpsertArgs} args - Arguments to update or create a Reward_redemptions.
     * @example
     * // Update or create a Reward_redemptions
     * const reward_redemptions = await prisma.reward_redemptions.upsert({
     *   create: {
     *     // ... data to create a Reward_redemptions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reward_redemptions we want to update
     *   }
     * })
     */
    upsert<T extends reward_redemptionsUpsertArgs>(args: SelectSubset<T, reward_redemptionsUpsertArgs<ExtArgs>>): Prisma__reward_redemptionsClient<$Result.GetResult<Prisma.$reward_redemptionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reward_redemptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reward_redemptionsCountArgs} args - Arguments to filter Reward_redemptions to count.
     * @example
     * // Count the number of Reward_redemptions
     * const count = await prisma.reward_redemptions.count({
     *   where: {
     *     // ... the filter for the Reward_redemptions we want to count
     *   }
     * })
    **/
    count<T extends reward_redemptionsCountArgs>(
      args?: Subset<T, reward_redemptionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Reward_redemptionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reward_redemptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Reward_redemptionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Reward_redemptionsAggregateArgs>(args: Subset<T, Reward_redemptionsAggregateArgs>): Prisma.PrismaPromise<GetReward_redemptionsAggregateType<T>>

    /**
     * Group by Reward_redemptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reward_redemptionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends reward_redemptionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: reward_redemptionsGroupByArgs['orderBy'] }
        : { orderBy?: reward_redemptionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, reward_redemptionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReward_redemptionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the reward_redemptions model
   */
  readonly fields: reward_redemptionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for reward_redemptions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__reward_redemptionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the reward_redemptions model
   */
  interface reward_redemptionsFieldRefs {
    readonly id: FieldRef<"reward_redemptions", 'String'>
    readonly userId: FieldRef<"reward_redemptions", 'String'>
    readonly rewardId: FieldRef<"reward_redemptions", 'String'>
    readonly coinSpent: FieldRef<"reward_redemptions", 'Int'>
    readonly status: FieldRef<"reward_redemptions", 'reward_redemptions_status'>
    readonly deliveryAddress: FieldRef<"reward_redemptions", 'String'>
    readonly trackingNumber: FieldRef<"reward_redemptions", 'String'>
    readonly redeemedAt: FieldRef<"reward_redemptions", 'DateTime'>
    readonly deliveredAt: FieldRef<"reward_redemptions", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * reward_redemptions findUnique
   */
  export type reward_redemptionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reward_redemptions
     */
    select?: reward_redemptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reward_redemptions
     */
    omit?: reward_redemptionsOmit<ExtArgs> | null
    /**
     * Filter, which reward_redemptions to fetch.
     */
    where: reward_redemptionsWhereUniqueInput
  }

  /**
   * reward_redemptions findUniqueOrThrow
   */
  export type reward_redemptionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reward_redemptions
     */
    select?: reward_redemptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reward_redemptions
     */
    omit?: reward_redemptionsOmit<ExtArgs> | null
    /**
     * Filter, which reward_redemptions to fetch.
     */
    where: reward_redemptionsWhereUniqueInput
  }

  /**
   * reward_redemptions findFirst
   */
  export type reward_redemptionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reward_redemptions
     */
    select?: reward_redemptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reward_redemptions
     */
    omit?: reward_redemptionsOmit<ExtArgs> | null
    /**
     * Filter, which reward_redemptions to fetch.
     */
    where?: reward_redemptionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reward_redemptions to fetch.
     */
    orderBy?: reward_redemptionsOrderByWithRelationInput | reward_redemptionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reward_redemptions.
     */
    cursor?: reward_redemptionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reward_redemptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reward_redemptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reward_redemptions.
     */
    distinct?: Reward_redemptionsScalarFieldEnum | Reward_redemptionsScalarFieldEnum[]
  }

  /**
   * reward_redemptions findFirstOrThrow
   */
  export type reward_redemptionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reward_redemptions
     */
    select?: reward_redemptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reward_redemptions
     */
    omit?: reward_redemptionsOmit<ExtArgs> | null
    /**
     * Filter, which reward_redemptions to fetch.
     */
    where?: reward_redemptionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reward_redemptions to fetch.
     */
    orderBy?: reward_redemptionsOrderByWithRelationInput | reward_redemptionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reward_redemptions.
     */
    cursor?: reward_redemptionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reward_redemptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reward_redemptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reward_redemptions.
     */
    distinct?: Reward_redemptionsScalarFieldEnum | Reward_redemptionsScalarFieldEnum[]
  }

  /**
   * reward_redemptions findMany
   */
  export type reward_redemptionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reward_redemptions
     */
    select?: reward_redemptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reward_redemptions
     */
    omit?: reward_redemptionsOmit<ExtArgs> | null
    /**
     * Filter, which reward_redemptions to fetch.
     */
    where?: reward_redemptionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reward_redemptions to fetch.
     */
    orderBy?: reward_redemptionsOrderByWithRelationInput | reward_redemptionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing reward_redemptions.
     */
    cursor?: reward_redemptionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reward_redemptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reward_redemptions.
     */
    skip?: number
    distinct?: Reward_redemptionsScalarFieldEnum | Reward_redemptionsScalarFieldEnum[]
  }

  /**
   * reward_redemptions create
   */
  export type reward_redemptionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reward_redemptions
     */
    select?: reward_redemptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reward_redemptions
     */
    omit?: reward_redemptionsOmit<ExtArgs> | null
    /**
     * The data needed to create a reward_redemptions.
     */
    data: XOR<reward_redemptionsCreateInput, reward_redemptionsUncheckedCreateInput>
  }

  /**
   * reward_redemptions createMany
   */
  export type reward_redemptionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many reward_redemptions.
     */
    data: reward_redemptionsCreateManyInput | reward_redemptionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * reward_redemptions update
   */
  export type reward_redemptionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reward_redemptions
     */
    select?: reward_redemptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reward_redemptions
     */
    omit?: reward_redemptionsOmit<ExtArgs> | null
    /**
     * The data needed to update a reward_redemptions.
     */
    data: XOR<reward_redemptionsUpdateInput, reward_redemptionsUncheckedUpdateInput>
    /**
     * Choose, which reward_redemptions to update.
     */
    where: reward_redemptionsWhereUniqueInput
  }

  /**
   * reward_redemptions updateMany
   */
  export type reward_redemptionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update reward_redemptions.
     */
    data: XOR<reward_redemptionsUpdateManyMutationInput, reward_redemptionsUncheckedUpdateManyInput>
    /**
     * Filter which reward_redemptions to update
     */
    where?: reward_redemptionsWhereInput
    /**
     * Limit how many reward_redemptions to update.
     */
    limit?: number
  }

  /**
   * reward_redemptions upsert
   */
  export type reward_redemptionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reward_redemptions
     */
    select?: reward_redemptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reward_redemptions
     */
    omit?: reward_redemptionsOmit<ExtArgs> | null
    /**
     * The filter to search for the reward_redemptions to update in case it exists.
     */
    where: reward_redemptionsWhereUniqueInput
    /**
     * In case the reward_redemptions found by the `where` argument doesn't exist, create a new reward_redemptions with this data.
     */
    create: XOR<reward_redemptionsCreateInput, reward_redemptionsUncheckedCreateInput>
    /**
     * In case the reward_redemptions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<reward_redemptionsUpdateInput, reward_redemptionsUncheckedUpdateInput>
  }

  /**
   * reward_redemptions delete
   */
  export type reward_redemptionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reward_redemptions
     */
    select?: reward_redemptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reward_redemptions
     */
    omit?: reward_redemptionsOmit<ExtArgs> | null
    /**
     * Filter which reward_redemptions to delete.
     */
    where: reward_redemptionsWhereUniqueInput
  }

  /**
   * reward_redemptions deleteMany
   */
  export type reward_redemptionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which reward_redemptions to delete
     */
    where?: reward_redemptionsWhereInput
    /**
     * Limit how many reward_redemptions to delete.
     */
    limit?: number
  }

  /**
   * reward_redemptions without action
   */
  export type reward_redemptionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reward_redemptions
     */
    select?: reward_redemptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reward_redemptions
     */
    omit?: reward_redemptionsOmit<ExtArgs> | null
  }


  /**
   * Model rewards
   */

  export type AggregateRewards = {
    _count: RewardsCountAggregateOutputType | null
    _avg: RewardsAvgAggregateOutputType | null
    _sum: RewardsSumAggregateOutputType | null
    _min: RewardsMinAggregateOutputType | null
    _max: RewardsMaxAggregateOutputType | null
  }

  export type RewardsAvgAggregateOutputType = {
    coinCost: number | null
    stockCount: number | null
  }

  export type RewardsSumAggregateOutputType = {
    coinCost: number | null
    stockCount: number | null
  }

  export type RewardsMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    coinCost: number | null
    imageUrl: string | null
    isActive: boolean | null
    stockCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RewardsMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    coinCost: number | null
    imageUrl: string | null
    isActive: boolean | null
    stockCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RewardsCountAggregateOutputType = {
    id: number
    name: number
    description: number
    coinCost: number
    imageUrl: number
    isActive: number
    stockCount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RewardsAvgAggregateInputType = {
    coinCost?: true
    stockCount?: true
  }

  export type RewardsSumAggregateInputType = {
    coinCost?: true
    stockCount?: true
  }

  export type RewardsMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    coinCost?: true
    imageUrl?: true
    isActive?: true
    stockCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RewardsMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    coinCost?: true
    imageUrl?: true
    isActive?: true
    stockCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RewardsCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    coinCost?: true
    imageUrl?: true
    isActive?: true
    stockCount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RewardsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which rewards to aggregate.
     */
    where?: rewardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rewards to fetch.
     */
    orderBy?: rewardsOrderByWithRelationInput | rewardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: rewardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned rewards
    **/
    _count?: true | RewardsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RewardsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RewardsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RewardsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RewardsMaxAggregateInputType
  }

  export type GetRewardsAggregateType<T extends RewardsAggregateArgs> = {
        [P in keyof T & keyof AggregateRewards]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRewards[P]>
      : GetScalarType<T[P], AggregateRewards[P]>
  }




  export type rewardsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rewardsWhereInput
    orderBy?: rewardsOrderByWithAggregationInput | rewardsOrderByWithAggregationInput[]
    by: RewardsScalarFieldEnum[] | RewardsScalarFieldEnum
    having?: rewardsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RewardsCountAggregateInputType | true
    _avg?: RewardsAvgAggregateInputType
    _sum?: RewardsSumAggregateInputType
    _min?: RewardsMinAggregateInputType
    _max?: RewardsMaxAggregateInputType
  }

  export type RewardsGroupByOutputType = {
    id: string
    name: string
    description: string
    coinCost: number
    imageUrl: string | null
    isActive: boolean
    stockCount: number | null
    createdAt: Date
    updatedAt: Date
    _count: RewardsCountAggregateOutputType | null
    _avg: RewardsAvgAggregateOutputType | null
    _sum: RewardsSumAggregateOutputType | null
    _min: RewardsMinAggregateOutputType | null
    _max: RewardsMaxAggregateOutputType | null
  }

  type GetRewardsGroupByPayload<T extends rewardsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RewardsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RewardsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RewardsGroupByOutputType[P]>
            : GetScalarType<T[P], RewardsGroupByOutputType[P]>
        }
      >
    >


  export type rewardsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    coinCost?: boolean
    imageUrl?: boolean
    isActive?: boolean
    stockCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["rewards"]>



  export type rewardsSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    coinCost?: boolean
    imageUrl?: boolean
    isActive?: boolean
    stockCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type rewardsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "coinCost" | "imageUrl" | "isActive" | "stockCount" | "createdAt" | "updatedAt", ExtArgs["result"]["rewards"]>

  export type $rewardsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "rewards"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      coinCost: number
      imageUrl: string | null
      isActive: boolean
      stockCount: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["rewards"]>
    composites: {}
  }

  type rewardsGetPayload<S extends boolean | null | undefined | rewardsDefaultArgs> = $Result.GetResult<Prisma.$rewardsPayload, S>

  type rewardsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<rewardsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RewardsCountAggregateInputType | true
    }

  export interface rewardsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['rewards'], meta: { name: 'rewards' } }
    /**
     * Find zero or one Rewards that matches the filter.
     * @param {rewardsFindUniqueArgs} args - Arguments to find a Rewards
     * @example
     * // Get one Rewards
     * const rewards = await prisma.rewards.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends rewardsFindUniqueArgs>(args: SelectSubset<T, rewardsFindUniqueArgs<ExtArgs>>): Prisma__rewardsClient<$Result.GetResult<Prisma.$rewardsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Rewards that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {rewardsFindUniqueOrThrowArgs} args - Arguments to find a Rewards
     * @example
     * // Get one Rewards
     * const rewards = await prisma.rewards.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends rewardsFindUniqueOrThrowArgs>(args: SelectSubset<T, rewardsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__rewardsClient<$Result.GetResult<Prisma.$rewardsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Rewards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rewardsFindFirstArgs} args - Arguments to find a Rewards
     * @example
     * // Get one Rewards
     * const rewards = await prisma.rewards.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends rewardsFindFirstArgs>(args?: SelectSubset<T, rewardsFindFirstArgs<ExtArgs>>): Prisma__rewardsClient<$Result.GetResult<Prisma.$rewardsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Rewards that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rewardsFindFirstOrThrowArgs} args - Arguments to find a Rewards
     * @example
     * // Get one Rewards
     * const rewards = await prisma.rewards.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends rewardsFindFirstOrThrowArgs>(args?: SelectSubset<T, rewardsFindFirstOrThrowArgs<ExtArgs>>): Prisma__rewardsClient<$Result.GetResult<Prisma.$rewardsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Rewards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rewardsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rewards
     * const rewards = await prisma.rewards.findMany()
     * 
     * // Get first 10 Rewards
     * const rewards = await prisma.rewards.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rewardsWithIdOnly = await prisma.rewards.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends rewardsFindManyArgs>(args?: SelectSubset<T, rewardsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rewardsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Rewards.
     * @param {rewardsCreateArgs} args - Arguments to create a Rewards.
     * @example
     * // Create one Rewards
     * const Rewards = await prisma.rewards.create({
     *   data: {
     *     // ... data to create a Rewards
     *   }
     * })
     * 
     */
    create<T extends rewardsCreateArgs>(args: SelectSubset<T, rewardsCreateArgs<ExtArgs>>): Prisma__rewardsClient<$Result.GetResult<Prisma.$rewardsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Rewards.
     * @param {rewardsCreateManyArgs} args - Arguments to create many Rewards.
     * @example
     * // Create many Rewards
     * const rewards = await prisma.rewards.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends rewardsCreateManyArgs>(args?: SelectSubset<T, rewardsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Rewards.
     * @param {rewardsDeleteArgs} args - Arguments to delete one Rewards.
     * @example
     * // Delete one Rewards
     * const Rewards = await prisma.rewards.delete({
     *   where: {
     *     // ... filter to delete one Rewards
     *   }
     * })
     * 
     */
    delete<T extends rewardsDeleteArgs>(args: SelectSubset<T, rewardsDeleteArgs<ExtArgs>>): Prisma__rewardsClient<$Result.GetResult<Prisma.$rewardsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Rewards.
     * @param {rewardsUpdateArgs} args - Arguments to update one Rewards.
     * @example
     * // Update one Rewards
     * const rewards = await prisma.rewards.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends rewardsUpdateArgs>(args: SelectSubset<T, rewardsUpdateArgs<ExtArgs>>): Prisma__rewardsClient<$Result.GetResult<Prisma.$rewardsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Rewards.
     * @param {rewardsDeleteManyArgs} args - Arguments to filter Rewards to delete.
     * @example
     * // Delete a few Rewards
     * const { count } = await prisma.rewards.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends rewardsDeleteManyArgs>(args?: SelectSubset<T, rewardsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rewardsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rewards
     * const rewards = await prisma.rewards.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends rewardsUpdateManyArgs>(args: SelectSubset<T, rewardsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Rewards.
     * @param {rewardsUpsertArgs} args - Arguments to update or create a Rewards.
     * @example
     * // Update or create a Rewards
     * const rewards = await prisma.rewards.upsert({
     *   create: {
     *     // ... data to create a Rewards
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Rewards we want to update
     *   }
     * })
     */
    upsert<T extends rewardsUpsertArgs>(args: SelectSubset<T, rewardsUpsertArgs<ExtArgs>>): Prisma__rewardsClient<$Result.GetResult<Prisma.$rewardsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Rewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rewardsCountArgs} args - Arguments to filter Rewards to count.
     * @example
     * // Count the number of Rewards
     * const count = await prisma.rewards.count({
     *   where: {
     *     // ... the filter for the Rewards we want to count
     *   }
     * })
    **/
    count<T extends rewardsCountArgs>(
      args?: Subset<T, rewardsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RewardsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Rewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RewardsAggregateArgs>(args: Subset<T, RewardsAggregateArgs>): Prisma.PrismaPromise<GetRewardsAggregateType<T>>

    /**
     * Group by Rewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rewardsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends rewardsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: rewardsGroupByArgs['orderBy'] }
        : { orderBy?: rewardsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, rewardsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRewardsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the rewards model
   */
  readonly fields: rewardsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for rewards.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__rewardsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the rewards model
   */
  interface rewardsFieldRefs {
    readonly id: FieldRef<"rewards", 'String'>
    readonly name: FieldRef<"rewards", 'String'>
    readonly description: FieldRef<"rewards", 'String'>
    readonly coinCost: FieldRef<"rewards", 'Int'>
    readonly imageUrl: FieldRef<"rewards", 'String'>
    readonly isActive: FieldRef<"rewards", 'Boolean'>
    readonly stockCount: FieldRef<"rewards", 'Int'>
    readonly createdAt: FieldRef<"rewards", 'DateTime'>
    readonly updatedAt: FieldRef<"rewards", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * rewards findUnique
   */
  export type rewardsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rewards
     */
    select?: rewardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rewards
     */
    omit?: rewardsOmit<ExtArgs> | null
    /**
     * Filter, which rewards to fetch.
     */
    where: rewardsWhereUniqueInput
  }

  /**
   * rewards findUniqueOrThrow
   */
  export type rewardsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rewards
     */
    select?: rewardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rewards
     */
    omit?: rewardsOmit<ExtArgs> | null
    /**
     * Filter, which rewards to fetch.
     */
    where: rewardsWhereUniqueInput
  }

  /**
   * rewards findFirst
   */
  export type rewardsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rewards
     */
    select?: rewardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rewards
     */
    omit?: rewardsOmit<ExtArgs> | null
    /**
     * Filter, which rewards to fetch.
     */
    where?: rewardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rewards to fetch.
     */
    orderBy?: rewardsOrderByWithRelationInput | rewardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rewards.
     */
    cursor?: rewardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rewards.
     */
    distinct?: RewardsScalarFieldEnum | RewardsScalarFieldEnum[]
  }

  /**
   * rewards findFirstOrThrow
   */
  export type rewardsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rewards
     */
    select?: rewardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rewards
     */
    omit?: rewardsOmit<ExtArgs> | null
    /**
     * Filter, which rewards to fetch.
     */
    where?: rewardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rewards to fetch.
     */
    orderBy?: rewardsOrderByWithRelationInput | rewardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rewards.
     */
    cursor?: rewardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rewards.
     */
    distinct?: RewardsScalarFieldEnum | RewardsScalarFieldEnum[]
  }

  /**
   * rewards findMany
   */
  export type rewardsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rewards
     */
    select?: rewardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rewards
     */
    omit?: rewardsOmit<ExtArgs> | null
    /**
     * Filter, which rewards to fetch.
     */
    where?: rewardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rewards to fetch.
     */
    orderBy?: rewardsOrderByWithRelationInput | rewardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing rewards.
     */
    cursor?: rewardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rewards.
     */
    skip?: number
    distinct?: RewardsScalarFieldEnum | RewardsScalarFieldEnum[]
  }

  /**
   * rewards create
   */
  export type rewardsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rewards
     */
    select?: rewardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rewards
     */
    omit?: rewardsOmit<ExtArgs> | null
    /**
     * The data needed to create a rewards.
     */
    data: XOR<rewardsCreateInput, rewardsUncheckedCreateInput>
  }

  /**
   * rewards createMany
   */
  export type rewardsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many rewards.
     */
    data: rewardsCreateManyInput | rewardsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * rewards update
   */
  export type rewardsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rewards
     */
    select?: rewardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rewards
     */
    omit?: rewardsOmit<ExtArgs> | null
    /**
     * The data needed to update a rewards.
     */
    data: XOR<rewardsUpdateInput, rewardsUncheckedUpdateInput>
    /**
     * Choose, which rewards to update.
     */
    where: rewardsWhereUniqueInput
  }

  /**
   * rewards updateMany
   */
  export type rewardsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update rewards.
     */
    data: XOR<rewardsUpdateManyMutationInput, rewardsUncheckedUpdateManyInput>
    /**
     * Filter which rewards to update
     */
    where?: rewardsWhereInput
    /**
     * Limit how many rewards to update.
     */
    limit?: number
  }

  /**
   * rewards upsert
   */
  export type rewardsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rewards
     */
    select?: rewardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rewards
     */
    omit?: rewardsOmit<ExtArgs> | null
    /**
     * The filter to search for the rewards to update in case it exists.
     */
    where: rewardsWhereUniqueInput
    /**
     * In case the rewards found by the `where` argument doesn't exist, create a new rewards with this data.
     */
    create: XOR<rewardsCreateInput, rewardsUncheckedCreateInput>
    /**
     * In case the rewards was found with the provided `where` argument, update it with this data.
     */
    update: XOR<rewardsUpdateInput, rewardsUncheckedUpdateInput>
  }

  /**
   * rewards delete
   */
  export type rewardsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rewards
     */
    select?: rewardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rewards
     */
    omit?: rewardsOmit<ExtArgs> | null
    /**
     * Filter which rewards to delete.
     */
    where: rewardsWhereUniqueInput
  }

  /**
   * rewards deleteMany
   */
  export type rewardsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which rewards to delete
     */
    where?: rewardsWhereInput
    /**
     * Limit how many rewards to delete.
     */
    limit?: number
  }

  /**
   * rewards without action
   */
  export type rewardsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rewards
     */
    select?: rewardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rewards
     */
    omit?: rewardsOmit<ExtArgs> | null
  }


  /**
   * Model sessions
   */

  export type AggregateSessions = {
    _count: SessionsCountAggregateOutputType | null
    _min: SessionsMinAggregateOutputType | null
    _max: SessionsMaxAggregateOutputType | null
  }

  export type SessionsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    deviceInfo: string | null
    ipAddress: string | null
    userAgent: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type SessionsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    deviceInfo: string | null
    ipAddress: string | null
    userAgent: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type SessionsCountAggregateOutputType = {
    id: number
    userId: number
    token: number
    deviceInfo: number
    ipAddress: number
    userAgent: number
    expiresAt: number
    createdAt: number
    _all: number
  }


  export type SessionsMinAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    deviceInfo?: true
    ipAddress?: true
    userAgent?: true
    expiresAt?: true
    createdAt?: true
  }

  export type SessionsMaxAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    deviceInfo?: true
    ipAddress?: true
    userAgent?: true
    expiresAt?: true
    createdAt?: true
  }

  export type SessionsCountAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    deviceInfo?: true
    ipAddress?: true
    userAgent?: true
    expiresAt?: true
    createdAt?: true
    _all?: true
  }

  export type SessionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sessions to aggregate.
     */
    where?: sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionsOrderByWithRelationInput | sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sessions
    **/
    _count?: true | SessionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionsMaxAggregateInputType
  }

  export type GetSessionsAggregateType<T extends SessionsAggregateArgs> = {
        [P in keyof T & keyof AggregateSessions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSessions[P]>
      : GetScalarType<T[P], AggregateSessions[P]>
  }




  export type sessionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sessionsWhereInput
    orderBy?: sessionsOrderByWithAggregationInput | sessionsOrderByWithAggregationInput[]
    by: SessionsScalarFieldEnum[] | SessionsScalarFieldEnum
    having?: sessionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionsCountAggregateInputType | true
    _min?: SessionsMinAggregateInputType
    _max?: SessionsMaxAggregateInputType
  }

  export type SessionsGroupByOutputType = {
    id: string
    userId: string
    token: string
    deviceInfo: string | null
    ipAddress: string | null
    userAgent: string | null
    expiresAt: Date
    createdAt: Date
    _count: SessionsCountAggregateOutputType | null
    _min: SessionsMinAggregateOutputType | null
    _max: SessionsMaxAggregateOutputType | null
  }

  type GetSessionsGroupByPayload<T extends sessionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionsGroupByOutputType[P]>
            : GetScalarType<T[P], SessionsGroupByOutputType[P]>
        }
      >
    >


  export type sessionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    deviceInfo?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["sessions"]>



  export type sessionsSelectScalar = {
    id?: boolean
    userId?: boolean
    token?: boolean
    deviceInfo?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }

  export type sessionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "token" | "deviceInfo" | "ipAddress" | "userAgent" | "expiresAt" | "createdAt", ExtArgs["result"]["sessions"]>

  export type $sessionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "sessions"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      token: string
      deviceInfo: string | null
      ipAddress: string | null
      userAgent: string | null
      expiresAt: Date
      createdAt: Date
    }, ExtArgs["result"]["sessions"]>
    composites: {}
  }

  type sessionsGetPayload<S extends boolean | null | undefined | sessionsDefaultArgs> = $Result.GetResult<Prisma.$sessionsPayload, S>

  type sessionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<sessionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionsCountAggregateInputType | true
    }

  export interface sessionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['sessions'], meta: { name: 'sessions' } }
    /**
     * Find zero or one Sessions that matches the filter.
     * @param {sessionsFindUniqueArgs} args - Arguments to find a Sessions
     * @example
     * // Get one Sessions
     * const sessions = await prisma.sessions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends sessionsFindUniqueArgs>(args: SelectSubset<T, sessionsFindUniqueArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Sessions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {sessionsFindUniqueOrThrowArgs} args - Arguments to find a Sessions
     * @example
     * // Get one Sessions
     * const sessions = await prisma.sessions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends sessionsFindUniqueOrThrowArgs>(args: SelectSubset<T, sessionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsFindFirstArgs} args - Arguments to find a Sessions
     * @example
     * // Get one Sessions
     * const sessions = await prisma.sessions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends sessionsFindFirstArgs>(args?: SelectSubset<T, sessionsFindFirstArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sessions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsFindFirstOrThrowArgs} args - Arguments to find a Sessions
     * @example
     * // Get one Sessions
     * const sessions = await prisma.sessions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends sessionsFindFirstOrThrowArgs>(args?: SelectSubset<T, sessionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.sessions.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.sessions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionsWithIdOnly = await prisma.sessions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends sessionsFindManyArgs>(args?: SelectSubset<T, sessionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Sessions.
     * @param {sessionsCreateArgs} args - Arguments to create a Sessions.
     * @example
     * // Create one Sessions
     * const Sessions = await prisma.sessions.create({
     *   data: {
     *     // ... data to create a Sessions
     *   }
     * })
     * 
     */
    create<T extends sessionsCreateArgs>(args: SelectSubset<T, sessionsCreateArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {sessionsCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const sessions = await prisma.sessions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends sessionsCreateManyArgs>(args?: SelectSubset<T, sessionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Sessions.
     * @param {sessionsDeleteArgs} args - Arguments to delete one Sessions.
     * @example
     * // Delete one Sessions
     * const Sessions = await prisma.sessions.delete({
     *   where: {
     *     // ... filter to delete one Sessions
     *   }
     * })
     * 
     */
    delete<T extends sessionsDeleteArgs>(args: SelectSubset<T, sessionsDeleteArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Sessions.
     * @param {sessionsUpdateArgs} args - Arguments to update one Sessions.
     * @example
     * // Update one Sessions
     * const sessions = await prisma.sessions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends sessionsUpdateArgs>(args: SelectSubset<T, sessionsUpdateArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {sessionsDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.sessions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends sessionsDeleteManyArgs>(args?: SelectSubset<T, sessionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const sessions = await prisma.sessions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends sessionsUpdateManyArgs>(args: SelectSubset<T, sessionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Sessions.
     * @param {sessionsUpsertArgs} args - Arguments to update or create a Sessions.
     * @example
     * // Update or create a Sessions
     * const sessions = await prisma.sessions.upsert({
     *   create: {
     *     // ... data to create a Sessions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sessions we want to update
     *   }
     * })
     */
    upsert<T extends sessionsUpsertArgs>(args: SelectSubset<T, sessionsUpsertArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.sessions.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends sessionsCountArgs>(
      args?: Subset<T, sessionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionsAggregateArgs>(args: Subset<T, SessionsAggregateArgs>): Prisma.PrismaPromise<GetSessionsAggregateType<T>>

    /**
     * Group by Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends sessionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: sessionsGroupByArgs['orderBy'] }
        : { orderBy?: sessionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, sessionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the sessions model
   */
  readonly fields: sessionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for sessions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__sessionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the sessions model
   */
  interface sessionsFieldRefs {
    readonly id: FieldRef<"sessions", 'String'>
    readonly userId: FieldRef<"sessions", 'String'>
    readonly token: FieldRef<"sessions", 'String'>
    readonly deviceInfo: FieldRef<"sessions", 'String'>
    readonly ipAddress: FieldRef<"sessions", 'String'>
    readonly userAgent: FieldRef<"sessions", 'String'>
    readonly expiresAt: FieldRef<"sessions", 'DateTime'>
    readonly createdAt: FieldRef<"sessions", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * sessions findUnique
   */
  export type sessionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Filter, which sessions to fetch.
     */
    where: sessionsWhereUniqueInput
  }

  /**
   * sessions findUniqueOrThrow
   */
  export type sessionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Filter, which sessions to fetch.
     */
    where: sessionsWhereUniqueInput
  }

  /**
   * sessions findFirst
   */
  export type sessionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Filter, which sessions to fetch.
     */
    where?: sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionsOrderByWithRelationInput | sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sessions.
     */
    cursor?: sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sessions.
     */
    distinct?: SessionsScalarFieldEnum | SessionsScalarFieldEnum[]
  }

  /**
   * sessions findFirstOrThrow
   */
  export type sessionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Filter, which sessions to fetch.
     */
    where?: sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionsOrderByWithRelationInput | sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sessions.
     */
    cursor?: sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sessions.
     */
    distinct?: SessionsScalarFieldEnum | SessionsScalarFieldEnum[]
  }

  /**
   * sessions findMany
   */
  export type sessionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Filter, which sessions to fetch.
     */
    where?: sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionsOrderByWithRelationInput | sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sessions.
     */
    cursor?: sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    distinct?: SessionsScalarFieldEnum | SessionsScalarFieldEnum[]
  }

  /**
   * sessions create
   */
  export type sessionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * The data needed to create a sessions.
     */
    data: XOR<sessionsCreateInput, sessionsUncheckedCreateInput>
  }

  /**
   * sessions createMany
   */
  export type sessionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many sessions.
     */
    data: sessionsCreateManyInput | sessionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * sessions update
   */
  export type sessionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * The data needed to update a sessions.
     */
    data: XOR<sessionsUpdateInput, sessionsUncheckedUpdateInput>
    /**
     * Choose, which sessions to update.
     */
    where: sessionsWhereUniqueInput
  }

  /**
   * sessions updateMany
   */
  export type sessionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update sessions.
     */
    data: XOR<sessionsUpdateManyMutationInput, sessionsUncheckedUpdateManyInput>
    /**
     * Filter which sessions to update
     */
    where?: sessionsWhereInput
    /**
     * Limit how many sessions to update.
     */
    limit?: number
  }

  /**
   * sessions upsert
   */
  export type sessionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * The filter to search for the sessions to update in case it exists.
     */
    where: sessionsWhereUniqueInput
    /**
     * In case the sessions found by the `where` argument doesn't exist, create a new sessions with this data.
     */
    create: XOR<sessionsCreateInput, sessionsUncheckedCreateInput>
    /**
     * In case the sessions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<sessionsUpdateInput, sessionsUncheckedUpdateInput>
  }

  /**
   * sessions delete
   */
  export type sessionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Filter which sessions to delete.
     */
    where: sessionsWhereUniqueInput
  }

  /**
   * sessions deleteMany
   */
  export type sessionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sessions to delete
     */
    where?: sessionsWhereInput
    /**
     * Limit how many sessions to delete.
     */
    limit?: number
  }

  /**
   * sessions without action
   */
  export type sessionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
  }


  /**
   * Model system_config
   */

  export type AggregateSystem_config = {
    _count: System_configCountAggregateOutputType | null
    _min: System_configMinAggregateOutputType | null
    _max: System_configMaxAggregateOutputType | null
  }

  export type System_configMinAggregateOutputType = {
    id: string | null
    key: string | null
    value: string | null
    description: string | null
    updatedAt: Date | null
  }

  export type System_configMaxAggregateOutputType = {
    id: string | null
    key: string | null
    value: string | null
    description: string | null
    updatedAt: Date | null
  }

  export type System_configCountAggregateOutputType = {
    id: number
    key: number
    value: number
    description: number
    updatedAt: number
    _all: number
  }


  export type System_configMinAggregateInputType = {
    id?: true
    key?: true
    value?: true
    description?: true
    updatedAt?: true
  }

  export type System_configMaxAggregateInputType = {
    id?: true
    key?: true
    value?: true
    description?: true
    updatedAt?: true
  }

  export type System_configCountAggregateInputType = {
    id?: true
    key?: true
    value?: true
    description?: true
    updatedAt?: true
    _all?: true
  }

  export type System_configAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which system_config to aggregate.
     */
    where?: system_configWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of system_configs to fetch.
     */
    orderBy?: system_configOrderByWithRelationInput | system_configOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: system_configWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` system_configs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` system_configs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned system_configs
    **/
    _count?: true | System_configCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: System_configMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: System_configMaxAggregateInputType
  }

  export type GetSystem_configAggregateType<T extends System_configAggregateArgs> = {
        [P in keyof T & keyof AggregateSystem_config]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystem_config[P]>
      : GetScalarType<T[P], AggregateSystem_config[P]>
  }




  export type system_configGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: system_configWhereInput
    orderBy?: system_configOrderByWithAggregationInput | system_configOrderByWithAggregationInput[]
    by: System_configScalarFieldEnum[] | System_configScalarFieldEnum
    having?: system_configScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: System_configCountAggregateInputType | true
    _min?: System_configMinAggregateInputType
    _max?: System_configMaxAggregateInputType
  }

  export type System_configGroupByOutputType = {
    id: string
    key: string
    value: string
    description: string | null
    updatedAt: Date
    _count: System_configCountAggregateOutputType | null
    _min: System_configMinAggregateOutputType | null
    _max: System_configMaxAggregateOutputType | null
  }

  type GetSystem_configGroupByPayload<T extends system_configGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<System_configGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof System_configGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], System_configGroupByOutputType[P]>
            : GetScalarType<T[P], System_configGroupByOutputType[P]>
        }
      >
    >


  export type system_configSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    description?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["system_config"]>



  export type system_configSelectScalar = {
    id?: boolean
    key?: boolean
    value?: boolean
    description?: boolean
    updatedAt?: boolean
  }

  export type system_configOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "key" | "value" | "description" | "updatedAt", ExtArgs["result"]["system_config"]>

  export type $system_configPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "system_config"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      key: string
      value: string
      description: string | null
      updatedAt: Date
    }, ExtArgs["result"]["system_config"]>
    composites: {}
  }

  type system_configGetPayload<S extends boolean | null | undefined | system_configDefaultArgs> = $Result.GetResult<Prisma.$system_configPayload, S>

  type system_configCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<system_configFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: System_configCountAggregateInputType | true
    }

  export interface system_configDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['system_config'], meta: { name: 'system_config' } }
    /**
     * Find zero or one System_config that matches the filter.
     * @param {system_configFindUniqueArgs} args - Arguments to find a System_config
     * @example
     * // Get one System_config
     * const system_config = await prisma.system_config.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends system_configFindUniqueArgs>(args: SelectSubset<T, system_configFindUniqueArgs<ExtArgs>>): Prisma__system_configClient<$Result.GetResult<Prisma.$system_configPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one System_config that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {system_configFindUniqueOrThrowArgs} args - Arguments to find a System_config
     * @example
     * // Get one System_config
     * const system_config = await prisma.system_config.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends system_configFindUniqueOrThrowArgs>(args: SelectSubset<T, system_configFindUniqueOrThrowArgs<ExtArgs>>): Prisma__system_configClient<$Result.GetResult<Prisma.$system_configPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first System_config that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {system_configFindFirstArgs} args - Arguments to find a System_config
     * @example
     * // Get one System_config
     * const system_config = await prisma.system_config.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends system_configFindFirstArgs>(args?: SelectSubset<T, system_configFindFirstArgs<ExtArgs>>): Prisma__system_configClient<$Result.GetResult<Prisma.$system_configPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first System_config that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {system_configFindFirstOrThrowArgs} args - Arguments to find a System_config
     * @example
     * // Get one System_config
     * const system_config = await prisma.system_config.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends system_configFindFirstOrThrowArgs>(args?: SelectSubset<T, system_configFindFirstOrThrowArgs<ExtArgs>>): Prisma__system_configClient<$Result.GetResult<Prisma.$system_configPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more System_configs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {system_configFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all System_configs
     * const system_configs = await prisma.system_config.findMany()
     * 
     * // Get first 10 System_configs
     * const system_configs = await prisma.system_config.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const system_configWithIdOnly = await prisma.system_config.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends system_configFindManyArgs>(args?: SelectSubset<T, system_configFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$system_configPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a System_config.
     * @param {system_configCreateArgs} args - Arguments to create a System_config.
     * @example
     * // Create one System_config
     * const System_config = await prisma.system_config.create({
     *   data: {
     *     // ... data to create a System_config
     *   }
     * })
     * 
     */
    create<T extends system_configCreateArgs>(args: SelectSubset<T, system_configCreateArgs<ExtArgs>>): Prisma__system_configClient<$Result.GetResult<Prisma.$system_configPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many System_configs.
     * @param {system_configCreateManyArgs} args - Arguments to create many System_configs.
     * @example
     * // Create many System_configs
     * const system_config = await prisma.system_config.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends system_configCreateManyArgs>(args?: SelectSubset<T, system_configCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a System_config.
     * @param {system_configDeleteArgs} args - Arguments to delete one System_config.
     * @example
     * // Delete one System_config
     * const System_config = await prisma.system_config.delete({
     *   where: {
     *     // ... filter to delete one System_config
     *   }
     * })
     * 
     */
    delete<T extends system_configDeleteArgs>(args: SelectSubset<T, system_configDeleteArgs<ExtArgs>>): Prisma__system_configClient<$Result.GetResult<Prisma.$system_configPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one System_config.
     * @param {system_configUpdateArgs} args - Arguments to update one System_config.
     * @example
     * // Update one System_config
     * const system_config = await prisma.system_config.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends system_configUpdateArgs>(args: SelectSubset<T, system_configUpdateArgs<ExtArgs>>): Prisma__system_configClient<$Result.GetResult<Prisma.$system_configPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more System_configs.
     * @param {system_configDeleteManyArgs} args - Arguments to filter System_configs to delete.
     * @example
     * // Delete a few System_configs
     * const { count } = await prisma.system_config.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends system_configDeleteManyArgs>(args?: SelectSubset<T, system_configDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more System_configs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {system_configUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many System_configs
     * const system_config = await prisma.system_config.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends system_configUpdateManyArgs>(args: SelectSubset<T, system_configUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one System_config.
     * @param {system_configUpsertArgs} args - Arguments to update or create a System_config.
     * @example
     * // Update or create a System_config
     * const system_config = await prisma.system_config.upsert({
     *   create: {
     *     // ... data to create a System_config
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the System_config we want to update
     *   }
     * })
     */
    upsert<T extends system_configUpsertArgs>(args: SelectSubset<T, system_configUpsertArgs<ExtArgs>>): Prisma__system_configClient<$Result.GetResult<Prisma.$system_configPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of System_configs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {system_configCountArgs} args - Arguments to filter System_configs to count.
     * @example
     * // Count the number of System_configs
     * const count = await prisma.system_config.count({
     *   where: {
     *     // ... the filter for the System_configs we want to count
     *   }
     * })
    **/
    count<T extends system_configCountArgs>(
      args?: Subset<T, system_configCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], System_configCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a System_config.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {System_configAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends System_configAggregateArgs>(args: Subset<T, System_configAggregateArgs>): Prisma.PrismaPromise<GetSystem_configAggregateType<T>>

    /**
     * Group by System_config.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {system_configGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends system_configGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: system_configGroupByArgs['orderBy'] }
        : { orderBy?: system_configGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, system_configGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystem_configGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the system_config model
   */
  readonly fields: system_configFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for system_config.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__system_configClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the system_config model
   */
  interface system_configFieldRefs {
    readonly id: FieldRef<"system_config", 'String'>
    readonly key: FieldRef<"system_config", 'String'>
    readonly value: FieldRef<"system_config", 'String'>
    readonly description: FieldRef<"system_config", 'String'>
    readonly updatedAt: FieldRef<"system_config", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * system_config findUnique
   */
  export type system_configFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the system_config
     */
    select?: system_configSelect<ExtArgs> | null
    /**
     * Omit specific fields from the system_config
     */
    omit?: system_configOmit<ExtArgs> | null
    /**
     * Filter, which system_config to fetch.
     */
    where: system_configWhereUniqueInput
  }

  /**
   * system_config findUniqueOrThrow
   */
  export type system_configFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the system_config
     */
    select?: system_configSelect<ExtArgs> | null
    /**
     * Omit specific fields from the system_config
     */
    omit?: system_configOmit<ExtArgs> | null
    /**
     * Filter, which system_config to fetch.
     */
    where: system_configWhereUniqueInput
  }

  /**
   * system_config findFirst
   */
  export type system_configFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the system_config
     */
    select?: system_configSelect<ExtArgs> | null
    /**
     * Omit specific fields from the system_config
     */
    omit?: system_configOmit<ExtArgs> | null
    /**
     * Filter, which system_config to fetch.
     */
    where?: system_configWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of system_configs to fetch.
     */
    orderBy?: system_configOrderByWithRelationInput | system_configOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for system_configs.
     */
    cursor?: system_configWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` system_configs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` system_configs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of system_configs.
     */
    distinct?: System_configScalarFieldEnum | System_configScalarFieldEnum[]
  }

  /**
   * system_config findFirstOrThrow
   */
  export type system_configFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the system_config
     */
    select?: system_configSelect<ExtArgs> | null
    /**
     * Omit specific fields from the system_config
     */
    omit?: system_configOmit<ExtArgs> | null
    /**
     * Filter, which system_config to fetch.
     */
    where?: system_configWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of system_configs to fetch.
     */
    orderBy?: system_configOrderByWithRelationInput | system_configOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for system_configs.
     */
    cursor?: system_configWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` system_configs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` system_configs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of system_configs.
     */
    distinct?: System_configScalarFieldEnum | System_configScalarFieldEnum[]
  }

  /**
   * system_config findMany
   */
  export type system_configFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the system_config
     */
    select?: system_configSelect<ExtArgs> | null
    /**
     * Omit specific fields from the system_config
     */
    omit?: system_configOmit<ExtArgs> | null
    /**
     * Filter, which system_configs to fetch.
     */
    where?: system_configWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of system_configs to fetch.
     */
    orderBy?: system_configOrderByWithRelationInput | system_configOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing system_configs.
     */
    cursor?: system_configWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` system_configs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` system_configs.
     */
    skip?: number
    distinct?: System_configScalarFieldEnum | System_configScalarFieldEnum[]
  }

  /**
   * system_config create
   */
  export type system_configCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the system_config
     */
    select?: system_configSelect<ExtArgs> | null
    /**
     * Omit specific fields from the system_config
     */
    omit?: system_configOmit<ExtArgs> | null
    /**
     * The data needed to create a system_config.
     */
    data: XOR<system_configCreateInput, system_configUncheckedCreateInput>
  }

  /**
   * system_config createMany
   */
  export type system_configCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many system_configs.
     */
    data: system_configCreateManyInput | system_configCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * system_config update
   */
  export type system_configUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the system_config
     */
    select?: system_configSelect<ExtArgs> | null
    /**
     * Omit specific fields from the system_config
     */
    omit?: system_configOmit<ExtArgs> | null
    /**
     * The data needed to update a system_config.
     */
    data: XOR<system_configUpdateInput, system_configUncheckedUpdateInput>
    /**
     * Choose, which system_config to update.
     */
    where: system_configWhereUniqueInput
  }

  /**
   * system_config updateMany
   */
  export type system_configUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update system_configs.
     */
    data: XOR<system_configUpdateManyMutationInput, system_configUncheckedUpdateManyInput>
    /**
     * Filter which system_configs to update
     */
    where?: system_configWhereInput
    /**
     * Limit how many system_configs to update.
     */
    limit?: number
  }

  /**
   * system_config upsert
   */
  export type system_configUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the system_config
     */
    select?: system_configSelect<ExtArgs> | null
    /**
     * Omit specific fields from the system_config
     */
    omit?: system_configOmit<ExtArgs> | null
    /**
     * The filter to search for the system_config to update in case it exists.
     */
    where: system_configWhereUniqueInput
    /**
     * In case the system_config found by the `where` argument doesn't exist, create a new system_config with this data.
     */
    create: XOR<system_configCreateInput, system_configUncheckedCreateInput>
    /**
     * In case the system_config was found with the provided `where` argument, update it with this data.
     */
    update: XOR<system_configUpdateInput, system_configUncheckedUpdateInput>
  }

  /**
   * system_config delete
   */
  export type system_configDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the system_config
     */
    select?: system_configSelect<ExtArgs> | null
    /**
     * Omit specific fields from the system_config
     */
    omit?: system_configOmit<ExtArgs> | null
    /**
     * Filter which system_config to delete.
     */
    where: system_configWhereUniqueInput
  }

  /**
   * system_config deleteMany
   */
  export type system_configDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which system_configs to delete
     */
    where?: system_configWhereInput
    /**
     * Limit how many system_configs to delete.
     */
    limit?: number
  }

  /**
   * system_config without action
   */
  export type system_configDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the system_config
     */
    select?: system_configSelect<ExtArgs> | null
    /**
     * Omit specific fields from the system_config
     */
    omit?: system_configOmit<ExtArgs> | null
  }


  /**
   * Model documents
   */

  export type AggregateDocuments = {
    _count: DocumentsCountAggregateOutputType | null
    _avg: DocumentsAvgAggregateOutputType | null
    _sum: DocumentsSumAggregateOutputType | null
    _min: DocumentsMinAggregateOutputType | null
    _max: DocumentsMaxAggregateOutputType | null
  }

  export type DocumentsAvgAggregateOutputType = {
    price: Decimal | null
    employeeId: number | null
    docFilePrice: Decimal | null
  }

  export type DocumentsSumAggregateOutputType = {
    price: Decimal | null
    employeeId: number | null
    docFilePrice: Decimal | null
  }

  export type DocumentsMinAggregateOutputType = {
    id: string | null
    docType: $Enums.documents_docType | null
    docNumber: string | null
    docDate: Date | null
    title: string | null
    price: Decimal | null
    cashFlowName: string | null
    employeeId: number | null
    username: string | null
    docFile: string | null
    docFileDate: Date | null
    docFileTime: string | null
    docFilePrice: Decimal | null
    filePath: string | null
    note: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type DocumentsMaxAggregateOutputType = {
    id: string | null
    docType: $Enums.documents_docType | null
    docNumber: string | null
    docDate: Date | null
    title: string | null
    price: Decimal | null
    cashFlowName: string | null
    employeeId: number | null
    username: string | null
    docFile: string | null
    docFileDate: Date | null
    docFileTime: string | null
    docFilePrice: Decimal | null
    filePath: string | null
    note: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type DocumentsCountAggregateOutputType = {
    id: number
    docType: number
    docNumber: number
    docDate: number
    title: number
    price: number
    cashFlowName: number
    employeeId: number
    username: number
    docFile: number
    docFileDate: number
    docFileTime: number
    docFilePrice: number
    filePath: number
    note: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type DocumentsAvgAggregateInputType = {
    price?: true
    employeeId?: true
    docFilePrice?: true
  }

  export type DocumentsSumAggregateInputType = {
    price?: true
    employeeId?: true
    docFilePrice?: true
  }

  export type DocumentsMinAggregateInputType = {
    id?: true
    docType?: true
    docNumber?: true
    docDate?: true
    title?: true
    price?: true
    cashFlowName?: true
    employeeId?: true
    username?: true
    docFile?: true
    docFileDate?: true
    docFileTime?: true
    docFilePrice?: true
    filePath?: true
    note?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type DocumentsMaxAggregateInputType = {
    id?: true
    docType?: true
    docNumber?: true
    docDate?: true
    title?: true
    price?: true
    cashFlowName?: true
    employeeId?: true
    username?: true
    docFile?: true
    docFileDate?: true
    docFileTime?: true
    docFilePrice?: true
    filePath?: true
    note?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type DocumentsCountAggregateInputType = {
    id?: true
    docType?: true
    docNumber?: true
    docDate?: true
    title?: true
    price?: true
    cashFlowName?: true
    employeeId?: true
    username?: true
    docFile?: true
    docFileDate?: true
    docFileTime?: true
    docFilePrice?: true
    filePath?: true
    note?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type DocumentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which documents to aggregate.
     */
    where?: documentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of documents to fetch.
     */
    orderBy?: documentsOrderByWithRelationInput | documentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: documentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned documents
    **/
    _count?: true | DocumentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DocumentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DocumentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentsMaxAggregateInputType
  }

  export type GetDocumentsAggregateType<T extends DocumentsAggregateArgs> = {
        [P in keyof T & keyof AggregateDocuments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocuments[P]>
      : GetScalarType<T[P], AggregateDocuments[P]>
  }




  export type documentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: documentsWhereInput
    orderBy?: documentsOrderByWithAggregationInput | documentsOrderByWithAggregationInput[]
    by: DocumentsScalarFieldEnum[] | DocumentsScalarFieldEnum
    having?: documentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentsCountAggregateInputType | true
    _avg?: DocumentsAvgAggregateInputType
    _sum?: DocumentsSumAggregateInputType
    _min?: DocumentsMinAggregateInputType
    _max?: DocumentsMaxAggregateInputType
  }

  export type DocumentsGroupByOutputType = {
    id: string
    docType: $Enums.documents_docType
    docNumber: string
    docDate: Date
    title: string
    price: Decimal
    cashFlowName: string
    employeeId: number
    username: string | null
    docFile: string | null
    docFileDate: Date | null
    docFileTime: string | null
    docFilePrice: Decimal | null
    filePath: string | null
    note: string | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: DocumentsCountAggregateOutputType | null
    _avg: DocumentsAvgAggregateOutputType | null
    _sum: DocumentsSumAggregateOutputType | null
    _min: DocumentsMinAggregateOutputType | null
    _max: DocumentsMaxAggregateOutputType | null
  }

  type GetDocumentsGroupByPayload<T extends documentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentsGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentsGroupByOutputType[P]>
        }
      >
    >


  export type documentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    docType?: boolean
    docNumber?: boolean
    docDate?: boolean
    title?: boolean
    price?: boolean
    cashFlowName?: boolean
    employeeId?: boolean
    username?: boolean
    docFile?: boolean
    docFileDate?: boolean
    docFileTime?: boolean
    docFilePrice?: boolean
    filePath?: boolean
    note?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["documents"]>



  export type documentsSelectScalar = {
    id?: boolean
    docType?: boolean
    docNumber?: boolean
    docDate?: boolean
    title?: boolean
    price?: boolean
    cashFlowName?: boolean
    employeeId?: boolean
    username?: boolean
    docFile?: boolean
    docFileDate?: boolean
    docFileTime?: boolean
    docFilePrice?: boolean
    filePath?: boolean
    note?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type documentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "docType" | "docNumber" | "docDate" | "title" | "price" | "cashFlowName" | "employeeId" | "username" | "docFile" | "docFileDate" | "docFileTime" | "docFilePrice" | "filePath" | "note" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["documents"]>

  export type $documentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "documents"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      docType: $Enums.documents_docType
      docNumber: string
      docDate: Date
      title: string
      price: Prisma.Decimal
      cashFlowName: string
      employeeId: number
      username: string | null
      docFile: string | null
      docFileDate: Date | null
      docFileTime: string | null
      docFilePrice: Prisma.Decimal | null
      filePath: string | null
      note: string | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["documents"]>
    composites: {}
  }

  type documentsGetPayload<S extends boolean | null | undefined | documentsDefaultArgs> = $Result.GetResult<Prisma.$documentsPayload, S>

  type documentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<documentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DocumentsCountAggregateInputType | true
    }

  export interface documentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['documents'], meta: { name: 'documents' } }
    /**
     * Find zero or one Documents that matches the filter.
     * @param {documentsFindUniqueArgs} args - Arguments to find a Documents
     * @example
     * // Get one Documents
     * const documents = await prisma.documents.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends documentsFindUniqueArgs>(args: SelectSubset<T, documentsFindUniqueArgs<ExtArgs>>): Prisma__documentsClient<$Result.GetResult<Prisma.$documentsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Documents that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {documentsFindUniqueOrThrowArgs} args - Arguments to find a Documents
     * @example
     * // Get one Documents
     * const documents = await prisma.documents.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends documentsFindUniqueOrThrowArgs>(args: SelectSubset<T, documentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__documentsClient<$Result.GetResult<Prisma.$documentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {documentsFindFirstArgs} args - Arguments to find a Documents
     * @example
     * // Get one Documents
     * const documents = await prisma.documents.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends documentsFindFirstArgs>(args?: SelectSubset<T, documentsFindFirstArgs<ExtArgs>>): Prisma__documentsClient<$Result.GetResult<Prisma.$documentsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Documents that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {documentsFindFirstOrThrowArgs} args - Arguments to find a Documents
     * @example
     * // Get one Documents
     * const documents = await prisma.documents.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends documentsFindFirstOrThrowArgs>(args?: SelectSubset<T, documentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__documentsClient<$Result.GetResult<Prisma.$documentsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {documentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Documents
     * const documents = await prisma.documents.findMany()
     * 
     * // Get first 10 Documents
     * const documents = await prisma.documents.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentsWithIdOnly = await prisma.documents.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends documentsFindManyArgs>(args?: SelectSubset<T, documentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$documentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Documents.
     * @param {documentsCreateArgs} args - Arguments to create a Documents.
     * @example
     * // Create one Documents
     * const Documents = await prisma.documents.create({
     *   data: {
     *     // ... data to create a Documents
     *   }
     * })
     * 
     */
    create<T extends documentsCreateArgs>(args: SelectSubset<T, documentsCreateArgs<ExtArgs>>): Prisma__documentsClient<$Result.GetResult<Prisma.$documentsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Documents.
     * @param {documentsCreateManyArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const documents = await prisma.documents.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends documentsCreateManyArgs>(args?: SelectSubset<T, documentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Documents.
     * @param {documentsDeleteArgs} args - Arguments to delete one Documents.
     * @example
     * // Delete one Documents
     * const Documents = await prisma.documents.delete({
     *   where: {
     *     // ... filter to delete one Documents
     *   }
     * })
     * 
     */
    delete<T extends documentsDeleteArgs>(args: SelectSubset<T, documentsDeleteArgs<ExtArgs>>): Prisma__documentsClient<$Result.GetResult<Prisma.$documentsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Documents.
     * @param {documentsUpdateArgs} args - Arguments to update one Documents.
     * @example
     * // Update one Documents
     * const documents = await prisma.documents.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends documentsUpdateArgs>(args: SelectSubset<T, documentsUpdateArgs<ExtArgs>>): Prisma__documentsClient<$Result.GetResult<Prisma.$documentsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Documents.
     * @param {documentsDeleteManyArgs} args - Arguments to filter Documents to delete.
     * @example
     * // Delete a few Documents
     * const { count } = await prisma.documents.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends documentsDeleteManyArgs>(args?: SelectSubset<T, documentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {documentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Documents
     * const documents = await prisma.documents.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends documentsUpdateManyArgs>(args: SelectSubset<T, documentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Documents.
     * @param {documentsUpsertArgs} args - Arguments to update or create a Documents.
     * @example
     * // Update or create a Documents
     * const documents = await prisma.documents.upsert({
     *   create: {
     *     // ... data to create a Documents
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Documents we want to update
     *   }
     * })
     */
    upsert<T extends documentsUpsertArgs>(args: SelectSubset<T, documentsUpsertArgs<ExtArgs>>): Prisma__documentsClient<$Result.GetResult<Prisma.$documentsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {documentsCountArgs} args - Arguments to filter Documents to count.
     * @example
     * // Count the number of Documents
     * const count = await prisma.documents.count({
     *   where: {
     *     // ... the filter for the Documents we want to count
     *   }
     * })
    **/
    count<T extends documentsCountArgs>(
      args?: Subset<T, documentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentsAggregateArgs>(args: Subset<T, DocumentsAggregateArgs>): Prisma.PrismaPromise<GetDocumentsAggregateType<T>>

    /**
     * Group by Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {documentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends documentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: documentsGroupByArgs['orderBy'] }
        : { orderBy?: documentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, documentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the documents model
   */
  readonly fields: documentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for documents.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__documentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the documents model
   */
  interface documentsFieldRefs {
    readonly id: FieldRef<"documents", 'String'>
    readonly docType: FieldRef<"documents", 'documents_docType'>
    readonly docNumber: FieldRef<"documents", 'String'>
    readonly docDate: FieldRef<"documents", 'DateTime'>
    readonly title: FieldRef<"documents", 'String'>
    readonly price: FieldRef<"documents", 'Decimal'>
    readonly cashFlowName: FieldRef<"documents", 'String'>
    readonly employeeId: FieldRef<"documents", 'Int'>
    readonly username: FieldRef<"documents", 'String'>
    readonly docFile: FieldRef<"documents", 'String'>
    readonly docFileDate: FieldRef<"documents", 'DateTime'>
    readonly docFileTime: FieldRef<"documents", 'String'>
    readonly docFilePrice: FieldRef<"documents", 'Decimal'>
    readonly filePath: FieldRef<"documents", 'String'>
    readonly note: FieldRef<"documents", 'String'>
    readonly createdAt: FieldRef<"documents", 'DateTime'>
    readonly updatedAt: FieldRef<"documents", 'DateTime'>
    readonly deletedAt: FieldRef<"documents", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * documents findUnique
   */
  export type documentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documents
     */
    select?: documentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the documents
     */
    omit?: documentsOmit<ExtArgs> | null
    /**
     * Filter, which documents to fetch.
     */
    where: documentsWhereUniqueInput
  }

  /**
   * documents findUniqueOrThrow
   */
  export type documentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documents
     */
    select?: documentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the documents
     */
    omit?: documentsOmit<ExtArgs> | null
    /**
     * Filter, which documents to fetch.
     */
    where: documentsWhereUniqueInput
  }

  /**
   * documents findFirst
   */
  export type documentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documents
     */
    select?: documentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the documents
     */
    omit?: documentsOmit<ExtArgs> | null
    /**
     * Filter, which documents to fetch.
     */
    where?: documentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of documents to fetch.
     */
    orderBy?: documentsOrderByWithRelationInput | documentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for documents.
     */
    cursor?: documentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of documents.
     */
    distinct?: DocumentsScalarFieldEnum | DocumentsScalarFieldEnum[]
  }

  /**
   * documents findFirstOrThrow
   */
  export type documentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documents
     */
    select?: documentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the documents
     */
    omit?: documentsOmit<ExtArgs> | null
    /**
     * Filter, which documents to fetch.
     */
    where?: documentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of documents to fetch.
     */
    orderBy?: documentsOrderByWithRelationInput | documentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for documents.
     */
    cursor?: documentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of documents.
     */
    distinct?: DocumentsScalarFieldEnum | DocumentsScalarFieldEnum[]
  }

  /**
   * documents findMany
   */
  export type documentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documents
     */
    select?: documentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the documents
     */
    omit?: documentsOmit<ExtArgs> | null
    /**
     * Filter, which documents to fetch.
     */
    where?: documentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of documents to fetch.
     */
    orderBy?: documentsOrderByWithRelationInput | documentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing documents.
     */
    cursor?: documentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` documents.
     */
    skip?: number
    distinct?: DocumentsScalarFieldEnum | DocumentsScalarFieldEnum[]
  }

  /**
   * documents create
   */
  export type documentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documents
     */
    select?: documentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the documents
     */
    omit?: documentsOmit<ExtArgs> | null
    /**
     * The data needed to create a documents.
     */
    data: XOR<documentsCreateInput, documentsUncheckedCreateInput>
  }

  /**
   * documents createMany
   */
  export type documentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many documents.
     */
    data: documentsCreateManyInput | documentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * documents update
   */
  export type documentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documents
     */
    select?: documentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the documents
     */
    omit?: documentsOmit<ExtArgs> | null
    /**
     * The data needed to update a documents.
     */
    data: XOR<documentsUpdateInput, documentsUncheckedUpdateInput>
    /**
     * Choose, which documents to update.
     */
    where: documentsWhereUniqueInput
  }

  /**
   * documents updateMany
   */
  export type documentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update documents.
     */
    data: XOR<documentsUpdateManyMutationInput, documentsUncheckedUpdateManyInput>
    /**
     * Filter which documents to update
     */
    where?: documentsWhereInput
    /**
     * Limit how many documents to update.
     */
    limit?: number
  }

  /**
   * documents upsert
   */
  export type documentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documents
     */
    select?: documentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the documents
     */
    omit?: documentsOmit<ExtArgs> | null
    /**
     * The filter to search for the documents to update in case it exists.
     */
    where: documentsWhereUniqueInput
    /**
     * In case the documents found by the `where` argument doesn't exist, create a new documents with this data.
     */
    create: XOR<documentsCreateInput, documentsUncheckedCreateInput>
    /**
     * In case the documents was found with the provided `where` argument, update it with this data.
     */
    update: XOR<documentsUpdateInput, documentsUncheckedUpdateInput>
  }

  /**
   * documents delete
   */
  export type documentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documents
     */
    select?: documentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the documents
     */
    omit?: documentsOmit<ExtArgs> | null
    /**
     * Filter which documents to delete.
     */
    where: documentsWhereUniqueInput
  }

  /**
   * documents deleteMany
   */
  export type documentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which documents to delete
     */
    where?: documentsWhereInput
    /**
     * Limit how many documents to delete.
     */
    limit?: number
  }

  /**
   * documents without action
   */
  export type documentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documents
     */
    select?: documentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the documents
     */
    omit?: documentsOmit<ExtArgs> | null
  }


  /**
   * Model document_title_lists
   */

  export type AggregateDocument_title_lists = {
    _count: Document_title_listsCountAggregateOutputType | null
    _min: Document_title_listsMinAggregateOutputType | null
    _max: Document_title_listsMaxAggregateOutputType | null
  }

  export type Document_title_listsMinAggregateOutputType = {
    id: string | null
    docType: $Enums.document_title_lists_docType | null
    title: string | null
    note: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type Document_title_listsMaxAggregateOutputType = {
    id: string | null
    docType: $Enums.document_title_lists_docType | null
    title: string | null
    note: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type Document_title_listsCountAggregateOutputType = {
    id: number
    docType: number
    title: number
    note: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type Document_title_listsMinAggregateInputType = {
    id?: true
    docType?: true
    title?: true
    note?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type Document_title_listsMaxAggregateInputType = {
    id?: true
    docType?: true
    title?: true
    note?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type Document_title_listsCountAggregateInputType = {
    id?: true
    docType?: true
    title?: true
    note?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type Document_title_listsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which document_title_lists to aggregate.
     */
    where?: document_title_listsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of document_title_lists to fetch.
     */
    orderBy?: document_title_listsOrderByWithRelationInput | document_title_listsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: document_title_listsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` document_title_lists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` document_title_lists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned document_title_lists
    **/
    _count?: true | Document_title_listsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Document_title_listsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Document_title_listsMaxAggregateInputType
  }

  export type GetDocument_title_listsAggregateType<T extends Document_title_listsAggregateArgs> = {
        [P in keyof T & keyof AggregateDocument_title_lists]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocument_title_lists[P]>
      : GetScalarType<T[P], AggregateDocument_title_lists[P]>
  }




  export type document_title_listsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: document_title_listsWhereInput
    orderBy?: document_title_listsOrderByWithAggregationInput | document_title_listsOrderByWithAggregationInput[]
    by: Document_title_listsScalarFieldEnum[] | Document_title_listsScalarFieldEnum
    having?: document_title_listsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Document_title_listsCountAggregateInputType | true
    _min?: Document_title_listsMinAggregateInputType
    _max?: Document_title_listsMaxAggregateInputType
  }

  export type Document_title_listsGroupByOutputType = {
    id: string
    docType: $Enums.document_title_lists_docType
    title: string
    note: string | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: Document_title_listsCountAggregateOutputType | null
    _min: Document_title_listsMinAggregateOutputType | null
    _max: Document_title_listsMaxAggregateOutputType | null
  }

  type GetDocument_title_listsGroupByPayload<T extends document_title_listsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Document_title_listsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Document_title_listsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Document_title_listsGroupByOutputType[P]>
            : GetScalarType<T[P], Document_title_listsGroupByOutputType[P]>
        }
      >
    >


  export type document_title_listsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    docType?: boolean
    title?: boolean
    note?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["document_title_lists"]>



  export type document_title_listsSelectScalar = {
    id?: boolean
    docType?: boolean
    title?: boolean
    note?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type document_title_listsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "docType" | "title" | "note" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["document_title_lists"]>

  export type $document_title_listsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "document_title_lists"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      docType: $Enums.document_title_lists_docType
      title: string
      note: string | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["document_title_lists"]>
    composites: {}
  }

  type document_title_listsGetPayload<S extends boolean | null | undefined | document_title_listsDefaultArgs> = $Result.GetResult<Prisma.$document_title_listsPayload, S>

  type document_title_listsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<document_title_listsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Document_title_listsCountAggregateInputType | true
    }

  export interface document_title_listsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['document_title_lists'], meta: { name: 'document_title_lists' } }
    /**
     * Find zero or one Document_title_lists that matches the filter.
     * @param {document_title_listsFindUniqueArgs} args - Arguments to find a Document_title_lists
     * @example
     * // Get one Document_title_lists
     * const document_title_lists = await prisma.document_title_lists.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends document_title_listsFindUniqueArgs>(args: SelectSubset<T, document_title_listsFindUniqueArgs<ExtArgs>>): Prisma__document_title_listsClient<$Result.GetResult<Prisma.$document_title_listsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Document_title_lists that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {document_title_listsFindUniqueOrThrowArgs} args - Arguments to find a Document_title_lists
     * @example
     * // Get one Document_title_lists
     * const document_title_lists = await prisma.document_title_lists.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends document_title_listsFindUniqueOrThrowArgs>(args: SelectSubset<T, document_title_listsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__document_title_listsClient<$Result.GetResult<Prisma.$document_title_listsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Document_title_lists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {document_title_listsFindFirstArgs} args - Arguments to find a Document_title_lists
     * @example
     * // Get one Document_title_lists
     * const document_title_lists = await prisma.document_title_lists.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends document_title_listsFindFirstArgs>(args?: SelectSubset<T, document_title_listsFindFirstArgs<ExtArgs>>): Prisma__document_title_listsClient<$Result.GetResult<Prisma.$document_title_listsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Document_title_lists that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {document_title_listsFindFirstOrThrowArgs} args - Arguments to find a Document_title_lists
     * @example
     * // Get one Document_title_lists
     * const document_title_lists = await prisma.document_title_lists.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends document_title_listsFindFirstOrThrowArgs>(args?: SelectSubset<T, document_title_listsFindFirstOrThrowArgs<ExtArgs>>): Prisma__document_title_listsClient<$Result.GetResult<Prisma.$document_title_listsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Document_title_lists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {document_title_listsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Document_title_lists
     * const document_title_lists = await prisma.document_title_lists.findMany()
     * 
     * // Get first 10 Document_title_lists
     * const document_title_lists = await prisma.document_title_lists.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const document_title_listsWithIdOnly = await prisma.document_title_lists.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends document_title_listsFindManyArgs>(args?: SelectSubset<T, document_title_listsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$document_title_listsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Document_title_lists.
     * @param {document_title_listsCreateArgs} args - Arguments to create a Document_title_lists.
     * @example
     * // Create one Document_title_lists
     * const Document_title_lists = await prisma.document_title_lists.create({
     *   data: {
     *     // ... data to create a Document_title_lists
     *   }
     * })
     * 
     */
    create<T extends document_title_listsCreateArgs>(args: SelectSubset<T, document_title_listsCreateArgs<ExtArgs>>): Prisma__document_title_listsClient<$Result.GetResult<Prisma.$document_title_listsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Document_title_lists.
     * @param {document_title_listsCreateManyArgs} args - Arguments to create many Document_title_lists.
     * @example
     * // Create many Document_title_lists
     * const document_title_lists = await prisma.document_title_lists.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends document_title_listsCreateManyArgs>(args?: SelectSubset<T, document_title_listsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Document_title_lists.
     * @param {document_title_listsDeleteArgs} args - Arguments to delete one Document_title_lists.
     * @example
     * // Delete one Document_title_lists
     * const Document_title_lists = await prisma.document_title_lists.delete({
     *   where: {
     *     // ... filter to delete one Document_title_lists
     *   }
     * })
     * 
     */
    delete<T extends document_title_listsDeleteArgs>(args: SelectSubset<T, document_title_listsDeleteArgs<ExtArgs>>): Prisma__document_title_listsClient<$Result.GetResult<Prisma.$document_title_listsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Document_title_lists.
     * @param {document_title_listsUpdateArgs} args - Arguments to update one Document_title_lists.
     * @example
     * // Update one Document_title_lists
     * const document_title_lists = await prisma.document_title_lists.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends document_title_listsUpdateArgs>(args: SelectSubset<T, document_title_listsUpdateArgs<ExtArgs>>): Prisma__document_title_listsClient<$Result.GetResult<Prisma.$document_title_listsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Document_title_lists.
     * @param {document_title_listsDeleteManyArgs} args - Arguments to filter Document_title_lists to delete.
     * @example
     * // Delete a few Document_title_lists
     * const { count } = await prisma.document_title_lists.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends document_title_listsDeleteManyArgs>(args?: SelectSubset<T, document_title_listsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Document_title_lists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {document_title_listsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Document_title_lists
     * const document_title_lists = await prisma.document_title_lists.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends document_title_listsUpdateManyArgs>(args: SelectSubset<T, document_title_listsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Document_title_lists.
     * @param {document_title_listsUpsertArgs} args - Arguments to update or create a Document_title_lists.
     * @example
     * // Update or create a Document_title_lists
     * const document_title_lists = await prisma.document_title_lists.upsert({
     *   create: {
     *     // ... data to create a Document_title_lists
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Document_title_lists we want to update
     *   }
     * })
     */
    upsert<T extends document_title_listsUpsertArgs>(args: SelectSubset<T, document_title_listsUpsertArgs<ExtArgs>>): Prisma__document_title_listsClient<$Result.GetResult<Prisma.$document_title_listsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Document_title_lists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {document_title_listsCountArgs} args - Arguments to filter Document_title_lists to count.
     * @example
     * // Count the number of Document_title_lists
     * const count = await prisma.document_title_lists.count({
     *   where: {
     *     // ... the filter for the Document_title_lists we want to count
     *   }
     * })
    **/
    count<T extends document_title_listsCountArgs>(
      args?: Subset<T, document_title_listsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Document_title_listsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Document_title_lists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Document_title_listsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Document_title_listsAggregateArgs>(args: Subset<T, Document_title_listsAggregateArgs>): Prisma.PrismaPromise<GetDocument_title_listsAggregateType<T>>

    /**
     * Group by Document_title_lists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {document_title_listsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends document_title_listsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: document_title_listsGroupByArgs['orderBy'] }
        : { orderBy?: document_title_listsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, document_title_listsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocument_title_listsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the document_title_lists model
   */
  readonly fields: document_title_listsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for document_title_lists.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__document_title_listsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the document_title_lists model
   */
  interface document_title_listsFieldRefs {
    readonly id: FieldRef<"document_title_lists", 'String'>
    readonly docType: FieldRef<"document_title_lists", 'document_title_lists_docType'>
    readonly title: FieldRef<"document_title_lists", 'String'>
    readonly note: FieldRef<"document_title_lists", 'String'>
    readonly createdAt: FieldRef<"document_title_lists", 'DateTime'>
    readonly updatedAt: FieldRef<"document_title_lists", 'DateTime'>
    readonly deletedAt: FieldRef<"document_title_lists", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * document_title_lists findUnique
   */
  export type document_title_listsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the document_title_lists
     */
    select?: document_title_listsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the document_title_lists
     */
    omit?: document_title_listsOmit<ExtArgs> | null
    /**
     * Filter, which document_title_lists to fetch.
     */
    where: document_title_listsWhereUniqueInput
  }

  /**
   * document_title_lists findUniqueOrThrow
   */
  export type document_title_listsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the document_title_lists
     */
    select?: document_title_listsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the document_title_lists
     */
    omit?: document_title_listsOmit<ExtArgs> | null
    /**
     * Filter, which document_title_lists to fetch.
     */
    where: document_title_listsWhereUniqueInput
  }

  /**
   * document_title_lists findFirst
   */
  export type document_title_listsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the document_title_lists
     */
    select?: document_title_listsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the document_title_lists
     */
    omit?: document_title_listsOmit<ExtArgs> | null
    /**
     * Filter, which document_title_lists to fetch.
     */
    where?: document_title_listsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of document_title_lists to fetch.
     */
    orderBy?: document_title_listsOrderByWithRelationInput | document_title_listsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for document_title_lists.
     */
    cursor?: document_title_listsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` document_title_lists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` document_title_lists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of document_title_lists.
     */
    distinct?: Document_title_listsScalarFieldEnum | Document_title_listsScalarFieldEnum[]
  }

  /**
   * document_title_lists findFirstOrThrow
   */
  export type document_title_listsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the document_title_lists
     */
    select?: document_title_listsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the document_title_lists
     */
    omit?: document_title_listsOmit<ExtArgs> | null
    /**
     * Filter, which document_title_lists to fetch.
     */
    where?: document_title_listsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of document_title_lists to fetch.
     */
    orderBy?: document_title_listsOrderByWithRelationInput | document_title_listsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for document_title_lists.
     */
    cursor?: document_title_listsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` document_title_lists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` document_title_lists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of document_title_lists.
     */
    distinct?: Document_title_listsScalarFieldEnum | Document_title_listsScalarFieldEnum[]
  }

  /**
   * document_title_lists findMany
   */
  export type document_title_listsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the document_title_lists
     */
    select?: document_title_listsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the document_title_lists
     */
    omit?: document_title_listsOmit<ExtArgs> | null
    /**
     * Filter, which document_title_lists to fetch.
     */
    where?: document_title_listsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of document_title_lists to fetch.
     */
    orderBy?: document_title_listsOrderByWithRelationInput | document_title_listsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing document_title_lists.
     */
    cursor?: document_title_listsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` document_title_lists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` document_title_lists.
     */
    skip?: number
    distinct?: Document_title_listsScalarFieldEnum | Document_title_listsScalarFieldEnum[]
  }

  /**
   * document_title_lists create
   */
  export type document_title_listsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the document_title_lists
     */
    select?: document_title_listsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the document_title_lists
     */
    omit?: document_title_listsOmit<ExtArgs> | null
    /**
     * The data needed to create a document_title_lists.
     */
    data: XOR<document_title_listsCreateInput, document_title_listsUncheckedCreateInput>
  }

  /**
   * document_title_lists createMany
   */
  export type document_title_listsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many document_title_lists.
     */
    data: document_title_listsCreateManyInput | document_title_listsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * document_title_lists update
   */
  export type document_title_listsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the document_title_lists
     */
    select?: document_title_listsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the document_title_lists
     */
    omit?: document_title_listsOmit<ExtArgs> | null
    /**
     * The data needed to update a document_title_lists.
     */
    data: XOR<document_title_listsUpdateInput, document_title_listsUncheckedUpdateInput>
    /**
     * Choose, which document_title_lists to update.
     */
    where: document_title_listsWhereUniqueInput
  }

  /**
   * document_title_lists updateMany
   */
  export type document_title_listsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update document_title_lists.
     */
    data: XOR<document_title_listsUpdateManyMutationInput, document_title_listsUncheckedUpdateManyInput>
    /**
     * Filter which document_title_lists to update
     */
    where?: document_title_listsWhereInput
    /**
     * Limit how many document_title_lists to update.
     */
    limit?: number
  }

  /**
   * document_title_lists upsert
   */
  export type document_title_listsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the document_title_lists
     */
    select?: document_title_listsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the document_title_lists
     */
    omit?: document_title_listsOmit<ExtArgs> | null
    /**
     * The filter to search for the document_title_lists to update in case it exists.
     */
    where: document_title_listsWhereUniqueInput
    /**
     * In case the document_title_lists found by the `where` argument doesn't exist, create a new document_title_lists with this data.
     */
    create: XOR<document_title_listsCreateInput, document_title_listsUncheckedCreateInput>
    /**
     * In case the document_title_lists was found with the provided `where` argument, update it with this data.
     */
    update: XOR<document_title_listsUpdateInput, document_title_listsUncheckedUpdateInput>
  }

  /**
   * document_title_lists delete
   */
  export type document_title_listsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the document_title_lists
     */
    select?: document_title_listsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the document_title_lists
     */
    omit?: document_title_listsOmit<ExtArgs> | null
    /**
     * Filter which document_title_lists to delete.
     */
    where: document_title_listsWhereUniqueInput
  }

  /**
   * document_title_lists deleteMany
   */
  export type document_title_listsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which document_title_lists to delete
     */
    where?: document_title_listsWhereInput
    /**
     * Limit how many document_title_lists to delete.
     */
    limit?: number
  }

  /**
   * document_title_lists without action
   */
  export type document_title_listsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the document_title_lists
     */
    select?: document_title_listsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the document_title_lists
     */
    omit?: document_title_listsOmit<ExtArgs> | null
  }


  /**
   * Model land_accounts
   */

  export type AggregateLand_accounts = {
    _count: Land_accountsCountAggregateOutputType | null
    _avg: Land_accountsAvgAggregateOutputType | null
    _sum: Land_accountsSumAggregateOutputType | null
    _min: Land_accountsMinAggregateOutputType | null
    _max: Land_accountsMaxAggregateOutputType | null
  }

  export type Land_accountsAvgAggregateOutputType = {
    accountBalance: Decimal | null
  }

  export type Land_accountsSumAggregateOutputType = {
    accountBalance: Decimal | null
  }

  export type Land_accountsMinAggregateOutputType = {
    id: string | null
    accountName: string | null
    accountBalance: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type Land_accountsMaxAggregateOutputType = {
    id: string | null
    accountName: string | null
    accountBalance: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type Land_accountsCountAggregateOutputType = {
    id: number
    accountName: number
    accountBalance: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type Land_accountsAvgAggregateInputType = {
    accountBalance?: true
  }

  export type Land_accountsSumAggregateInputType = {
    accountBalance?: true
  }

  export type Land_accountsMinAggregateInputType = {
    id?: true
    accountName?: true
    accountBalance?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type Land_accountsMaxAggregateInputType = {
    id?: true
    accountName?: true
    accountBalance?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type Land_accountsCountAggregateInputType = {
    id?: true
    accountName?: true
    accountBalance?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type Land_accountsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which land_accounts to aggregate.
     */
    where?: land_accountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of land_accounts to fetch.
     */
    orderBy?: land_accountsOrderByWithRelationInput | land_accountsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: land_accountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` land_accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` land_accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned land_accounts
    **/
    _count?: true | Land_accountsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Land_accountsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Land_accountsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Land_accountsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Land_accountsMaxAggregateInputType
  }

  export type GetLand_accountsAggregateType<T extends Land_accountsAggregateArgs> = {
        [P in keyof T & keyof AggregateLand_accounts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLand_accounts[P]>
      : GetScalarType<T[P], AggregateLand_accounts[P]>
  }




  export type land_accountsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: land_accountsWhereInput
    orderBy?: land_accountsOrderByWithAggregationInput | land_accountsOrderByWithAggregationInput[]
    by: Land_accountsScalarFieldEnum[] | Land_accountsScalarFieldEnum
    having?: land_accountsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Land_accountsCountAggregateInputType | true
    _avg?: Land_accountsAvgAggregateInputType
    _sum?: Land_accountsSumAggregateInputType
    _min?: Land_accountsMinAggregateInputType
    _max?: Land_accountsMaxAggregateInputType
  }

  export type Land_accountsGroupByOutputType = {
    id: string
    accountName: string
    accountBalance: Decimal
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: Land_accountsCountAggregateOutputType | null
    _avg: Land_accountsAvgAggregateOutputType | null
    _sum: Land_accountsSumAggregateOutputType | null
    _min: Land_accountsMinAggregateOutputType | null
    _max: Land_accountsMaxAggregateOutputType | null
  }

  type GetLand_accountsGroupByPayload<T extends land_accountsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Land_accountsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Land_accountsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Land_accountsGroupByOutputType[P]>
            : GetScalarType<T[P], Land_accountsGroupByOutputType[P]>
        }
      >
    >


  export type land_accountsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountName?: boolean
    accountBalance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    logs?: boolean | land_accounts$logsArgs<ExtArgs>
    reports?: boolean | land_accounts$reportsArgs<ExtArgs>
    _count?: boolean | Land_accountsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["land_accounts"]>



  export type land_accountsSelectScalar = {
    id?: boolean
    accountName?: boolean
    accountBalance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type land_accountsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "accountName" | "accountBalance" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["land_accounts"]>
  export type land_accountsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    logs?: boolean | land_accounts$logsArgs<ExtArgs>
    reports?: boolean | land_accounts$reportsArgs<ExtArgs>
    _count?: boolean | Land_accountsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $land_accountsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "land_accounts"
    objects: {
      logs: Prisma.$land_account_logsPayload<ExtArgs>[]
      reports: Prisma.$land_account_reportsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      accountName: string
      accountBalance: Prisma.Decimal
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["land_accounts"]>
    composites: {}
  }

  type land_accountsGetPayload<S extends boolean | null | undefined | land_accountsDefaultArgs> = $Result.GetResult<Prisma.$land_accountsPayload, S>

  type land_accountsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<land_accountsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Land_accountsCountAggregateInputType | true
    }

  export interface land_accountsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['land_accounts'], meta: { name: 'land_accounts' } }
    /**
     * Find zero or one Land_accounts that matches the filter.
     * @param {land_accountsFindUniqueArgs} args - Arguments to find a Land_accounts
     * @example
     * // Get one Land_accounts
     * const land_accounts = await prisma.land_accounts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends land_accountsFindUniqueArgs>(args: SelectSubset<T, land_accountsFindUniqueArgs<ExtArgs>>): Prisma__land_accountsClient<$Result.GetResult<Prisma.$land_accountsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Land_accounts that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {land_accountsFindUniqueOrThrowArgs} args - Arguments to find a Land_accounts
     * @example
     * // Get one Land_accounts
     * const land_accounts = await prisma.land_accounts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends land_accountsFindUniqueOrThrowArgs>(args: SelectSubset<T, land_accountsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__land_accountsClient<$Result.GetResult<Prisma.$land_accountsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Land_accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {land_accountsFindFirstArgs} args - Arguments to find a Land_accounts
     * @example
     * // Get one Land_accounts
     * const land_accounts = await prisma.land_accounts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends land_accountsFindFirstArgs>(args?: SelectSubset<T, land_accountsFindFirstArgs<ExtArgs>>): Prisma__land_accountsClient<$Result.GetResult<Prisma.$land_accountsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Land_accounts that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {land_accountsFindFirstOrThrowArgs} args - Arguments to find a Land_accounts
     * @example
     * // Get one Land_accounts
     * const land_accounts = await prisma.land_accounts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends land_accountsFindFirstOrThrowArgs>(args?: SelectSubset<T, land_accountsFindFirstOrThrowArgs<ExtArgs>>): Prisma__land_accountsClient<$Result.GetResult<Prisma.$land_accountsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Land_accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {land_accountsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Land_accounts
     * const land_accounts = await prisma.land_accounts.findMany()
     * 
     * // Get first 10 Land_accounts
     * const land_accounts = await prisma.land_accounts.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const land_accountsWithIdOnly = await prisma.land_accounts.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends land_accountsFindManyArgs>(args?: SelectSubset<T, land_accountsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$land_accountsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Land_accounts.
     * @param {land_accountsCreateArgs} args - Arguments to create a Land_accounts.
     * @example
     * // Create one Land_accounts
     * const Land_accounts = await prisma.land_accounts.create({
     *   data: {
     *     // ... data to create a Land_accounts
     *   }
     * })
     * 
     */
    create<T extends land_accountsCreateArgs>(args: SelectSubset<T, land_accountsCreateArgs<ExtArgs>>): Prisma__land_accountsClient<$Result.GetResult<Prisma.$land_accountsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Land_accounts.
     * @param {land_accountsCreateManyArgs} args - Arguments to create many Land_accounts.
     * @example
     * // Create many Land_accounts
     * const land_accounts = await prisma.land_accounts.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends land_accountsCreateManyArgs>(args?: SelectSubset<T, land_accountsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Land_accounts.
     * @param {land_accountsDeleteArgs} args - Arguments to delete one Land_accounts.
     * @example
     * // Delete one Land_accounts
     * const Land_accounts = await prisma.land_accounts.delete({
     *   where: {
     *     // ... filter to delete one Land_accounts
     *   }
     * })
     * 
     */
    delete<T extends land_accountsDeleteArgs>(args: SelectSubset<T, land_accountsDeleteArgs<ExtArgs>>): Prisma__land_accountsClient<$Result.GetResult<Prisma.$land_accountsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Land_accounts.
     * @param {land_accountsUpdateArgs} args - Arguments to update one Land_accounts.
     * @example
     * // Update one Land_accounts
     * const land_accounts = await prisma.land_accounts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends land_accountsUpdateArgs>(args: SelectSubset<T, land_accountsUpdateArgs<ExtArgs>>): Prisma__land_accountsClient<$Result.GetResult<Prisma.$land_accountsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Land_accounts.
     * @param {land_accountsDeleteManyArgs} args - Arguments to filter Land_accounts to delete.
     * @example
     * // Delete a few Land_accounts
     * const { count } = await prisma.land_accounts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends land_accountsDeleteManyArgs>(args?: SelectSubset<T, land_accountsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Land_accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {land_accountsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Land_accounts
     * const land_accounts = await prisma.land_accounts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends land_accountsUpdateManyArgs>(args: SelectSubset<T, land_accountsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Land_accounts.
     * @param {land_accountsUpsertArgs} args - Arguments to update or create a Land_accounts.
     * @example
     * // Update or create a Land_accounts
     * const land_accounts = await prisma.land_accounts.upsert({
     *   create: {
     *     // ... data to create a Land_accounts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Land_accounts we want to update
     *   }
     * })
     */
    upsert<T extends land_accountsUpsertArgs>(args: SelectSubset<T, land_accountsUpsertArgs<ExtArgs>>): Prisma__land_accountsClient<$Result.GetResult<Prisma.$land_accountsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Land_accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {land_accountsCountArgs} args - Arguments to filter Land_accounts to count.
     * @example
     * // Count the number of Land_accounts
     * const count = await prisma.land_accounts.count({
     *   where: {
     *     // ... the filter for the Land_accounts we want to count
     *   }
     * })
    **/
    count<T extends land_accountsCountArgs>(
      args?: Subset<T, land_accountsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Land_accountsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Land_accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Land_accountsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Land_accountsAggregateArgs>(args: Subset<T, Land_accountsAggregateArgs>): Prisma.PrismaPromise<GetLand_accountsAggregateType<T>>

    /**
     * Group by Land_accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {land_accountsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends land_accountsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: land_accountsGroupByArgs['orderBy'] }
        : { orderBy?: land_accountsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, land_accountsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLand_accountsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the land_accounts model
   */
  readonly fields: land_accountsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for land_accounts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__land_accountsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    logs<T extends land_accounts$logsArgs<ExtArgs> = {}>(args?: Subset<T, land_accounts$logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$land_account_logsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reports<T extends land_accounts$reportsArgs<ExtArgs> = {}>(args?: Subset<T, land_accounts$reportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$land_account_reportsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the land_accounts model
   */
  interface land_accountsFieldRefs {
    readonly id: FieldRef<"land_accounts", 'String'>
    readonly accountName: FieldRef<"land_accounts", 'String'>
    readonly accountBalance: FieldRef<"land_accounts", 'Decimal'>
    readonly createdAt: FieldRef<"land_accounts", 'DateTime'>
    readonly updatedAt: FieldRef<"land_accounts", 'DateTime'>
    readonly deletedAt: FieldRef<"land_accounts", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * land_accounts findUnique
   */
  export type land_accountsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the land_accounts
     */
    select?: land_accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the land_accounts
     */
    omit?: land_accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: land_accountsInclude<ExtArgs> | null
    /**
     * Filter, which land_accounts to fetch.
     */
    where: land_accountsWhereUniqueInput
  }

  /**
   * land_accounts findUniqueOrThrow
   */
  export type land_accountsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the land_accounts
     */
    select?: land_accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the land_accounts
     */
    omit?: land_accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: land_accountsInclude<ExtArgs> | null
    /**
     * Filter, which land_accounts to fetch.
     */
    where: land_accountsWhereUniqueInput
  }

  /**
   * land_accounts findFirst
   */
  export type land_accountsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the land_accounts
     */
    select?: land_accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the land_accounts
     */
    omit?: land_accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: land_accountsInclude<ExtArgs> | null
    /**
     * Filter, which land_accounts to fetch.
     */
    where?: land_accountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of land_accounts to fetch.
     */
    orderBy?: land_accountsOrderByWithRelationInput | land_accountsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for land_accounts.
     */
    cursor?: land_accountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` land_accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` land_accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of land_accounts.
     */
    distinct?: Land_accountsScalarFieldEnum | Land_accountsScalarFieldEnum[]
  }

  /**
   * land_accounts findFirstOrThrow
   */
  export type land_accountsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the land_accounts
     */
    select?: land_accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the land_accounts
     */
    omit?: land_accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: land_accountsInclude<ExtArgs> | null
    /**
     * Filter, which land_accounts to fetch.
     */
    where?: land_accountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of land_accounts to fetch.
     */
    orderBy?: land_accountsOrderByWithRelationInput | land_accountsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for land_accounts.
     */
    cursor?: land_accountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` land_accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` land_accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of land_accounts.
     */
    distinct?: Land_accountsScalarFieldEnum | Land_accountsScalarFieldEnum[]
  }

  /**
   * land_accounts findMany
   */
  export type land_accountsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the land_accounts
     */
    select?: land_accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the land_accounts
     */
    omit?: land_accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: land_accountsInclude<ExtArgs> | null
    /**
     * Filter, which land_accounts to fetch.
     */
    where?: land_accountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of land_accounts to fetch.
     */
    orderBy?: land_accountsOrderByWithRelationInput | land_accountsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing land_accounts.
     */
    cursor?: land_accountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` land_accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` land_accounts.
     */
    skip?: number
    distinct?: Land_accountsScalarFieldEnum | Land_accountsScalarFieldEnum[]
  }

  /**
   * land_accounts create
   */
  export type land_accountsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the land_accounts
     */
    select?: land_accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the land_accounts
     */
    omit?: land_accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: land_accountsInclude<ExtArgs> | null
    /**
     * The data needed to create a land_accounts.
     */
    data: XOR<land_accountsCreateInput, land_accountsUncheckedCreateInput>
  }

  /**
   * land_accounts createMany
   */
  export type land_accountsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many land_accounts.
     */
    data: land_accountsCreateManyInput | land_accountsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * land_accounts update
   */
  export type land_accountsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the land_accounts
     */
    select?: land_accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the land_accounts
     */
    omit?: land_accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: land_accountsInclude<ExtArgs> | null
    /**
     * The data needed to update a land_accounts.
     */
    data: XOR<land_accountsUpdateInput, land_accountsUncheckedUpdateInput>
    /**
     * Choose, which land_accounts to update.
     */
    where: land_accountsWhereUniqueInput
  }

  /**
   * land_accounts updateMany
   */
  export type land_accountsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update land_accounts.
     */
    data: XOR<land_accountsUpdateManyMutationInput, land_accountsUncheckedUpdateManyInput>
    /**
     * Filter which land_accounts to update
     */
    where?: land_accountsWhereInput
    /**
     * Limit how many land_accounts to update.
     */
    limit?: number
  }

  /**
   * land_accounts upsert
   */
  export type land_accountsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the land_accounts
     */
    select?: land_accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the land_accounts
     */
    omit?: land_accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: land_accountsInclude<ExtArgs> | null
    /**
     * The filter to search for the land_accounts to update in case it exists.
     */
    where: land_accountsWhereUniqueInput
    /**
     * In case the land_accounts found by the `where` argument doesn't exist, create a new land_accounts with this data.
     */
    create: XOR<land_accountsCreateInput, land_accountsUncheckedCreateInput>
    /**
     * In case the land_accounts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<land_accountsUpdateInput, land_accountsUncheckedUpdateInput>
  }

  /**
   * land_accounts delete
   */
  export type land_accountsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the land_accounts
     */
    select?: land_accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the land_accounts
     */
    omit?: land_accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: land_accountsInclude<ExtArgs> | null
    /**
     * Filter which land_accounts to delete.
     */
    where: land_accountsWhereUniqueInput
  }

  /**
   * land_accounts deleteMany
   */
  export type land_accountsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which land_accounts to delete
     */
    where?: land_accountsWhereInput
    /**
     * Limit how many land_accounts to delete.
     */
    limit?: number
  }

  /**
   * land_accounts.logs
   */
  export type land_accounts$logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the land_account_logs
     */
    select?: land_account_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the land_account_logs
     */
    omit?: land_account_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: land_account_logsInclude<ExtArgs> | null
    where?: land_account_logsWhereInput
    orderBy?: land_account_logsOrderByWithRelationInput | land_account_logsOrderByWithRelationInput[]
    cursor?: land_account_logsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Land_account_logsScalarFieldEnum | Land_account_logsScalarFieldEnum[]
  }

  /**
   * land_accounts.reports
   */
  export type land_accounts$reportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the land_account_reports
     */
    select?: land_account_reportsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the land_account_reports
     */
    omit?: land_account_reportsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: land_account_reportsInclude<ExtArgs> | null
    where?: land_account_reportsWhereInput
    orderBy?: land_account_reportsOrderByWithRelationInput | land_account_reportsOrderByWithRelationInput[]
    cursor?: land_account_reportsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Land_account_reportsScalarFieldEnum | Land_account_reportsScalarFieldEnum[]
  }

  /**
   * land_accounts without action
   */
  export type land_accountsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the land_accounts
     */
    select?: land_accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the land_accounts
     */
    omit?: land_accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: land_accountsInclude<ExtArgs> | null
  }


  /**
   * Model land_account_logs
   */

  export type AggregateLand_account_logs = {
    _count: Land_account_logsCountAggregateOutputType | null
    _avg: Land_account_logsAvgAggregateOutputType | null
    _sum: Land_account_logsSumAggregateOutputType | null
    _min: Land_account_logsMinAggregateOutputType | null
    _max: Land_account_logsMaxAggregateOutputType | null
  }

  export type Land_account_logsAvgAggregateOutputType = {
    amount: Decimal | null
    employeeId: number | null
  }

  export type Land_account_logsSumAggregateOutputType = {
    amount: Decimal | null
    employeeId: number | null
  }

  export type Land_account_logsMinAggregateOutputType = {
    id: string | null
    landAccountId: string | null
    detail: string | null
    amount: Decimal | null
    note: string | null
    employeeId: number | null
    employeeName: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type Land_account_logsMaxAggregateOutputType = {
    id: string | null
    landAccountId: string | null
    detail: string | null
    amount: Decimal | null
    note: string | null
    employeeId: number | null
    employeeName: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type Land_account_logsCountAggregateOutputType = {
    id: number
    landAccountId: number
    detail: number
    amount: number
    note: number
    employeeId: number
    employeeName: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type Land_account_logsAvgAggregateInputType = {
    amount?: true
    employeeId?: true
  }

  export type Land_account_logsSumAggregateInputType = {
    amount?: true
    employeeId?: true
  }

  export type Land_account_logsMinAggregateInputType = {
    id?: true
    landAccountId?: true
    detail?: true
    amount?: true
    note?: true
    employeeId?: true
    employeeName?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type Land_account_logsMaxAggregateInputType = {
    id?: true
    landAccountId?: true
    detail?: true
    amount?: true
    note?: true
    employeeId?: true
    employeeName?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type Land_account_logsCountAggregateInputType = {
    id?: true
    landAccountId?: true
    detail?: true
    amount?: true
    note?: true
    employeeId?: true
    employeeName?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type Land_account_logsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which land_account_logs to aggregate.
     */
    where?: land_account_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of land_account_logs to fetch.
     */
    orderBy?: land_account_logsOrderByWithRelationInput | land_account_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: land_account_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` land_account_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` land_account_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned land_account_logs
    **/
    _count?: true | Land_account_logsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Land_account_logsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Land_account_logsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Land_account_logsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Land_account_logsMaxAggregateInputType
  }

  export type GetLand_account_logsAggregateType<T extends Land_account_logsAggregateArgs> = {
        [P in keyof T & keyof AggregateLand_account_logs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLand_account_logs[P]>
      : GetScalarType<T[P], AggregateLand_account_logs[P]>
  }




  export type land_account_logsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: land_account_logsWhereInput
    orderBy?: land_account_logsOrderByWithAggregationInput | land_account_logsOrderByWithAggregationInput[]
    by: Land_account_logsScalarFieldEnum[] | Land_account_logsScalarFieldEnum
    having?: land_account_logsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Land_account_logsCountAggregateInputType | true
    _avg?: Land_account_logsAvgAggregateInputType
    _sum?: Land_account_logsSumAggregateInputType
    _min?: Land_account_logsMinAggregateInputType
    _max?: Land_account_logsMaxAggregateInputType
  }

  export type Land_account_logsGroupByOutputType = {
    id: string
    landAccountId: string
    detail: string
    amount: Decimal
    note: string | null
    employeeId: number
    employeeName: string | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: Land_account_logsCountAggregateOutputType | null
    _avg: Land_account_logsAvgAggregateOutputType | null
    _sum: Land_account_logsSumAggregateOutputType | null
    _min: Land_account_logsMinAggregateOutputType | null
    _max: Land_account_logsMaxAggregateOutputType | null
  }

  type GetLand_account_logsGroupByPayload<T extends land_account_logsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Land_account_logsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Land_account_logsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Land_account_logsGroupByOutputType[P]>
            : GetScalarType<T[P], Land_account_logsGroupByOutputType[P]>
        }
      >
    >


  export type land_account_logsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    landAccountId?: boolean
    detail?: boolean
    amount?: boolean
    note?: boolean
    employeeId?: boolean
    employeeName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    landAccount?: boolean | land_accountsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["land_account_logs"]>



  export type land_account_logsSelectScalar = {
    id?: boolean
    landAccountId?: boolean
    detail?: boolean
    amount?: boolean
    note?: boolean
    employeeId?: boolean
    employeeName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type land_account_logsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "landAccountId" | "detail" | "amount" | "note" | "employeeId" | "employeeName" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["land_account_logs"]>
  export type land_account_logsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    landAccount?: boolean | land_accountsDefaultArgs<ExtArgs>
  }

  export type $land_account_logsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "land_account_logs"
    objects: {
      landAccount: Prisma.$land_accountsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      landAccountId: string
      detail: string
      amount: Prisma.Decimal
      note: string | null
      employeeId: number
      employeeName: string | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["land_account_logs"]>
    composites: {}
  }

  type land_account_logsGetPayload<S extends boolean | null | undefined | land_account_logsDefaultArgs> = $Result.GetResult<Prisma.$land_account_logsPayload, S>

  type land_account_logsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<land_account_logsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Land_account_logsCountAggregateInputType | true
    }

  export interface land_account_logsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['land_account_logs'], meta: { name: 'land_account_logs' } }
    /**
     * Find zero or one Land_account_logs that matches the filter.
     * @param {land_account_logsFindUniqueArgs} args - Arguments to find a Land_account_logs
     * @example
     * // Get one Land_account_logs
     * const land_account_logs = await prisma.land_account_logs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends land_account_logsFindUniqueArgs>(args: SelectSubset<T, land_account_logsFindUniqueArgs<ExtArgs>>): Prisma__land_account_logsClient<$Result.GetResult<Prisma.$land_account_logsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Land_account_logs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {land_account_logsFindUniqueOrThrowArgs} args - Arguments to find a Land_account_logs
     * @example
     * // Get one Land_account_logs
     * const land_account_logs = await prisma.land_account_logs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends land_account_logsFindUniqueOrThrowArgs>(args: SelectSubset<T, land_account_logsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__land_account_logsClient<$Result.GetResult<Prisma.$land_account_logsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Land_account_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {land_account_logsFindFirstArgs} args - Arguments to find a Land_account_logs
     * @example
     * // Get one Land_account_logs
     * const land_account_logs = await prisma.land_account_logs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends land_account_logsFindFirstArgs>(args?: SelectSubset<T, land_account_logsFindFirstArgs<ExtArgs>>): Prisma__land_account_logsClient<$Result.GetResult<Prisma.$land_account_logsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Land_account_logs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {land_account_logsFindFirstOrThrowArgs} args - Arguments to find a Land_account_logs
     * @example
     * // Get one Land_account_logs
     * const land_account_logs = await prisma.land_account_logs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends land_account_logsFindFirstOrThrowArgs>(args?: SelectSubset<T, land_account_logsFindFirstOrThrowArgs<ExtArgs>>): Prisma__land_account_logsClient<$Result.GetResult<Prisma.$land_account_logsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Land_account_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {land_account_logsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Land_account_logs
     * const land_account_logs = await prisma.land_account_logs.findMany()
     * 
     * // Get first 10 Land_account_logs
     * const land_account_logs = await prisma.land_account_logs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const land_account_logsWithIdOnly = await prisma.land_account_logs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends land_account_logsFindManyArgs>(args?: SelectSubset<T, land_account_logsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$land_account_logsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Land_account_logs.
     * @param {land_account_logsCreateArgs} args - Arguments to create a Land_account_logs.
     * @example
     * // Create one Land_account_logs
     * const Land_account_logs = await prisma.land_account_logs.create({
     *   data: {
     *     // ... data to create a Land_account_logs
     *   }
     * })
     * 
     */
    create<T extends land_account_logsCreateArgs>(args: SelectSubset<T, land_account_logsCreateArgs<ExtArgs>>): Prisma__land_account_logsClient<$Result.GetResult<Prisma.$land_account_logsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Land_account_logs.
     * @param {land_account_logsCreateManyArgs} args - Arguments to create many Land_account_logs.
     * @example
     * // Create many Land_account_logs
     * const land_account_logs = await prisma.land_account_logs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends land_account_logsCreateManyArgs>(args?: SelectSubset<T, land_account_logsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Land_account_logs.
     * @param {land_account_logsDeleteArgs} args - Arguments to delete one Land_account_logs.
     * @example
     * // Delete one Land_account_logs
     * const Land_account_logs = await prisma.land_account_logs.delete({
     *   where: {
     *     // ... filter to delete one Land_account_logs
     *   }
     * })
     * 
     */
    delete<T extends land_account_logsDeleteArgs>(args: SelectSubset<T, land_account_logsDeleteArgs<ExtArgs>>): Prisma__land_account_logsClient<$Result.GetResult<Prisma.$land_account_logsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Land_account_logs.
     * @param {land_account_logsUpdateArgs} args - Arguments to update one Land_account_logs.
     * @example
     * // Update one Land_account_logs
     * const land_account_logs = await prisma.land_account_logs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends land_account_logsUpdateArgs>(args: SelectSubset<T, land_account_logsUpdateArgs<ExtArgs>>): Prisma__land_account_logsClient<$Result.GetResult<Prisma.$land_account_logsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Land_account_logs.
     * @param {land_account_logsDeleteManyArgs} args - Arguments to filter Land_account_logs to delete.
     * @example
     * // Delete a few Land_account_logs
     * const { count } = await prisma.land_account_logs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends land_account_logsDeleteManyArgs>(args?: SelectSubset<T, land_account_logsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Land_account_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {land_account_logsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Land_account_logs
     * const land_account_logs = await prisma.land_account_logs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends land_account_logsUpdateManyArgs>(args: SelectSubset<T, land_account_logsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Land_account_logs.
     * @param {land_account_logsUpsertArgs} args - Arguments to update or create a Land_account_logs.
     * @example
     * // Update or create a Land_account_logs
     * const land_account_logs = await prisma.land_account_logs.upsert({
     *   create: {
     *     // ... data to create a Land_account_logs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Land_account_logs we want to update
     *   }
     * })
     */
    upsert<T extends land_account_logsUpsertArgs>(args: SelectSubset<T, land_account_logsUpsertArgs<ExtArgs>>): Prisma__land_account_logsClient<$Result.GetResult<Prisma.$land_account_logsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Land_account_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {land_account_logsCountArgs} args - Arguments to filter Land_account_logs to count.
     * @example
     * // Count the number of Land_account_logs
     * const count = await prisma.land_account_logs.count({
     *   where: {
     *     // ... the filter for the Land_account_logs we want to count
     *   }
     * })
    **/
    count<T extends land_account_logsCountArgs>(
      args?: Subset<T, land_account_logsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Land_account_logsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Land_account_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Land_account_logsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Land_account_logsAggregateArgs>(args: Subset<T, Land_account_logsAggregateArgs>): Prisma.PrismaPromise<GetLand_account_logsAggregateType<T>>

    /**
     * Group by Land_account_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {land_account_logsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends land_account_logsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: land_account_logsGroupByArgs['orderBy'] }
        : { orderBy?: land_account_logsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, land_account_logsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLand_account_logsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the land_account_logs model
   */
  readonly fields: land_account_logsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for land_account_logs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__land_account_logsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    landAccount<T extends land_accountsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, land_accountsDefaultArgs<ExtArgs>>): Prisma__land_accountsClient<$Result.GetResult<Prisma.$land_accountsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the land_account_logs model
   */
  interface land_account_logsFieldRefs {
    readonly id: FieldRef<"land_account_logs", 'String'>
    readonly landAccountId: FieldRef<"land_account_logs", 'String'>
    readonly detail: FieldRef<"land_account_logs", 'String'>
    readonly amount: FieldRef<"land_account_logs", 'Decimal'>
    readonly note: FieldRef<"land_account_logs", 'String'>
    readonly employeeId: FieldRef<"land_account_logs", 'Int'>
    readonly employeeName: FieldRef<"land_account_logs", 'String'>
    readonly createdAt: FieldRef<"land_account_logs", 'DateTime'>
    readonly updatedAt: FieldRef<"land_account_logs", 'DateTime'>
    readonly deletedAt: FieldRef<"land_account_logs", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * land_account_logs findUnique
   */
  export type land_account_logsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the land_account_logs
     */
    select?: land_account_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the land_account_logs
     */
    omit?: land_account_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: land_account_logsInclude<ExtArgs> | null
    /**
     * Filter, which land_account_logs to fetch.
     */
    where: land_account_logsWhereUniqueInput
  }

  /**
   * land_account_logs findUniqueOrThrow
   */
  export type land_account_logsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the land_account_logs
     */
    select?: land_account_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the land_account_logs
     */
    omit?: land_account_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: land_account_logsInclude<ExtArgs> | null
    /**
     * Filter, which land_account_logs to fetch.
     */
    where: land_account_logsWhereUniqueInput
  }

  /**
   * land_account_logs findFirst
   */
  export type land_account_logsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the land_account_logs
     */
    select?: land_account_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the land_account_logs
     */
    omit?: land_account_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: land_account_logsInclude<ExtArgs> | null
    /**
     * Filter, which land_account_logs to fetch.
     */
    where?: land_account_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of land_account_logs to fetch.
     */
    orderBy?: land_account_logsOrderByWithRelationInput | land_account_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for land_account_logs.
     */
    cursor?: land_account_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` land_account_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` land_account_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of land_account_logs.
     */
    distinct?: Land_account_logsScalarFieldEnum | Land_account_logsScalarFieldEnum[]
  }

  /**
   * land_account_logs findFirstOrThrow
   */
  export type land_account_logsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the land_account_logs
     */
    select?: land_account_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the land_account_logs
     */
    omit?: land_account_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: land_account_logsInclude<ExtArgs> | null
    /**
     * Filter, which land_account_logs to fetch.
     */
    where?: land_account_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of land_account_logs to fetch.
     */
    orderBy?: land_account_logsOrderByWithRelationInput | land_account_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for land_account_logs.
     */
    cursor?: land_account_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` land_account_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` land_account_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of land_account_logs.
     */
    distinct?: Land_account_logsScalarFieldEnum | Land_account_logsScalarFieldEnum[]
  }

  /**
   * land_account_logs findMany
   */
  export type land_account_logsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the land_account_logs
     */
    select?: land_account_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the land_account_logs
     */
    omit?: land_account_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: land_account_logsInclude<ExtArgs> | null
    /**
     * Filter, which land_account_logs to fetch.
     */
    where?: land_account_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of land_account_logs to fetch.
     */
    orderBy?: land_account_logsOrderByWithRelationInput | land_account_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing land_account_logs.
     */
    cursor?: land_account_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` land_account_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` land_account_logs.
     */
    skip?: number
    distinct?: Land_account_logsScalarFieldEnum | Land_account_logsScalarFieldEnum[]
  }

  /**
   * land_account_logs create
   */
  export type land_account_logsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the land_account_logs
     */
    select?: land_account_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the land_account_logs
     */
    omit?: land_account_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: land_account_logsInclude<ExtArgs> | null
    /**
     * The data needed to create a land_account_logs.
     */
    data: XOR<land_account_logsCreateInput, land_account_logsUncheckedCreateInput>
  }

  /**
   * land_account_logs createMany
   */
  export type land_account_logsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many land_account_logs.
     */
    data: land_account_logsCreateManyInput | land_account_logsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * land_account_logs update
   */
  export type land_account_logsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the land_account_logs
     */
    select?: land_account_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the land_account_logs
     */
    omit?: land_account_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: land_account_logsInclude<ExtArgs> | null
    /**
     * The data needed to update a land_account_logs.
     */
    data: XOR<land_account_logsUpdateInput, land_account_logsUncheckedUpdateInput>
    /**
     * Choose, which land_account_logs to update.
     */
    where: land_account_logsWhereUniqueInput
  }

  /**
   * land_account_logs updateMany
   */
  export type land_account_logsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update land_account_logs.
     */
    data: XOR<land_account_logsUpdateManyMutationInput, land_account_logsUncheckedUpdateManyInput>
    /**
     * Filter which land_account_logs to update
     */
    where?: land_account_logsWhereInput
    /**
     * Limit how many land_account_logs to update.
     */
    limit?: number
  }

  /**
   * land_account_logs upsert
   */
  export type land_account_logsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the land_account_logs
     */
    select?: land_account_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the land_account_logs
     */
    omit?: land_account_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: land_account_logsInclude<ExtArgs> | null
    /**
     * The filter to search for the land_account_logs to update in case it exists.
     */
    where: land_account_logsWhereUniqueInput
    /**
     * In case the land_account_logs found by the `where` argument doesn't exist, create a new land_account_logs with this data.
     */
    create: XOR<land_account_logsCreateInput, land_account_logsUncheckedCreateInput>
    /**
     * In case the land_account_logs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<land_account_logsUpdateInput, land_account_logsUncheckedUpdateInput>
  }

  /**
   * land_account_logs delete
   */
  export type land_account_logsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the land_account_logs
     */
    select?: land_account_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the land_account_logs
     */
    omit?: land_account_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: land_account_logsInclude<ExtArgs> | null
    /**
     * Filter which land_account_logs to delete.
     */
    where: land_account_logsWhereUniqueInput
  }

  /**
   * land_account_logs deleteMany
   */
  export type land_account_logsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which land_account_logs to delete
     */
    where?: land_account_logsWhereInput
    /**
     * Limit how many land_account_logs to delete.
     */
    limit?: number
  }

  /**
   * land_account_logs without action
   */
  export type land_account_logsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the land_account_logs
     */
    select?: land_account_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the land_account_logs
     */
    omit?: land_account_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: land_account_logsInclude<ExtArgs> | null
  }


  /**
   * Model land_account_reports
   */

  export type AggregateLand_account_reports = {
    _count: Land_account_reportsCountAggregateOutputType | null
    _avg: Land_account_reportsAvgAggregateOutputType | null
    _sum: Land_account_reportsSumAggregateOutputType | null
    _min: Land_account_reportsMinAggregateOutputType | null
    _max: Land_account_reportsMaxAggregateOutputType | null
  }

  export type Land_account_reportsAvgAggregateOutputType = {
    amount: Decimal | null
    accountBalance: Decimal | null
    employeeId: number | null
  }

  export type Land_account_reportsSumAggregateOutputType = {
    amount: Decimal | null
    accountBalance: Decimal | null
    employeeId: number | null
  }

  export type Land_account_reportsMinAggregateOutputType = {
    id: string | null
    landAccountId: string | null
    detail: string | null
    amount: Decimal | null
    note: string | null
    accountBalance: Decimal | null
    employeeId: number | null
    employeeName: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type Land_account_reportsMaxAggregateOutputType = {
    id: string | null
    landAccountId: string | null
    detail: string | null
    amount: Decimal | null
    note: string | null
    accountBalance: Decimal | null
    employeeId: number | null
    employeeName: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type Land_account_reportsCountAggregateOutputType = {
    id: number
    landAccountId: number
    detail: number
    amount: number
    note: number
    accountBalance: number
    employeeId: number
    employeeName: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type Land_account_reportsAvgAggregateInputType = {
    amount?: true
    accountBalance?: true
    employeeId?: true
  }

  export type Land_account_reportsSumAggregateInputType = {
    amount?: true
    accountBalance?: true
    employeeId?: true
  }

  export type Land_account_reportsMinAggregateInputType = {
    id?: true
    landAccountId?: true
    detail?: true
    amount?: true
    note?: true
    accountBalance?: true
    employeeId?: true
    employeeName?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type Land_account_reportsMaxAggregateInputType = {
    id?: true
    landAccountId?: true
    detail?: true
    amount?: true
    note?: true
    accountBalance?: true
    employeeId?: true
    employeeName?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type Land_account_reportsCountAggregateInputType = {
    id?: true
    landAccountId?: true
    detail?: true
    amount?: true
    note?: true
    accountBalance?: true
    employeeId?: true
    employeeName?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type Land_account_reportsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which land_account_reports to aggregate.
     */
    where?: land_account_reportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of land_account_reports to fetch.
     */
    orderBy?: land_account_reportsOrderByWithRelationInput | land_account_reportsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: land_account_reportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` land_account_reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` land_account_reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned land_account_reports
    **/
    _count?: true | Land_account_reportsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Land_account_reportsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Land_account_reportsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Land_account_reportsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Land_account_reportsMaxAggregateInputType
  }

  export type GetLand_account_reportsAggregateType<T extends Land_account_reportsAggregateArgs> = {
        [P in keyof T & keyof AggregateLand_account_reports]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLand_account_reports[P]>
      : GetScalarType<T[P], AggregateLand_account_reports[P]>
  }




  export type land_account_reportsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: land_account_reportsWhereInput
    orderBy?: land_account_reportsOrderByWithAggregationInput | land_account_reportsOrderByWithAggregationInput[]
    by: Land_account_reportsScalarFieldEnum[] | Land_account_reportsScalarFieldEnum
    having?: land_account_reportsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Land_account_reportsCountAggregateInputType | true
    _avg?: Land_account_reportsAvgAggregateInputType
    _sum?: Land_account_reportsSumAggregateInputType
    _min?: Land_account_reportsMinAggregateInputType
    _max?: Land_account_reportsMaxAggregateInputType
  }

  export type Land_account_reportsGroupByOutputType = {
    id: string
    landAccountId: string
    detail: string
    amount: Decimal
    note: string | null
    accountBalance: Decimal | null
    employeeId: number
    employeeName: string | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: Land_account_reportsCountAggregateOutputType | null
    _avg: Land_account_reportsAvgAggregateOutputType | null
    _sum: Land_account_reportsSumAggregateOutputType | null
    _min: Land_account_reportsMinAggregateOutputType | null
    _max: Land_account_reportsMaxAggregateOutputType | null
  }

  type GetLand_account_reportsGroupByPayload<T extends land_account_reportsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Land_account_reportsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Land_account_reportsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Land_account_reportsGroupByOutputType[P]>
            : GetScalarType<T[P], Land_account_reportsGroupByOutputType[P]>
        }
      >
    >


  export type land_account_reportsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    landAccountId?: boolean
    detail?: boolean
    amount?: boolean
    note?: boolean
    accountBalance?: boolean
    employeeId?: boolean
    employeeName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    landAccount?: boolean | land_accountsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["land_account_reports"]>



  export type land_account_reportsSelectScalar = {
    id?: boolean
    landAccountId?: boolean
    detail?: boolean
    amount?: boolean
    note?: boolean
    accountBalance?: boolean
    employeeId?: boolean
    employeeName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type land_account_reportsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "landAccountId" | "detail" | "amount" | "note" | "accountBalance" | "employeeId" | "employeeName" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["land_account_reports"]>
  export type land_account_reportsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    landAccount?: boolean | land_accountsDefaultArgs<ExtArgs>
  }

  export type $land_account_reportsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "land_account_reports"
    objects: {
      landAccount: Prisma.$land_accountsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      landAccountId: string
      detail: string
      amount: Prisma.Decimal
      note: string | null
      accountBalance: Prisma.Decimal | null
      employeeId: number
      employeeName: string | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["land_account_reports"]>
    composites: {}
  }

  type land_account_reportsGetPayload<S extends boolean | null | undefined | land_account_reportsDefaultArgs> = $Result.GetResult<Prisma.$land_account_reportsPayload, S>

  type land_account_reportsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<land_account_reportsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Land_account_reportsCountAggregateInputType | true
    }

  export interface land_account_reportsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['land_account_reports'], meta: { name: 'land_account_reports' } }
    /**
     * Find zero or one Land_account_reports that matches the filter.
     * @param {land_account_reportsFindUniqueArgs} args - Arguments to find a Land_account_reports
     * @example
     * // Get one Land_account_reports
     * const land_account_reports = await prisma.land_account_reports.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends land_account_reportsFindUniqueArgs>(args: SelectSubset<T, land_account_reportsFindUniqueArgs<ExtArgs>>): Prisma__land_account_reportsClient<$Result.GetResult<Prisma.$land_account_reportsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Land_account_reports that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {land_account_reportsFindUniqueOrThrowArgs} args - Arguments to find a Land_account_reports
     * @example
     * // Get one Land_account_reports
     * const land_account_reports = await prisma.land_account_reports.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends land_account_reportsFindUniqueOrThrowArgs>(args: SelectSubset<T, land_account_reportsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__land_account_reportsClient<$Result.GetResult<Prisma.$land_account_reportsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Land_account_reports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {land_account_reportsFindFirstArgs} args - Arguments to find a Land_account_reports
     * @example
     * // Get one Land_account_reports
     * const land_account_reports = await prisma.land_account_reports.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends land_account_reportsFindFirstArgs>(args?: SelectSubset<T, land_account_reportsFindFirstArgs<ExtArgs>>): Prisma__land_account_reportsClient<$Result.GetResult<Prisma.$land_account_reportsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Land_account_reports that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {land_account_reportsFindFirstOrThrowArgs} args - Arguments to find a Land_account_reports
     * @example
     * // Get one Land_account_reports
     * const land_account_reports = await prisma.land_account_reports.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends land_account_reportsFindFirstOrThrowArgs>(args?: SelectSubset<T, land_account_reportsFindFirstOrThrowArgs<ExtArgs>>): Prisma__land_account_reportsClient<$Result.GetResult<Prisma.$land_account_reportsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Land_account_reports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {land_account_reportsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Land_account_reports
     * const land_account_reports = await prisma.land_account_reports.findMany()
     * 
     * // Get first 10 Land_account_reports
     * const land_account_reports = await prisma.land_account_reports.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const land_account_reportsWithIdOnly = await prisma.land_account_reports.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends land_account_reportsFindManyArgs>(args?: SelectSubset<T, land_account_reportsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$land_account_reportsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Land_account_reports.
     * @param {land_account_reportsCreateArgs} args - Arguments to create a Land_account_reports.
     * @example
     * // Create one Land_account_reports
     * const Land_account_reports = await prisma.land_account_reports.create({
     *   data: {
     *     // ... data to create a Land_account_reports
     *   }
     * })
     * 
     */
    create<T extends land_account_reportsCreateArgs>(args: SelectSubset<T, land_account_reportsCreateArgs<ExtArgs>>): Prisma__land_account_reportsClient<$Result.GetResult<Prisma.$land_account_reportsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Land_account_reports.
     * @param {land_account_reportsCreateManyArgs} args - Arguments to create many Land_account_reports.
     * @example
     * // Create many Land_account_reports
     * const land_account_reports = await prisma.land_account_reports.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends land_account_reportsCreateManyArgs>(args?: SelectSubset<T, land_account_reportsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Land_account_reports.
     * @param {land_account_reportsDeleteArgs} args - Arguments to delete one Land_account_reports.
     * @example
     * // Delete one Land_account_reports
     * const Land_account_reports = await prisma.land_account_reports.delete({
     *   where: {
     *     // ... filter to delete one Land_account_reports
     *   }
     * })
     * 
     */
    delete<T extends land_account_reportsDeleteArgs>(args: SelectSubset<T, land_account_reportsDeleteArgs<ExtArgs>>): Prisma__land_account_reportsClient<$Result.GetResult<Prisma.$land_account_reportsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Land_account_reports.
     * @param {land_account_reportsUpdateArgs} args - Arguments to update one Land_account_reports.
     * @example
     * // Update one Land_account_reports
     * const land_account_reports = await prisma.land_account_reports.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends land_account_reportsUpdateArgs>(args: SelectSubset<T, land_account_reportsUpdateArgs<ExtArgs>>): Prisma__land_account_reportsClient<$Result.GetResult<Prisma.$land_account_reportsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Land_account_reports.
     * @param {land_account_reportsDeleteManyArgs} args - Arguments to filter Land_account_reports to delete.
     * @example
     * // Delete a few Land_account_reports
     * const { count } = await prisma.land_account_reports.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends land_account_reportsDeleteManyArgs>(args?: SelectSubset<T, land_account_reportsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Land_account_reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {land_account_reportsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Land_account_reports
     * const land_account_reports = await prisma.land_account_reports.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends land_account_reportsUpdateManyArgs>(args: SelectSubset<T, land_account_reportsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Land_account_reports.
     * @param {land_account_reportsUpsertArgs} args - Arguments to update or create a Land_account_reports.
     * @example
     * // Update or create a Land_account_reports
     * const land_account_reports = await prisma.land_account_reports.upsert({
     *   create: {
     *     // ... data to create a Land_account_reports
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Land_account_reports we want to update
     *   }
     * })
     */
    upsert<T extends land_account_reportsUpsertArgs>(args: SelectSubset<T, land_account_reportsUpsertArgs<ExtArgs>>): Prisma__land_account_reportsClient<$Result.GetResult<Prisma.$land_account_reportsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Land_account_reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {land_account_reportsCountArgs} args - Arguments to filter Land_account_reports to count.
     * @example
     * // Count the number of Land_account_reports
     * const count = await prisma.land_account_reports.count({
     *   where: {
     *     // ... the filter for the Land_account_reports we want to count
     *   }
     * })
    **/
    count<T extends land_account_reportsCountArgs>(
      args?: Subset<T, land_account_reportsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Land_account_reportsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Land_account_reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Land_account_reportsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Land_account_reportsAggregateArgs>(args: Subset<T, Land_account_reportsAggregateArgs>): Prisma.PrismaPromise<GetLand_account_reportsAggregateType<T>>

    /**
     * Group by Land_account_reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {land_account_reportsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends land_account_reportsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: land_account_reportsGroupByArgs['orderBy'] }
        : { orderBy?: land_account_reportsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, land_account_reportsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLand_account_reportsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the land_account_reports model
   */
  readonly fields: land_account_reportsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for land_account_reports.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__land_account_reportsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    landAccount<T extends land_accountsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, land_accountsDefaultArgs<ExtArgs>>): Prisma__land_accountsClient<$Result.GetResult<Prisma.$land_accountsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the land_account_reports model
   */
  interface land_account_reportsFieldRefs {
    readonly id: FieldRef<"land_account_reports", 'String'>
    readonly landAccountId: FieldRef<"land_account_reports", 'String'>
    readonly detail: FieldRef<"land_account_reports", 'String'>
    readonly amount: FieldRef<"land_account_reports", 'Decimal'>
    readonly note: FieldRef<"land_account_reports", 'String'>
    readonly accountBalance: FieldRef<"land_account_reports", 'Decimal'>
    readonly employeeId: FieldRef<"land_account_reports", 'Int'>
    readonly employeeName: FieldRef<"land_account_reports", 'String'>
    readonly createdAt: FieldRef<"land_account_reports", 'DateTime'>
    readonly updatedAt: FieldRef<"land_account_reports", 'DateTime'>
    readonly deletedAt: FieldRef<"land_account_reports", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * land_account_reports findUnique
   */
  export type land_account_reportsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the land_account_reports
     */
    select?: land_account_reportsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the land_account_reports
     */
    omit?: land_account_reportsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: land_account_reportsInclude<ExtArgs> | null
    /**
     * Filter, which land_account_reports to fetch.
     */
    where: land_account_reportsWhereUniqueInput
  }

  /**
   * land_account_reports findUniqueOrThrow
   */
  export type land_account_reportsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the land_account_reports
     */
    select?: land_account_reportsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the land_account_reports
     */
    omit?: land_account_reportsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: land_account_reportsInclude<ExtArgs> | null
    /**
     * Filter, which land_account_reports to fetch.
     */
    where: land_account_reportsWhereUniqueInput
  }

  /**
   * land_account_reports findFirst
   */
  export type land_account_reportsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the land_account_reports
     */
    select?: land_account_reportsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the land_account_reports
     */
    omit?: land_account_reportsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: land_account_reportsInclude<ExtArgs> | null
    /**
     * Filter, which land_account_reports to fetch.
     */
    where?: land_account_reportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of land_account_reports to fetch.
     */
    orderBy?: land_account_reportsOrderByWithRelationInput | land_account_reportsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for land_account_reports.
     */
    cursor?: land_account_reportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` land_account_reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` land_account_reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of land_account_reports.
     */
    distinct?: Land_account_reportsScalarFieldEnum | Land_account_reportsScalarFieldEnum[]
  }

  /**
   * land_account_reports findFirstOrThrow
   */
  export type land_account_reportsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the land_account_reports
     */
    select?: land_account_reportsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the land_account_reports
     */
    omit?: land_account_reportsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: land_account_reportsInclude<ExtArgs> | null
    /**
     * Filter, which land_account_reports to fetch.
     */
    where?: land_account_reportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of land_account_reports to fetch.
     */
    orderBy?: land_account_reportsOrderByWithRelationInput | land_account_reportsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for land_account_reports.
     */
    cursor?: land_account_reportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` land_account_reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` land_account_reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of land_account_reports.
     */
    distinct?: Land_account_reportsScalarFieldEnum | Land_account_reportsScalarFieldEnum[]
  }

  /**
   * land_account_reports findMany
   */
  export type land_account_reportsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the land_account_reports
     */
    select?: land_account_reportsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the land_account_reports
     */
    omit?: land_account_reportsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: land_account_reportsInclude<ExtArgs> | null
    /**
     * Filter, which land_account_reports to fetch.
     */
    where?: land_account_reportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of land_account_reports to fetch.
     */
    orderBy?: land_account_reportsOrderByWithRelationInput | land_account_reportsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing land_account_reports.
     */
    cursor?: land_account_reportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` land_account_reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` land_account_reports.
     */
    skip?: number
    distinct?: Land_account_reportsScalarFieldEnum | Land_account_reportsScalarFieldEnum[]
  }

  /**
   * land_account_reports create
   */
  export type land_account_reportsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the land_account_reports
     */
    select?: land_account_reportsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the land_account_reports
     */
    omit?: land_account_reportsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: land_account_reportsInclude<ExtArgs> | null
    /**
     * The data needed to create a land_account_reports.
     */
    data: XOR<land_account_reportsCreateInput, land_account_reportsUncheckedCreateInput>
  }

  /**
   * land_account_reports createMany
   */
  export type land_account_reportsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many land_account_reports.
     */
    data: land_account_reportsCreateManyInput | land_account_reportsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * land_account_reports update
   */
  export type land_account_reportsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the land_account_reports
     */
    select?: land_account_reportsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the land_account_reports
     */
    omit?: land_account_reportsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: land_account_reportsInclude<ExtArgs> | null
    /**
     * The data needed to update a land_account_reports.
     */
    data: XOR<land_account_reportsUpdateInput, land_account_reportsUncheckedUpdateInput>
    /**
     * Choose, which land_account_reports to update.
     */
    where: land_account_reportsWhereUniqueInput
  }

  /**
   * land_account_reports updateMany
   */
  export type land_account_reportsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update land_account_reports.
     */
    data: XOR<land_account_reportsUpdateManyMutationInput, land_account_reportsUncheckedUpdateManyInput>
    /**
     * Filter which land_account_reports to update
     */
    where?: land_account_reportsWhereInput
    /**
     * Limit how many land_account_reports to update.
     */
    limit?: number
  }

  /**
   * land_account_reports upsert
   */
  export type land_account_reportsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the land_account_reports
     */
    select?: land_account_reportsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the land_account_reports
     */
    omit?: land_account_reportsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: land_account_reportsInclude<ExtArgs> | null
    /**
     * The filter to search for the land_account_reports to update in case it exists.
     */
    where: land_account_reportsWhereUniqueInput
    /**
     * In case the land_account_reports found by the `where` argument doesn't exist, create a new land_account_reports with this data.
     */
    create: XOR<land_account_reportsCreateInput, land_account_reportsUncheckedCreateInput>
    /**
     * In case the land_account_reports was found with the provided `where` argument, update it with this data.
     */
    update: XOR<land_account_reportsUpdateInput, land_account_reportsUncheckedUpdateInput>
  }

  /**
   * land_account_reports delete
   */
  export type land_account_reportsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the land_account_reports
     */
    select?: land_account_reportsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the land_account_reports
     */
    omit?: land_account_reportsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: land_account_reportsInclude<ExtArgs> | null
    /**
     * Filter which land_account_reports to delete.
     */
    where: land_account_reportsWhereUniqueInput
  }

  /**
   * land_account_reports deleteMany
   */
  export type land_account_reportsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which land_account_reports to delete
     */
    where?: land_account_reportsWhereInput
    /**
     * Limit how many land_account_reports to delete.
     */
    limit?: number
  }

  /**
   * land_account_reports without action
   */
  export type land_account_reportsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the land_account_reports
     */
    select?: land_account_reportsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the land_account_reports
     */
    omit?: land_account_reportsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: land_account_reportsInclude<ExtArgs> | null
  }


  /**
   * Model user_profiles
   */

  export type AggregateUser_profiles = {
    _count: User_profilesCountAggregateOutputType | null
    _avg: User_profilesAvgAggregateOutputType | null
    _sum: User_profilesSumAggregateOutputType | null
    _min: User_profilesMinAggregateOutputType | null
    _max: User_profilesMaxAggregateOutputType | null
  }

  export type User_profilesAvgAggregateOutputType = {
    coinBalance: number | null
  }

  export type User_profilesSumAggregateOutputType = {
    coinBalance: number | null
  }

  export type User_profilesMinAggregateOutputType = {
    id: string | null
    userId: string | null
    firstName: string | null
    lastName: string | null
    idCardNumber: string | null
    dateOfBirth: Date | null
    address: string | null
    email: string | null
    lineId: string | null
    idCardFrontImage: string | null
    idCardBackImage: string | null
    preferredLanguage: string | null
    notificationEnabled: boolean | null
    coinBalance: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type User_profilesMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    firstName: string | null
    lastName: string | null
    idCardNumber: string | null
    dateOfBirth: Date | null
    address: string | null
    email: string | null
    lineId: string | null
    idCardFrontImage: string | null
    idCardBackImage: string | null
    preferredLanguage: string | null
    notificationEnabled: boolean | null
    coinBalance: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type User_profilesCountAggregateOutputType = {
    id: number
    userId: number
    firstName: number
    lastName: number
    idCardNumber: number
    dateOfBirth: number
    address: number
    email: number
    lineId: number
    idCardFrontImage: number
    idCardBackImage: number
    preferredLanguage: number
    notificationEnabled: number
    coinBalance: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type User_profilesAvgAggregateInputType = {
    coinBalance?: true
  }

  export type User_profilesSumAggregateInputType = {
    coinBalance?: true
  }

  export type User_profilesMinAggregateInputType = {
    id?: true
    userId?: true
    firstName?: true
    lastName?: true
    idCardNumber?: true
    dateOfBirth?: true
    address?: true
    email?: true
    lineId?: true
    idCardFrontImage?: true
    idCardBackImage?: true
    preferredLanguage?: true
    notificationEnabled?: true
    coinBalance?: true
    createdAt?: true
    updatedAt?: true
  }

  export type User_profilesMaxAggregateInputType = {
    id?: true
    userId?: true
    firstName?: true
    lastName?: true
    idCardNumber?: true
    dateOfBirth?: true
    address?: true
    email?: true
    lineId?: true
    idCardFrontImage?: true
    idCardBackImage?: true
    preferredLanguage?: true
    notificationEnabled?: true
    coinBalance?: true
    createdAt?: true
    updatedAt?: true
  }

  export type User_profilesCountAggregateInputType = {
    id?: true
    userId?: true
    firstName?: true
    lastName?: true
    idCardNumber?: true
    dateOfBirth?: true
    address?: true
    email?: true
    lineId?: true
    idCardFrontImage?: true
    idCardBackImage?: true
    preferredLanguage?: true
    notificationEnabled?: true
    coinBalance?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type User_profilesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_profiles to aggregate.
     */
    where?: user_profilesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_profiles to fetch.
     */
    orderBy?: user_profilesOrderByWithRelationInput | user_profilesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: user_profilesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned user_profiles
    **/
    _count?: true | User_profilesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: User_profilesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: User_profilesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_profilesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_profilesMaxAggregateInputType
  }

  export type GetUser_profilesAggregateType<T extends User_profilesAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_profiles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_profiles[P]>
      : GetScalarType<T[P], AggregateUser_profiles[P]>
  }




  export type user_profilesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_profilesWhereInput
    orderBy?: user_profilesOrderByWithAggregationInput | user_profilesOrderByWithAggregationInput[]
    by: User_profilesScalarFieldEnum[] | User_profilesScalarFieldEnum
    having?: user_profilesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_profilesCountAggregateInputType | true
    _avg?: User_profilesAvgAggregateInputType
    _sum?: User_profilesSumAggregateInputType
    _min?: User_profilesMinAggregateInputType
    _max?: User_profilesMaxAggregateInputType
  }

  export type User_profilesGroupByOutputType = {
    id: string
    userId: string
    firstName: string | null
    lastName: string | null
    idCardNumber: string | null
    dateOfBirth: Date | null
    address: string | null
    email: string | null
    lineId: string | null
    idCardFrontImage: string | null
    idCardBackImage: string | null
    preferredLanguage: string
    notificationEnabled: boolean
    coinBalance: number
    createdAt: Date
    updatedAt: Date
    _count: User_profilesCountAggregateOutputType | null
    _avg: User_profilesAvgAggregateOutputType | null
    _sum: User_profilesSumAggregateOutputType | null
    _min: User_profilesMinAggregateOutputType | null
    _max: User_profilesMaxAggregateOutputType | null
  }

  type GetUser_profilesGroupByPayload<T extends user_profilesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<User_profilesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_profilesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_profilesGroupByOutputType[P]>
            : GetScalarType<T[P], User_profilesGroupByOutputType[P]>
        }
      >
    >


  export type user_profilesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    idCardNumber?: boolean
    dateOfBirth?: boolean
    address?: boolean
    email?: boolean
    lineId?: boolean
    idCardFrontImage?: boolean
    idCardBackImage?: boolean
    preferredLanguage?: boolean
    notificationEnabled?: boolean
    coinBalance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user_profiles"]>



  export type user_profilesSelectScalar = {
    id?: boolean
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    idCardNumber?: boolean
    dateOfBirth?: boolean
    address?: boolean
    email?: boolean
    lineId?: boolean
    idCardFrontImage?: boolean
    idCardBackImage?: boolean
    preferredLanguage?: boolean
    notificationEnabled?: boolean
    coinBalance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type user_profilesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "firstName" | "lastName" | "idCardNumber" | "dateOfBirth" | "address" | "email" | "lineId" | "idCardFrontImage" | "idCardBackImage" | "preferredLanguage" | "notificationEnabled" | "coinBalance" | "createdAt" | "updatedAt", ExtArgs["result"]["user_profiles"]>

  export type $user_profilesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user_profiles"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      firstName: string | null
      lastName: string | null
      idCardNumber: string | null
      dateOfBirth: Date | null
      address: string | null
      email: string | null
      lineId: string | null
      idCardFrontImage: string | null
      idCardBackImage: string | null
      preferredLanguage: string
      notificationEnabled: boolean
      coinBalance: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user_profiles"]>
    composites: {}
  }

  type user_profilesGetPayload<S extends boolean | null | undefined | user_profilesDefaultArgs> = $Result.GetResult<Prisma.$user_profilesPayload, S>

  type user_profilesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<user_profilesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: User_profilesCountAggregateInputType | true
    }

  export interface user_profilesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user_profiles'], meta: { name: 'user_profiles' } }
    /**
     * Find zero or one User_profiles that matches the filter.
     * @param {user_profilesFindUniqueArgs} args - Arguments to find a User_profiles
     * @example
     * // Get one User_profiles
     * const user_profiles = await prisma.user_profiles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends user_profilesFindUniqueArgs>(args: SelectSubset<T, user_profilesFindUniqueArgs<ExtArgs>>): Prisma__user_profilesClient<$Result.GetResult<Prisma.$user_profilesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User_profiles that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {user_profilesFindUniqueOrThrowArgs} args - Arguments to find a User_profiles
     * @example
     * // Get one User_profiles
     * const user_profiles = await prisma.user_profiles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends user_profilesFindUniqueOrThrowArgs>(args: SelectSubset<T, user_profilesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__user_profilesClient<$Result.GetResult<Prisma.$user_profilesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User_profiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_profilesFindFirstArgs} args - Arguments to find a User_profiles
     * @example
     * // Get one User_profiles
     * const user_profiles = await prisma.user_profiles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends user_profilesFindFirstArgs>(args?: SelectSubset<T, user_profilesFindFirstArgs<ExtArgs>>): Prisma__user_profilesClient<$Result.GetResult<Prisma.$user_profilesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User_profiles that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_profilesFindFirstOrThrowArgs} args - Arguments to find a User_profiles
     * @example
     * // Get one User_profiles
     * const user_profiles = await prisma.user_profiles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends user_profilesFindFirstOrThrowArgs>(args?: SelectSubset<T, user_profilesFindFirstOrThrowArgs<ExtArgs>>): Prisma__user_profilesClient<$Result.GetResult<Prisma.$user_profilesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more User_profiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_profilesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_profiles
     * const user_profiles = await prisma.user_profiles.findMany()
     * 
     * // Get first 10 User_profiles
     * const user_profiles = await prisma.user_profiles.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const user_profilesWithIdOnly = await prisma.user_profiles.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends user_profilesFindManyArgs>(args?: SelectSubset<T, user_profilesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_profilesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User_profiles.
     * @param {user_profilesCreateArgs} args - Arguments to create a User_profiles.
     * @example
     * // Create one User_profiles
     * const User_profiles = await prisma.user_profiles.create({
     *   data: {
     *     // ... data to create a User_profiles
     *   }
     * })
     * 
     */
    create<T extends user_profilesCreateArgs>(args: SelectSubset<T, user_profilesCreateArgs<ExtArgs>>): Prisma__user_profilesClient<$Result.GetResult<Prisma.$user_profilesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many User_profiles.
     * @param {user_profilesCreateManyArgs} args - Arguments to create many User_profiles.
     * @example
     * // Create many User_profiles
     * const user_profiles = await prisma.user_profiles.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends user_profilesCreateManyArgs>(args?: SelectSubset<T, user_profilesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User_profiles.
     * @param {user_profilesDeleteArgs} args - Arguments to delete one User_profiles.
     * @example
     * // Delete one User_profiles
     * const User_profiles = await prisma.user_profiles.delete({
     *   where: {
     *     // ... filter to delete one User_profiles
     *   }
     * })
     * 
     */
    delete<T extends user_profilesDeleteArgs>(args: SelectSubset<T, user_profilesDeleteArgs<ExtArgs>>): Prisma__user_profilesClient<$Result.GetResult<Prisma.$user_profilesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User_profiles.
     * @param {user_profilesUpdateArgs} args - Arguments to update one User_profiles.
     * @example
     * // Update one User_profiles
     * const user_profiles = await prisma.user_profiles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends user_profilesUpdateArgs>(args: SelectSubset<T, user_profilesUpdateArgs<ExtArgs>>): Prisma__user_profilesClient<$Result.GetResult<Prisma.$user_profilesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more User_profiles.
     * @param {user_profilesDeleteManyArgs} args - Arguments to filter User_profiles to delete.
     * @example
     * // Delete a few User_profiles
     * const { count } = await prisma.user_profiles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends user_profilesDeleteManyArgs>(args?: SelectSubset<T, user_profilesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_profilesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_profiles
     * const user_profiles = await prisma.user_profiles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends user_profilesUpdateManyArgs>(args: SelectSubset<T, user_profilesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User_profiles.
     * @param {user_profilesUpsertArgs} args - Arguments to update or create a User_profiles.
     * @example
     * // Update or create a User_profiles
     * const user_profiles = await prisma.user_profiles.upsert({
     *   create: {
     *     // ... data to create a User_profiles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_profiles we want to update
     *   }
     * })
     */
    upsert<T extends user_profilesUpsertArgs>(args: SelectSubset<T, user_profilesUpsertArgs<ExtArgs>>): Prisma__user_profilesClient<$Result.GetResult<Prisma.$user_profilesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of User_profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_profilesCountArgs} args - Arguments to filter User_profiles to count.
     * @example
     * // Count the number of User_profiles
     * const count = await prisma.user_profiles.count({
     *   where: {
     *     // ... the filter for the User_profiles we want to count
     *   }
     * })
    **/
    count<T extends user_profilesCountArgs>(
      args?: Subset<T, user_profilesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_profilesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_profilesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_profilesAggregateArgs>(args: Subset<T, User_profilesAggregateArgs>): Prisma.PrismaPromise<GetUser_profilesAggregateType<T>>

    /**
     * Group by User_profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_profilesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends user_profilesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: user_profilesGroupByArgs['orderBy'] }
        : { orderBy?: user_profilesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, user_profilesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_profilesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user_profiles model
   */
  readonly fields: user_profilesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user_profiles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__user_profilesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user_profiles model
   */
  interface user_profilesFieldRefs {
    readonly id: FieldRef<"user_profiles", 'String'>
    readonly userId: FieldRef<"user_profiles", 'String'>
    readonly firstName: FieldRef<"user_profiles", 'String'>
    readonly lastName: FieldRef<"user_profiles", 'String'>
    readonly idCardNumber: FieldRef<"user_profiles", 'String'>
    readonly dateOfBirth: FieldRef<"user_profiles", 'DateTime'>
    readonly address: FieldRef<"user_profiles", 'String'>
    readonly email: FieldRef<"user_profiles", 'String'>
    readonly lineId: FieldRef<"user_profiles", 'String'>
    readonly idCardFrontImage: FieldRef<"user_profiles", 'String'>
    readonly idCardBackImage: FieldRef<"user_profiles", 'String'>
    readonly preferredLanguage: FieldRef<"user_profiles", 'String'>
    readonly notificationEnabled: FieldRef<"user_profiles", 'Boolean'>
    readonly coinBalance: FieldRef<"user_profiles", 'Int'>
    readonly createdAt: FieldRef<"user_profiles", 'DateTime'>
    readonly updatedAt: FieldRef<"user_profiles", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * user_profiles findUnique
   */
  export type user_profilesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_profiles
     */
    select?: user_profilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_profiles
     */
    omit?: user_profilesOmit<ExtArgs> | null
    /**
     * Filter, which user_profiles to fetch.
     */
    where: user_profilesWhereUniqueInput
  }

  /**
   * user_profiles findUniqueOrThrow
   */
  export type user_profilesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_profiles
     */
    select?: user_profilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_profiles
     */
    omit?: user_profilesOmit<ExtArgs> | null
    /**
     * Filter, which user_profiles to fetch.
     */
    where: user_profilesWhereUniqueInput
  }

  /**
   * user_profiles findFirst
   */
  export type user_profilesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_profiles
     */
    select?: user_profilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_profiles
     */
    omit?: user_profilesOmit<ExtArgs> | null
    /**
     * Filter, which user_profiles to fetch.
     */
    where?: user_profilesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_profiles to fetch.
     */
    orderBy?: user_profilesOrderByWithRelationInput | user_profilesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_profiles.
     */
    cursor?: user_profilesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_profiles.
     */
    distinct?: User_profilesScalarFieldEnum | User_profilesScalarFieldEnum[]
  }

  /**
   * user_profiles findFirstOrThrow
   */
  export type user_profilesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_profiles
     */
    select?: user_profilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_profiles
     */
    omit?: user_profilesOmit<ExtArgs> | null
    /**
     * Filter, which user_profiles to fetch.
     */
    where?: user_profilesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_profiles to fetch.
     */
    orderBy?: user_profilesOrderByWithRelationInput | user_profilesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_profiles.
     */
    cursor?: user_profilesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_profiles.
     */
    distinct?: User_profilesScalarFieldEnum | User_profilesScalarFieldEnum[]
  }

  /**
   * user_profiles findMany
   */
  export type user_profilesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_profiles
     */
    select?: user_profilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_profiles
     */
    omit?: user_profilesOmit<ExtArgs> | null
    /**
     * Filter, which user_profiles to fetch.
     */
    where?: user_profilesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_profiles to fetch.
     */
    orderBy?: user_profilesOrderByWithRelationInput | user_profilesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing user_profiles.
     */
    cursor?: user_profilesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_profiles.
     */
    skip?: number
    distinct?: User_profilesScalarFieldEnum | User_profilesScalarFieldEnum[]
  }

  /**
   * user_profiles create
   */
  export type user_profilesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_profiles
     */
    select?: user_profilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_profiles
     */
    omit?: user_profilesOmit<ExtArgs> | null
    /**
     * The data needed to create a user_profiles.
     */
    data: XOR<user_profilesCreateInput, user_profilesUncheckedCreateInput>
  }

  /**
   * user_profiles createMany
   */
  export type user_profilesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many user_profiles.
     */
    data: user_profilesCreateManyInput | user_profilesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user_profiles update
   */
  export type user_profilesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_profiles
     */
    select?: user_profilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_profiles
     */
    omit?: user_profilesOmit<ExtArgs> | null
    /**
     * The data needed to update a user_profiles.
     */
    data: XOR<user_profilesUpdateInput, user_profilesUncheckedUpdateInput>
    /**
     * Choose, which user_profiles to update.
     */
    where: user_profilesWhereUniqueInput
  }

  /**
   * user_profiles updateMany
   */
  export type user_profilesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update user_profiles.
     */
    data: XOR<user_profilesUpdateManyMutationInput, user_profilesUncheckedUpdateManyInput>
    /**
     * Filter which user_profiles to update
     */
    where?: user_profilesWhereInput
    /**
     * Limit how many user_profiles to update.
     */
    limit?: number
  }

  /**
   * user_profiles upsert
   */
  export type user_profilesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_profiles
     */
    select?: user_profilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_profiles
     */
    omit?: user_profilesOmit<ExtArgs> | null
    /**
     * The filter to search for the user_profiles to update in case it exists.
     */
    where: user_profilesWhereUniqueInput
    /**
     * In case the user_profiles found by the `where` argument doesn't exist, create a new user_profiles with this data.
     */
    create: XOR<user_profilesCreateInput, user_profilesUncheckedCreateInput>
    /**
     * In case the user_profiles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<user_profilesUpdateInput, user_profilesUncheckedUpdateInput>
  }

  /**
   * user_profiles delete
   */
  export type user_profilesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_profiles
     */
    select?: user_profilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_profiles
     */
    omit?: user_profilesOmit<ExtArgs> | null
    /**
     * Filter which user_profiles to delete.
     */
    where: user_profilesWhereUniqueInput
  }

  /**
   * user_profiles deleteMany
   */
  export type user_profilesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_profiles to delete
     */
    where?: user_profilesWhereInput
    /**
     * Limit how many user_profiles to delete.
     */
    limit?: number
  }

  /**
   * user_profiles without action
   */
  export type user_profilesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_profiles
     */
    select?: user_profilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_profiles
     */
    omit?: user_profilesOmit<ExtArgs> | null
  }


  /**
   * Model users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersMinAggregateOutputType = {
    id: string | null
    phoneNumber: string | null
    pin: string | null
    otpSecret: string | null
    otpEnabled: boolean | null
    lastOtpSentAt: Date | null
    userType: $Enums.users_userType | null
    isActive: boolean | null
    lastLoginAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UsersMaxAggregateOutputType = {
    id: string | null
    phoneNumber: string | null
    pin: string | null
    otpSecret: string | null
    otpEnabled: boolean | null
    lastOtpSentAt: Date | null
    userType: $Enums.users_userType | null
    isActive: boolean | null
    lastLoginAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UsersCountAggregateOutputType = {
    id: number
    phoneNumber: number
    pin: number
    otpSecret: number
    otpEnabled: number
    lastOtpSentAt: number
    userType: number
    isActive: number
    lastLoginAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UsersMinAggregateInputType = {
    id?: true
    phoneNumber?: true
    pin?: true
    otpSecret?: true
    otpEnabled?: true
    lastOtpSentAt?: true
    userType?: true
    isActive?: true
    lastLoginAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UsersMaxAggregateInputType = {
    id?: true
    phoneNumber?: true
    pin?: true
    otpSecret?: true
    otpEnabled?: true
    lastOtpSentAt?: true
    userType?: true
    isActive?: true
    lastLoginAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UsersCountAggregateInputType = {
    id?: true
    phoneNumber?: true
    pin?: true
    otpSecret?: true
    otpEnabled?: true
    lastOtpSentAt?: true
    userType?: true
    isActive?: true
    lastLoginAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to aggregate.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type usersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
    orderBy?: usersOrderByWithAggregationInput | usersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    id: string
    phoneNumber: string
    pin: string | null
    otpSecret: string | null
    otpEnabled: boolean
    lastOtpSentAt: Date | null
    userType: $Enums.users_userType
    isActive: boolean
    lastLoginAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: UsersCountAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends usersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type usersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    phoneNumber?: boolean
    pin?: boolean
    otpSecret?: boolean
    otpEnabled?: boolean
    lastOtpSentAt?: boolean
    userType?: boolean
    isActive?: boolean
    lastLoginAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["users"]>



  export type usersSelectScalar = {
    id?: boolean
    phoneNumber?: boolean
    pin?: boolean
    otpSecret?: boolean
    otpEnabled?: boolean
    lastOtpSentAt?: boolean
    userType?: boolean
    isActive?: boolean
    lastLoginAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type usersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "phoneNumber" | "pin" | "otpSecret" | "otpEnabled" | "lastOtpSentAt" | "userType" | "isActive" | "lastLoginAt" | "createdAt" | "updatedAt", ExtArgs["result"]["users"]>

  export type $usersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "users"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      phoneNumber: string
      pin: string | null
      otpSecret: string | null
      otpEnabled: boolean
      lastOtpSentAt: Date | null
      userType: $Enums.users_userType
      isActive: boolean
      lastLoginAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["users"]>
    composites: {}
  }

  type usersGetPayload<S extends boolean | null | undefined | usersDefaultArgs> = $Result.GetResult<Prisma.$usersPayload, S>

  type usersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<usersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface usersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['users'], meta: { name: 'users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {usersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usersFindUniqueArgs>(args: SelectSubset<T, usersFindUniqueArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {usersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usersFindUniqueOrThrowArgs>(args: SelectSubset<T, usersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usersFindFirstArgs>(args?: SelectSubset<T, usersFindFirstArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usersFindFirstOrThrowArgs>(args?: SelectSubset<T, usersFindFirstOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends usersFindManyArgs>(args?: SelectSubset<T, usersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Users.
     * @param {usersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
     */
    create<T extends usersCreateArgs>(args: SelectSubset<T, usersCreateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {usersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends usersCreateManyArgs>(args?: SelectSubset<T, usersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Users.
     * @param {usersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
     */
    delete<T extends usersDeleteArgs>(args: SelectSubset<T, usersDeleteArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Users.
     * @param {usersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends usersUpdateArgs>(args: SelectSubset<T, usersUpdateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends usersDeleteManyArgs>(args?: SelectSubset<T, usersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends usersUpdateManyArgs>(args: SelectSubset<T, usersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Users.
     * @param {usersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     */
    upsert<T extends usersUpsertArgs>(args: SelectSubset<T, usersUpsertArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends usersCountArgs>(
      args?: Subset<T, usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usersGroupByArgs['orderBy'] }
        : { orderBy?: usersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the users model
   */
  readonly fields: usersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the users model
   */
  interface usersFieldRefs {
    readonly id: FieldRef<"users", 'String'>
    readonly phoneNumber: FieldRef<"users", 'String'>
    readonly pin: FieldRef<"users", 'String'>
    readonly otpSecret: FieldRef<"users", 'String'>
    readonly otpEnabled: FieldRef<"users", 'Boolean'>
    readonly lastOtpSentAt: FieldRef<"users", 'DateTime'>
    readonly userType: FieldRef<"users", 'users_userType'>
    readonly isActive: FieldRef<"users", 'Boolean'>
    readonly lastLoginAt: FieldRef<"users", 'DateTime'>
    readonly createdAt: FieldRef<"users", 'DateTime'>
    readonly updatedAt: FieldRef<"users", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * users findUnique
   */
  export type usersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findUniqueOrThrow
   */
  export type usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findFirst
   */
  export type usersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findFirstOrThrow
   */
  export type usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findMany
   */
  export type usersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users create
   */
  export type usersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The data needed to create a users.
     */
    data: XOR<usersCreateInput, usersUncheckedCreateInput>
  }

  /**
   * users createMany
   */
  export type usersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users update
   */
  export type usersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The data needed to update a users.
     */
    data: XOR<usersUpdateInput, usersUncheckedUpdateInput>
    /**
     * Choose, which users to update.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users updateMany
   */
  export type usersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * users upsert
   */
  export type usersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The filter to search for the users to update in case it exists.
     */
    where: usersWhereUniqueInput
    /**
     * In case the users found by the `where` argument doesn't exist, create a new users with this data.
     */
    create: XOR<usersCreateInput, usersUncheckedCreateInput>
    /**
     * In case the users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usersUpdateInput, usersUncheckedUpdateInput>
  }

  /**
   * users delete
   */
  export type usersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Filter which users to delete.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users deleteMany
   */
  export type usersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: usersWhereInput
    /**
     * Limit how many users to delete.
     */
    limit?: number
  }

  /**
   * users without action
   */
  export type usersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const Admin_permissionsScalarFieldEnum: {
    id: 'id',
    adminId: 'adminId',
    permission: 'permission',
    grantedAt: 'grantedAt',
    grantedBy: 'grantedBy'
  };

  export type Admin_permissionsScalarFieldEnum = (typeof Admin_permissionsScalarFieldEnum)[keyof typeof Admin_permissionsScalarFieldEnum]


  export const Admin_sessionsScalarFieldEnum: {
    id: 'id',
    adminId: 'adminId',
    token: 'token',
    deviceInfo: 'deviceInfo',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt'
  };

  export type Admin_sessionsScalarFieldEnum = (typeof Admin_sessionsScalarFieldEnum)[keyof typeof Admin_sessionsScalarFieldEnum]


  export const AdminsScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    firstName: 'firstName',
    lastName: 'lastName',
    role: 'role',
    isActive: 'isActive',
    lastLoginAt: 'lastLoginAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AdminsScalarFieldEnum = (typeof AdminsScalarFieldEnum)[keyof typeof AdminsScalarFieldEnum]


  export const Agent_customersScalarFieldEnum: {
    id: 'id',
    agentId: 'agentId',
    customerId: 'customerId',
    assignedAt: 'assignedAt',
    isActive: 'isActive'
  };

  export type Agent_customersScalarFieldEnum = (typeof Agent_customersScalarFieldEnum)[keyof typeof Agent_customersScalarFieldEnum]


  export const Audit_logsScalarFieldEnum: {
    id: 'id',
    action: 'action',
    entity: 'entity',
    entityId: 'entityId',
    oldData: 'oldData',
    newData: 'newData',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    createdAt: 'createdAt',
    adminId: 'adminId'
  };

  export type Audit_logsScalarFieldEnum = (typeof Audit_logsScalarFieldEnum)[keyof typeof Audit_logsScalarFieldEnum]


  export const BannersScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    imageUrl: 'imageUrl',
    actionUrl: 'actionUrl',
    isActive: 'isActive',
    sortOrder: 'sortOrder',
    targetUserTypes: 'targetUserTypes',
    startDate: 'startDate',
    endDate: 'endDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BannersScalarFieldEnum = (typeof BannersScalarFieldEnum)[keyof typeof BannersScalarFieldEnum]


  export const Coin_transactionsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    amount: 'amount',
    description: 'description',
    loanId: 'loanId',
    rewardId: 'rewardId',
    createdAt: 'createdAt'
  };

  export type Coin_transactionsScalarFieldEnum = (typeof Coin_transactionsScalarFieldEnum)[keyof typeof Coin_transactionsScalarFieldEnum]


  export const Loan_applicationsScalarFieldEnum: {
    id: 'id',
    customerId: 'customerId',
    agentId: 'agentId',
    loanType: 'loanType',
    status: 'status',
    currentStep: 'currentStep',
    completedSteps: 'completedSteps',
    isNewUser: 'isNewUser',
    submittedByAgent: 'submittedByAgent',
    titleDeedImage: 'titleDeedImage',
    titleDeedData: 'titleDeedData',
    supportingImages: 'supportingImages',
    idCardFrontImage: 'idCardFrontImage',
    idCardBackImage: 'idCardBackImage',
    requestedAmount: 'requestedAmount',
    approvedAmount: 'approvedAmount',
    maxApprovedAmount: 'maxApprovedAmount',
    propertyType: 'propertyType',
    propertyValue: 'propertyValue',
    propertyArea: 'propertyArea',
    propertyLocation: 'propertyLocation',
    landNumber: 'landNumber',
    ownerName: 'ownerName',
    submittedAt: 'submittedAt',
    reviewedAt: 'reviewedAt',
    reviewedBy: 'reviewedBy',
    reviewNotes: 'reviewNotes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Loan_applicationsScalarFieldEnum = (typeof Loan_applicationsScalarFieldEnum)[keyof typeof Loan_applicationsScalarFieldEnum]


  export const Loan_installmentsScalarFieldEnum: {
    id: 'id',
    loanId: 'loanId',
    installmentNumber: 'installmentNumber',
    dueDate: 'dueDate',
    principalAmount: 'principalAmount',
    interestAmount: 'interestAmount',
    totalAmount: 'totalAmount',
    isPaid: 'isPaid',
    paidDate: 'paidDate',
    paidAmount: 'paidAmount',
    isLate: 'isLate',
    lateDays: 'lateDays',
    lateFee: 'lateFee',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Loan_installmentsScalarFieldEnum = (typeof Loan_installmentsScalarFieldEnum)[keyof typeof Loan_installmentsScalarFieldEnum]


  export const LoansScalarFieldEnum: {
    id: 'id',
    loanNumber: 'loanNumber',
    customerId: 'customerId',
    agentId: 'agentId',
    applicationId: 'applicationId',
    loanType: 'loanType',
    status: 'status',
    principalAmount: 'principalAmount',
    interestRate: 'interestRate',
    termMonths: 'termMonths',
    monthlyPayment: 'monthlyPayment',
    currentInstallment: 'currentInstallment',
    totalInstallments: 'totalInstallments',
    remainingBalance: 'remainingBalance',
    nextPaymentDate: 'nextPaymentDate',
    contractDate: 'contractDate',
    expiryDate: 'expiryDate',
    titleDeedNumber: 'titleDeedNumber',
    collateralValue: 'collateralValue',
    collateralDetails: 'collateralDetails',
    linkMap: 'linkMap',
    landAccountId: 'landAccountId',
    landAccountName: 'landAccountName',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LoansScalarFieldEnum = (typeof LoansScalarFieldEnum)[keyof typeof LoansScalarFieldEnum]


  export const NotificationsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    title: 'title',
    message: 'message',
    actionUrl: 'actionUrl',
    isRead: 'isRead',
    readAt: 'readAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationsScalarFieldEnum = (typeof NotificationsScalarFieldEnum)[keyof typeof NotificationsScalarFieldEnum]


  export const PaymentsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    loanId: 'loanId',
    installmentId: 'installmentId',
    amount: 'amount',
    paymentMethod: 'paymentMethod',
    status: 'status',
    referenceNumber: 'referenceNumber',
    transactionId: 'transactionId',
    qrCode: 'qrCode',
    barcodeNumber: 'barcodeNumber',
    bankName: 'bankName',
    accountNumber: 'accountNumber',
    accountName: 'accountName',
    dueDate: 'dueDate',
    paidDate: 'paidDate',
    principalAmount: 'principalAmount',
    interestAmount: 'interestAmount',
    feeAmount: 'feeAmount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentsScalarFieldEnum = (typeof PaymentsScalarFieldEnum)[keyof typeof PaymentsScalarFieldEnum]


  export const PrivilegesScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    imageUrl: 'imageUrl',
    actionUrl: 'actionUrl',
    isActive: 'isActive',
    sortOrder: 'sortOrder',
    targetUserTypes: 'targetUserTypes',
    coinCost: 'coinCost',
    requiresLoan: 'requiresLoan',
    validFrom: 'validFrom',
    validUntil: 'validUntil',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PrivilegesScalarFieldEnum = (typeof PrivilegesScalarFieldEnum)[keyof typeof PrivilegesScalarFieldEnum]


  export const Reward_redemptionsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    rewardId: 'rewardId',
    coinSpent: 'coinSpent',
    status: 'status',
    deliveryAddress: 'deliveryAddress',
    trackingNumber: 'trackingNumber',
    redeemedAt: 'redeemedAt',
    deliveredAt: 'deliveredAt'
  };

  export type Reward_redemptionsScalarFieldEnum = (typeof Reward_redemptionsScalarFieldEnum)[keyof typeof Reward_redemptionsScalarFieldEnum]


  export const RewardsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    coinCost: 'coinCost',
    imageUrl: 'imageUrl',
    isActive: 'isActive',
    stockCount: 'stockCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RewardsScalarFieldEnum = (typeof RewardsScalarFieldEnum)[keyof typeof RewardsScalarFieldEnum]


  export const SessionsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    token: 'token',
    deviceInfo: 'deviceInfo',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt'
  };

  export type SessionsScalarFieldEnum = (typeof SessionsScalarFieldEnum)[keyof typeof SessionsScalarFieldEnum]


  export const System_configScalarFieldEnum: {
    id: 'id',
    key: 'key',
    value: 'value',
    description: 'description',
    updatedAt: 'updatedAt'
  };

  export type System_configScalarFieldEnum = (typeof System_configScalarFieldEnum)[keyof typeof System_configScalarFieldEnum]


  export const DocumentsScalarFieldEnum: {
    id: 'id',
    docType: 'docType',
    docNumber: 'docNumber',
    docDate: 'docDate',
    title: 'title',
    price: 'price',
    cashFlowName: 'cashFlowName',
    employeeId: 'employeeId',
    username: 'username',
    docFile: 'docFile',
    docFileDate: 'docFileDate',
    docFileTime: 'docFileTime',
    docFilePrice: 'docFilePrice',
    filePath: 'filePath',
    note: 'note',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type DocumentsScalarFieldEnum = (typeof DocumentsScalarFieldEnum)[keyof typeof DocumentsScalarFieldEnum]


  export const Document_title_listsScalarFieldEnum: {
    id: 'id',
    docType: 'docType',
    title: 'title',
    note: 'note',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type Document_title_listsScalarFieldEnum = (typeof Document_title_listsScalarFieldEnum)[keyof typeof Document_title_listsScalarFieldEnum]


  export const Land_accountsScalarFieldEnum: {
    id: 'id',
    accountName: 'accountName',
    accountBalance: 'accountBalance',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type Land_accountsScalarFieldEnum = (typeof Land_accountsScalarFieldEnum)[keyof typeof Land_accountsScalarFieldEnum]


  export const Land_account_logsScalarFieldEnum: {
    id: 'id',
    landAccountId: 'landAccountId',
    detail: 'detail',
    amount: 'amount',
    note: 'note',
    employeeId: 'employeeId',
    employeeName: 'employeeName',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type Land_account_logsScalarFieldEnum = (typeof Land_account_logsScalarFieldEnum)[keyof typeof Land_account_logsScalarFieldEnum]


  export const Land_account_reportsScalarFieldEnum: {
    id: 'id',
    landAccountId: 'landAccountId',
    detail: 'detail',
    amount: 'amount',
    note: 'note',
    accountBalance: 'accountBalance',
    employeeId: 'employeeId',
    employeeName: 'employeeName',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type Land_account_reportsScalarFieldEnum = (typeof Land_account_reportsScalarFieldEnum)[keyof typeof Land_account_reportsScalarFieldEnum]


  export const User_profilesScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    firstName: 'firstName',
    lastName: 'lastName',
    idCardNumber: 'idCardNumber',
    dateOfBirth: 'dateOfBirth',
    address: 'address',
    email: 'email',
    lineId: 'lineId',
    idCardFrontImage: 'idCardFrontImage',
    idCardBackImage: 'idCardBackImage',
    preferredLanguage: 'preferredLanguage',
    notificationEnabled: 'notificationEnabled',
    coinBalance: 'coinBalance',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type User_profilesScalarFieldEnum = (typeof User_profilesScalarFieldEnum)[keyof typeof User_profilesScalarFieldEnum]


  export const UsersScalarFieldEnum: {
    id: 'id',
    phoneNumber: 'phoneNumber',
    pin: 'pin',
    otpSecret: 'otpSecret',
    otpEnabled: 'otpEnabled',
    lastOtpSentAt: 'lastOtpSentAt',
    userType: 'userType',
    isActive: 'isActive',
    lastLoginAt: 'lastLoginAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const admin_permissionsOrderByRelevanceFieldEnum: {
    id: 'id',
    adminId: 'adminId',
    grantedBy: 'grantedBy'
  };

  export type admin_permissionsOrderByRelevanceFieldEnum = (typeof admin_permissionsOrderByRelevanceFieldEnum)[keyof typeof admin_permissionsOrderByRelevanceFieldEnum]


  export const admin_sessionsOrderByRelevanceFieldEnum: {
    id: 'id',
    adminId: 'adminId',
    token: 'token',
    deviceInfo: 'deviceInfo',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent'
  };

  export type admin_sessionsOrderByRelevanceFieldEnum = (typeof admin_sessionsOrderByRelevanceFieldEnum)[keyof typeof admin_sessionsOrderByRelevanceFieldEnum]


  export const adminsOrderByRelevanceFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    firstName: 'firstName',
    lastName: 'lastName'
  };

  export type adminsOrderByRelevanceFieldEnum = (typeof adminsOrderByRelevanceFieldEnum)[keyof typeof adminsOrderByRelevanceFieldEnum]


  export const agent_customersOrderByRelevanceFieldEnum: {
    id: 'id',
    agentId: 'agentId',
    customerId: 'customerId'
  };

  export type agent_customersOrderByRelevanceFieldEnum = (typeof agent_customersOrderByRelevanceFieldEnum)[keyof typeof agent_customersOrderByRelevanceFieldEnum]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const audit_logsOrderByRelevanceFieldEnum: {
    id: 'id',
    action: 'action',
    entity: 'entity',
    entityId: 'entityId',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    adminId: 'adminId'
  };

  export type audit_logsOrderByRelevanceFieldEnum = (typeof audit_logsOrderByRelevanceFieldEnum)[keyof typeof audit_logsOrderByRelevanceFieldEnum]


  export const bannersOrderByRelevanceFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    imageUrl: 'imageUrl',
    actionUrl: 'actionUrl'
  };

  export type bannersOrderByRelevanceFieldEnum = (typeof bannersOrderByRelevanceFieldEnum)[keyof typeof bannersOrderByRelevanceFieldEnum]


  export const coin_transactionsOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    description: 'description',
    loanId: 'loanId',
    rewardId: 'rewardId'
  };

  export type coin_transactionsOrderByRelevanceFieldEnum = (typeof coin_transactionsOrderByRelevanceFieldEnum)[keyof typeof coin_transactionsOrderByRelevanceFieldEnum]


  export const loan_applicationsOrderByRelevanceFieldEnum: {
    id: 'id',
    customerId: 'customerId',
    agentId: 'agentId',
    titleDeedImage: 'titleDeedImage',
    idCardFrontImage: 'idCardFrontImage',
    idCardBackImage: 'idCardBackImage',
    propertyType: 'propertyType',
    propertyArea: 'propertyArea',
    propertyLocation: 'propertyLocation',
    landNumber: 'landNumber',
    ownerName: 'ownerName',
    reviewedBy: 'reviewedBy',
    reviewNotes: 'reviewNotes'
  };

  export type loan_applicationsOrderByRelevanceFieldEnum = (typeof loan_applicationsOrderByRelevanceFieldEnum)[keyof typeof loan_applicationsOrderByRelevanceFieldEnum]


  export const loan_installmentsOrderByRelevanceFieldEnum: {
    id: 'id',
    loanId: 'loanId'
  };

  export type loan_installmentsOrderByRelevanceFieldEnum = (typeof loan_installmentsOrderByRelevanceFieldEnum)[keyof typeof loan_installmentsOrderByRelevanceFieldEnum]


  export const loansOrderByRelevanceFieldEnum: {
    id: 'id',
    loanNumber: 'loanNumber',
    customerId: 'customerId',
    agentId: 'agentId',
    applicationId: 'applicationId',
    titleDeedNumber: 'titleDeedNumber',
    linkMap: 'linkMap',
    landAccountName: 'landAccountName'
  };

  export type loansOrderByRelevanceFieldEnum = (typeof loansOrderByRelevanceFieldEnum)[keyof typeof loansOrderByRelevanceFieldEnum]


  export const notificationsOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    message: 'message',
    actionUrl: 'actionUrl'
  };

  export type notificationsOrderByRelevanceFieldEnum = (typeof notificationsOrderByRelevanceFieldEnum)[keyof typeof notificationsOrderByRelevanceFieldEnum]


  export const paymentsOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    loanId: 'loanId',
    installmentId: 'installmentId',
    referenceNumber: 'referenceNumber',
    transactionId: 'transactionId',
    qrCode: 'qrCode',
    barcodeNumber: 'barcodeNumber',
    bankName: 'bankName',
    accountNumber: 'accountNumber',
    accountName: 'accountName'
  };

  export type paymentsOrderByRelevanceFieldEnum = (typeof paymentsOrderByRelevanceFieldEnum)[keyof typeof paymentsOrderByRelevanceFieldEnum]


  export const privilegesOrderByRelevanceFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    imageUrl: 'imageUrl',
    actionUrl: 'actionUrl'
  };

  export type privilegesOrderByRelevanceFieldEnum = (typeof privilegesOrderByRelevanceFieldEnum)[keyof typeof privilegesOrderByRelevanceFieldEnum]


  export const reward_redemptionsOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    rewardId: 'rewardId',
    deliveryAddress: 'deliveryAddress',
    trackingNumber: 'trackingNumber'
  };

  export type reward_redemptionsOrderByRelevanceFieldEnum = (typeof reward_redemptionsOrderByRelevanceFieldEnum)[keyof typeof reward_redemptionsOrderByRelevanceFieldEnum]


  export const rewardsOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    imageUrl: 'imageUrl'
  };

  export type rewardsOrderByRelevanceFieldEnum = (typeof rewardsOrderByRelevanceFieldEnum)[keyof typeof rewardsOrderByRelevanceFieldEnum]


  export const sessionsOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    token: 'token',
    deviceInfo: 'deviceInfo',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent'
  };

  export type sessionsOrderByRelevanceFieldEnum = (typeof sessionsOrderByRelevanceFieldEnum)[keyof typeof sessionsOrderByRelevanceFieldEnum]


  export const system_configOrderByRelevanceFieldEnum: {
    id: 'id',
    key: 'key',
    value: 'value',
    description: 'description'
  };

  export type system_configOrderByRelevanceFieldEnum = (typeof system_configOrderByRelevanceFieldEnum)[keyof typeof system_configOrderByRelevanceFieldEnum]


  export const documentsOrderByRelevanceFieldEnum: {
    id: 'id',
    docNumber: 'docNumber',
    title: 'title',
    cashFlowName: 'cashFlowName',
    username: 'username',
    docFile: 'docFile',
    docFileTime: 'docFileTime',
    filePath: 'filePath',
    note: 'note'
  };

  export type documentsOrderByRelevanceFieldEnum = (typeof documentsOrderByRelevanceFieldEnum)[keyof typeof documentsOrderByRelevanceFieldEnum]


  export const document_title_listsOrderByRelevanceFieldEnum: {
    id: 'id',
    title: 'title',
    note: 'note'
  };

  export type document_title_listsOrderByRelevanceFieldEnum = (typeof document_title_listsOrderByRelevanceFieldEnum)[keyof typeof document_title_listsOrderByRelevanceFieldEnum]


  export const land_accountsOrderByRelevanceFieldEnum: {
    id: 'id',
    accountName: 'accountName'
  };

  export type land_accountsOrderByRelevanceFieldEnum = (typeof land_accountsOrderByRelevanceFieldEnum)[keyof typeof land_accountsOrderByRelevanceFieldEnum]


  export const land_account_logsOrderByRelevanceFieldEnum: {
    id: 'id',
    landAccountId: 'landAccountId',
    detail: 'detail',
    note: 'note',
    employeeName: 'employeeName'
  };

  export type land_account_logsOrderByRelevanceFieldEnum = (typeof land_account_logsOrderByRelevanceFieldEnum)[keyof typeof land_account_logsOrderByRelevanceFieldEnum]


  export const land_account_reportsOrderByRelevanceFieldEnum: {
    id: 'id',
    landAccountId: 'landAccountId',
    detail: 'detail',
    note: 'note',
    employeeName: 'employeeName'
  };

  export type land_account_reportsOrderByRelevanceFieldEnum = (typeof land_account_reportsOrderByRelevanceFieldEnum)[keyof typeof land_account_reportsOrderByRelevanceFieldEnum]


  export const user_profilesOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    firstName: 'firstName',
    lastName: 'lastName',
    idCardNumber: 'idCardNumber',
    address: 'address',
    email: 'email',
    lineId: 'lineId',
    idCardFrontImage: 'idCardFrontImage',
    idCardBackImage: 'idCardBackImage',
    preferredLanguage: 'preferredLanguage'
  };

  export type user_profilesOrderByRelevanceFieldEnum = (typeof user_profilesOrderByRelevanceFieldEnum)[keyof typeof user_profilesOrderByRelevanceFieldEnum]


  export const usersOrderByRelevanceFieldEnum: {
    id: 'id',
    phoneNumber: 'phoneNumber',
    pin: 'pin',
    otpSecret: 'otpSecret'
  };

  export type usersOrderByRelevanceFieldEnum = (typeof usersOrderByRelevanceFieldEnum)[keyof typeof usersOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'admin_permissions_permission'
   */
  export type Enumadmin_permissions_permissionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'admin_permissions_permission'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'admins_role'
   */
  export type Enumadmins_roleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'admins_role'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'coin_transactions_type'
   */
  export type Enumcoin_transactions_typeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'coin_transactions_type'>
    


  /**
   * Reference to a field of type 'loan_applications_loanType'
   */
  export type Enumloan_applications_loanTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'loan_applications_loanType'>
    


  /**
   * Reference to a field of type 'loan_applications_status'
   */
  export type Enumloan_applications_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'loan_applications_status'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'loans_loanType'
   */
  export type Enumloans_loanTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'loans_loanType'>
    


  /**
   * Reference to a field of type 'loans_status'
   */
  export type Enumloans_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'loans_status'>
    


  /**
   * Reference to a field of type 'notifications_type'
   */
  export type Enumnotifications_typeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'notifications_type'>
    


  /**
   * Reference to a field of type 'payments_paymentMethod'
   */
  export type Enumpayments_paymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'payments_paymentMethod'>
    


  /**
   * Reference to a field of type 'payments_status'
   */
  export type Enumpayments_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'payments_status'>
    


  /**
   * Reference to a field of type 'reward_redemptions_status'
   */
  export type Enumreward_redemptions_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'reward_redemptions_status'>
    


  /**
   * Reference to a field of type 'documents_docType'
   */
  export type Enumdocuments_docTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'documents_docType'>
    


  /**
   * Reference to a field of type 'document_title_lists_docType'
   */
  export type Enumdocument_title_lists_docTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'document_title_lists_docType'>
    


  /**
   * Reference to a field of type 'users_userType'
   */
  export type Enumusers_userTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'users_userType'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type admin_permissionsWhereInput = {
    AND?: admin_permissionsWhereInput | admin_permissionsWhereInput[]
    OR?: admin_permissionsWhereInput[]
    NOT?: admin_permissionsWhereInput | admin_permissionsWhereInput[]
    id?: StringFilter<"admin_permissions"> | string
    adminId?: StringFilter<"admin_permissions"> | string
    permission?: Enumadmin_permissions_permissionFilter<"admin_permissions"> | $Enums.admin_permissions_permission
    grantedAt?: DateTimeFilter<"admin_permissions"> | Date | string
    grantedBy?: StringNullableFilter<"admin_permissions"> | string | null
  }

  export type admin_permissionsOrderByWithRelationInput = {
    id?: SortOrder
    adminId?: SortOrder
    permission?: SortOrder
    grantedAt?: SortOrder
    grantedBy?: SortOrderInput | SortOrder
    _relevance?: admin_permissionsOrderByRelevanceInput
  }

  export type admin_permissionsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    adminId_permission?: admin_permissionsAdminIdPermissionCompoundUniqueInput
    AND?: admin_permissionsWhereInput | admin_permissionsWhereInput[]
    OR?: admin_permissionsWhereInput[]
    NOT?: admin_permissionsWhereInput | admin_permissionsWhereInput[]
    adminId?: StringFilter<"admin_permissions"> | string
    permission?: Enumadmin_permissions_permissionFilter<"admin_permissions"> | $Enums.admin_permissions_permission
    grantedAt?: DateTimeFilter<"admin_permissions"> | Date | string
    grantedBy?: StringNullableFilter<"admin_permissions"> | string | null
  }, "id" | "adminId_permission">

  export type admin_permissionsOrderByWithAggregationInput = {
    id?: SortOrder
    adminId?: SortOrder
    permission?: SortOrder
    grantedAt?: SortOrder
    grantedBy?: SortOrderInput | SortOrder
    _count?: admin_permissionsCountOrderByAggregateInput
    _max?: admin_permissionsMaxOrderByAggregateInput
    _min?: admin_permissionsMinOrderByAggregateInput
  }

  export type admin_permissionsScalarWhereWithAggregatesInput = {
    AND?: admin_permissionsScalarWhereWithAggregatesInput | admin_permissionsScalarWhereWithAggregatesInput[]
    OR?: admin_permissionsScalarWhereWithAggregatesInput[]
    NOT?: admin_permissionsScalarWhereWithAggregatesInput | admin_permissionsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"admin_permissions"> | string
    adminId?: StringWithAggregatesFilter<"admin_permissions"> | string
    permission?: Enumadmin_permissions_permissionWithAggregatesFilter<"admin_permissions"> | $Enums.admin_permissions_permission
    grantedAt?: DateTimeWithAggregatesFilter<"admin_permissions"> | Date | string
    grantedBy?: StringNullableWithAggregatesFilter<"admin_permissions"> | string | null
  }

  export type admin_sessionsWhereInput = {
    AND?: admin_sessionsWhereInput | admin_sessionsWhereInput[]
    OR?: admin_sessionsWhereInput[]
    NOT?: admin_sessionsWhereInput | admin_sessionsWhereInput[]
    id?: StringFilter<"admin_sessions"> | string
    adminId?: StringFilter<"admin_sessions"> | string
    token?: StringFilter<"admin_sessions"> | string
    deviceInfo?: StringNullableFilter<"admin_sessions"> | string | null
    ipAddress?: StringNullableFilter<"admin_sessions"> | string | null
    userAgent?: StringNullableFilter<"admin_sessions"> | string | null
    expiresAt?: DateTimeFilter<"admin_sessions"> | Date | string
    createdAt?: DateTimeFilter<"admin_sessions"> | Date | string
  }

  export type admin_sessionsOrderByWithRelationInput = {
    id?: SortOrder
    adminId?: SortOrder
    token?: SortOrder
    deviceInfo?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    _relevance?: admin_sessionsOrderByRelevanceInput
  }

  export type admin_sessionsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: admin_sessionsWhereInput | admin_sessionsWhereInput[]
    OR?: admin_sessionsWhereInput[]
    NOT?: admin_sessionsWhereInput | admin_sessionsWhereInput[]
    adminId?: StringFilter<"admin_sessions"> | string
    deviceInfo?: StringNullableFilter<"admin_sessions"> | string | null
    ipAddress?: StringNullableFilter<"admin_sessions"> | string | null
    userAgent?: StringNullableFilter<"admin_sessions"> | string | null
    expiresAt?: DateTimeFilter<"admin_sessions"> | Date | string
    createdAt?: DateTimeFilter<"admin_sessions"> | Date | string
  }, "id" | "token">

  export type admin_sessionsOrderByWithAggregationInput = {
    id?: SortOrder
    adminId?: SortOrder
    token?: SortOrder
    deviceInfo?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    _count?: admin_sessionsCountOrderByAggregateInput
    _max?: admin_sessionsMaxOrderByAggregateInput
    _min?: admin_sessionsMinOrderByAggregateInput
  }

  export type admin_sessionsScalarWhereWithAggregatesInput = {
    AND?: admin_sessionsScalarWhereWithAggregatesInput | admin_sessionsScalarWhereWithAggregatesInput[]
    OR?: admin_sessionsScalarWhereWithAggregatesInput[]
    NOT?: admin_sessionsScalarWhereWithAggregatesInput | admin_sessionsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"admin_sessions"> | string
    adminId?: StringWithAggregatesFilter<"admin_sessions"> | string
    token?: StringWithAggregatesFilter<"admin_sessions"> | string
    deviceInfo?: StringNullableWithAggregatesFilter<"admin_sessions"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"admin_sessions"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"admin_sessions"> | string | null
    expiresAt?: DateTimeWithAggregatesFilter<"admin_sessions"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"admin_sessions"> | Date | string
  }

  export type adminsWhereInput = {
    AND?: adminsWhereInput | adminsWhereInput[]
    OR?: adminsWhereInput[]
    NOT?: adminsWhereInput | adminsWhereInput[]
    id?: StringFilter<"admins"> | string
    email?: StringFilter<"admins"> | string
    password?: StringFilter<"admins"> | string
    firstName?: StringFilter<"admins"> | string
    lastName?: StringFilter<"admins"> | string
    role?: Enumadmins_roleFilter<"admins"> | $Enums.admins_role
    isActive?: BoolFilter<"admins"> | boolean
    lastLoginAt?: DateTimeNullableFilter<"admins"> | Date | string | null
    createdAt?: DateTimeFilter<"admins"> | Date | string
    updatedAt?: DateTimeFilter<"admins"> | Date | string
  }

  export type adminsOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: adminsOrderByRelevanceInput
  }

  export type adminsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: adminsWhereInput | adminsWhereInput[]
    OR?: adminsWhereInput[]
    NOT?: adminsWhereInput | adminsWhereInput[]
    password?: StringFilter<"admins"> | string
    firstName?: StringFilter<"admins"> | string
    lastName?: StringFilter<"admins"> | string
    role?: Enumadmins_roleFilter<"admins"> | $Enums.admins_role
    isActive?: BoolFilter<"admins"> | boolean
    lastLoginAt?: DateTimeNullableFilter<"admins"> | Date | string | null
    createdAt?: DateTimeFilter<"admins"> | Date | string
    updatedAt?: DateTimeFilter<"admins"> | Date | string
  }, "id" | "email">

  export type adminsOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: adminsCountOrderByAggregateInput
    _max?: adminsMaxOrderByAggregateInput
    _min?: adminsMinOrderByAggregateInput
  }

  export type adminsScalarWhereWithAggregatesInput = {
    AND?: adminsScalarWhereWithAggregatesInput | adminsScalarWhereWithAggregatesInput[]
    OR?: adminsScalarWhereWithAggregatesInput[]
    NOT?: adminsScalarWhereWithAggregatesInput | adminsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"admins"> | string
    email?: StringWithAggregatesFilter<"admins"> | string
    password?: StringWithAggregatesFilter<"admins"> | string
    firstName?: StringWithAggregatesFilter<"admins"> | string
    lastName?: StringWithAggregatesFilter<"admins"> | string
    role?: Enumadmins_roleWithAggregatesFilter<"admins"> | $Enums.admins_role
    isActive?: BoolWithAggregatesFilter<"admins"> | boolean
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"admins"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"admins"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"admins"> | Date | string
  }

  export type agent_customersWhereInput = {
    AND?: agent_customersWhereInput | agent_customersWhereInput[]
    OR?: agent_customersWhereInput[]
    NOT?: agent_customersWhereInput | agent_customersWhereInput[]
    id?: StringFilter<"agent_customers"> | string
    agentId?: StringFilter<"agent_customers"> | string
    customerId?: StringFilter<"agent_customers"> | string
    assignedAt?: DateTimeFilter<"agent_customers"> | Date | string
    isActive?: BoolFilter<"agent_customers"> | boolean
  }

  export type agent_customersOrderByWithRelationInput = {
    id?: SortOrder
    agentId?: SortOrder
    customerId?: SortOrder
    assignedAt?: SortOrder
    isActive?: SortOrder
    _relevance?: agent_customersOrderByRelevanceInput
  }

  export type agent_customersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    agentId_customerId?: agent_customersAgentIdCustomerIdCompoundUniqueInput
    AND?: agent_customersWhereInput | agent_customersWhereInput[]
    OR?: agent_customersWhereInput[]
    NOT?: agent_customersWhereInput | agent_customersWhereInput[]
    agentId?: StringFilter<"agent_customers"> | string
    customerId?: StringFilter<"agent_customers"> | string
    assignedAt?: DateTimeFilter<"agent_customers"> | Date | string
    isActive?: BoolFilter<"agent_customers"> | boolean
  }, "id" | "agentId_customerId">

  export type agent_customersOrderByWithAggregationInput = {
    id?: SortOrder
    agentId?: SortOrder
    customerId?: SortOrder
    assignedAt?: SortOrder
    isActive?: SortOrder
    _count?: agent_customersCountOrderByAggregateInput
    _max?: agent_customersMaxOrderByAggregateInput
    _min?: agent_customersMinOrderByAggregateInput
  }

  export type agent_customersScalarWhereWithAggregatesInput = {
    AND?: agent_customersScalarWhereWithAggregatesInput | agent_customersScalarWhereWithAggregatesInput[]
    OR?: agent_customersScalarWhereWithAggregatesInput[]
    NOT?: agent_customersScalarWhereWithAggregatesInput | agent_customersScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"agent_customers"> | string
    agentId?: StringWithAggregatesFilter<"agent_customers"> | string
    customerId?: StringWithAggregatesFilter<"agent_customers"> | string
    assignedAt?: DateTimeWithAggregatesFilter<"agent_customers"> | Date | string
    isActive?: BoolWithAggregatesFilter<"agent_customers"> | boolean
  }

  export type audit_logsWhereInput = {
    AND?: audit_logsWhereInput | audit_logsWhereInput[]
    OR?: audit_logsWhereInput[]
    NOT?: audit_logsWhereInput | audit_logsWhereInput[]
    id?: StringFilter<"audit_logs"> | string
    action?: StringFilter<"audit_logs"> | string
    entity?: StringFilter<"audit_logs"> | string
    entityId?: StringFilter<"audit_logs"> | string
    oldData?: JsonNullableFilter<"audit_logs">
    newData?: JsonNullableFilter<"audit_logs">
    ipAddress?: StringNullableFilter<"audit_logs"> | string | null
    userAgent?: StringNullableFilter<"audit_logs"> | string | null
    createdAt?: DateTimeFilter<"audit_logs"> | Date | string
    adminId?: StringNullableFilter<"audit_logs"> | string | null
  }

  export type audit_logsOrderByWithRelationInput = {
    id?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    oldData?: SortOrderInput | SortOrder
    newData?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    adminId?: SortOrderInput | SortOrder
    _relevance?: audit_logsOrderByRelevanceInput
  }

  export type audit_logsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: audit_logsWhereInput | audit_logsWhereInput[]
    OR?: audit_logsWhereInput[]
    NOT?: audit_logsWhereInput | audit_logsWhereInput[]
    action?: StringFilter<"audit_logs"> | string
    entity?: StringFilter<"audit_logs"> | string
    entityId?: StringFilter<"audit_logs"> | string
    oldData?: JsonNullableFilter<"audit_logs">
    newData?: JsonNullableFilter<"audit_logs">
    ipAddress?: StringNullableFilter<"audit_logs"> | string | null
    userAgent?: StringNullableFilter<"audit_logs"> | string | null
    createdAt?: DateTimeFilter<"audit_logs"> | Date | string
    adminId?: StringNullableFilter<"audit_logs"> | string | null
  }, "id">

  export type audit_logsOrderByWithAggregationInput = {
    id?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    oldData?: SortOrderInput | SortOrder
    newData?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    adminId?: SortOrderInput | SortOrder
    _count?: audit_logsCountOrderByAggregateInput
    _max?: audit_logsMaxOrderByAggregateInput
    _min?: audit_logsMinOrderByAggregateInput
  }

  export type audit_logsScalarWhereWithAggregatesInput = {
    AND?: audit_logsScalarWhereWithAggregatesInput | audit_logsScalarWhereWithAggregatesInput[]
    OR?: audit_logsScalarWhereWithAggregatesInput[]
    NOT?: audit_logsScalarWhereWithAggregatesInput | audit_logsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"audit_logs"> | string
    action?: StringWithAggregatesFilter<"audit_logs"> | string
    entity?: StringWithAggregatesFilter<"audit_logs"> | string
    entityId?: StringWithAggregatesFilter<"audit_logs"> | string
    oldData?: JsonNullableWithAggregatesFilter<"audit_logs">
    newData?: JsonNullableWithAggregatesFilter<"audit_logs">
    ipAddress?: StringNullableWithAggregatesFilter<"audit_logs"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"audit_logs"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"audit_logs"> | Date | string
    adminId?: StringNullableWithAggregatesFilter<"audit_logs"> | string | null
  }

  export type bannersWhereInput = {
    AND?: bannersWhereInput | bannersWhereInput[]
    OR?: bannersWhereInput[]
    NOT?: bannersWhereInput | bannersWhereInput[]
    id?: StringFilter<"banners"> | string
    title?: StringFilter<"banners"> | string
    description?: StringNullableFilter<"banners"> | string | null
    imageUrl?: StringFilter<"banners"> | string
    actionUrl?: StringNullableFilter<"banners"> | string | null
    isActive?: BoolFilter<"banners"> | boolean
    sortOrder?: IntFilter<"banners"> | number
    targetUserTypes?: JsonFilter<"banners">
    startDate?: DateTimeNullableFilter<"banners"> | Date | string | null
    endDate?: DateTimeNullableFilter<"banners"> | Date | string | null
    createdAt?: DateTimeFilter<"banners"> | Date | string
    updatedAt?: DateTimeFilter<"banners"> | Date | string
  }

  export type bannersOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    imageUrl?: SortOrder
    actionUrl?: SortOrderInput | SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    targetUserTypes?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: bannersOrderByRelevanceInput
  }

  export type bannersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: bannersWhereInput | bannersWhereInput[]
    OR?: bannersWhereInput[]
    NOT?: bannersWhereInput | bannersWhereInput[]
    title?: StringFilter<"banners"> | string
    description?: StringNullableFilter<"banners"> | string | null
    imageUrl?: StringFilter<"banners"> | string
    actionUrl?: StringNullableFilter<"banners"> | string | null
    isActive?: BoolFilter<"banners"> | boolean
    sortOrder?: IntFilter<"banners"> | number
    targetUserTypes?: JsonFilter<"banners">
    startDate?: DateTimeNullableFilter<"banners"> | Date | string | null
    endDate?: DateTimeNullableFilter<"banners"> | Date | string | null
    createdAt?: DateTimeFilter<"banners"> | Date | string
    updatedAt?: DateTimeFilter<"banners"> | Date | string
  }, "id">

  export type bannersOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    imageUrl?: SortOrder
    actionUrl?: SortOrderInput | SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    targetUserTypes?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: bannersCountOrderByAggregateInput
    _avg?: bannersAvgOrderByAggregateInput
    _max?: bannersMaxOrderByAggregateInput
    _min?: bannersMinOrderByAggregateInput
    _sum?: bannersSumOrderByAggregateInput
  }

  export type bannersScalarWhereWithAggregatesInput = {
    AND?: bannersScalarWhereWithAggregatesInput | bannersScalarWhereWithAggregatesInput[]
    OR?: bannersScalarWhereWithAggregatesInput[]
    NOT?: bannersScalarWhereWithAggregatesInput | bannersScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"banners"> | string
    title?: StringWithAggregatesFilter<"banners"> | string
    description?: StringNullableWithAggregatesFilter<"banners"> | string | null
    imageUrl?: StringWithAggregatesFilter<"banners"> | string
    actionUrl?: StringNullableWithAggregatesFilter<"banners"> | string | null
    isActive?: BoolWithAggregatesFilter<"banners"> | boolean
    sortOrder?: IntWithAggregatesFilter<"banners"> | number
    targetUserTypes?: JsonWithAggregatesFilter<"banners">
    startDate?: DateTimeNullableWithAggregatesFilter<"banners"> | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter<"banners"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"banners"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"banners"> | Date | string
  }

  export type coin_transactionsWhereInput = {
    AND?: coin_transactionsWhereInput | coin_transactionsWhereInput[]
    OR?: coin_transactionsWhereInput[]
    NOT?: coin_transactionsWhereInput | coin_transactionsWhereInput[]
    id?: StringFilter<"coin_transactions"> | string
    userId?: StringFilter<"coin_transactions"> | string
    type?: Enumcoin_transactions_typeFilter<"coin_transactions"> | $Enums.coin_transactions_type
    amount?: IntFilter<"coin_transactions"> | number
    description?: StringFilter<"coin_transactions"> | string
    loanId?: StringNullableFilter<"coin_transactions"> | string | null
    rewardId?: StringNullableFilter<"coin_transactions"> | string | null
    createdAt?: DateTimeFilter<"coin_transactions"> | Date | string
  }

  export type coin_transactionsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    loanId?: SortOrderInput | SortOrder
    rewardId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _relevance?: coin_transactionsOrderByRelevanceInput
  }

  export type coin_transactionsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: coin_transactionsWhereInput | coin_transactionsWhereInput[]
    OR?: coin_transactionsWhereInput[]
    NOT?: coin_transactionsWhereInput | coin_transactionsWhereInput[]
    userId?: StringFilter<"coin_transactions"> | string
    type?: Enumcoin_transactions_typeFilter<"coin_transactions"> | $Enums.coin_transactions_type
    amount?: IntFilter<"coin_transactions"> | number
    description?: StringFilter<"coin_transactions"> | string
    loanId?: StringNullableFilter<"coin_transactions"> | string | null
    rewardId?: StringNullableFilter<"coin_transactions"> | string | null
    createdAt?: DateTimeFilter<"coin_transactions"> | Date | string
  }, "id">

  export type coin_transactionsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    loanId?: SortOrderInput | SortOrder
    rewardId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: coin_transactionsCountOrderByAggregateInput
    _avg?: coin_transactionsAvgOrderByAggregateInput
    _max?: coin_transactionsMaxOrderByAggregateInput
    _min?: coin_transactionsMinOrderByAggregateInput
    _sum?: coin_transactionsSumOrderByAggregateInput
  }

  export type coin_transactionsScalarWhereWithAggregatesInput = {
    AND?: coin_transactionsScalarWhereWithAggregatesInput | coin_transactionsScalarWhereWithAggregatesInput[]
    OR?: coin_transactionsScalarWhereWithAggregatesInput[]
    NOT?: coin_transactionsScalarWhereWithAggregatesInput | coin_transactionsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"coin_transactions"> | string
    userId?: StringWithAggregatesFilter<"coin_transactions"> | string
    type?: Enumcoin_transactions_typeWithAggregatesFilter<"coin_transactions"> | $Enums.coin_transactions_type
    amount?: IntWithAggregatesFilter<"coin_transactions"> | number
    description?: StringWithAggregatesFilter<"coin_transactions"> | string
    loanId?: StringNullableWithAggregatesFilter<"coin_transactions"> | string | null
    rewardId?: StringNullableWithAggregatesFilter<"coin_transactions"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"coin_transactions"> | Date | string
  }

  export type loan_applicationsWhereInput = {
    AND?: loan_applicationsWhereInput | loan_applicationsWhereInput[]
    OR?: loan_applicationsWhereInput[]
    NOT?: loan_applicationsWhereInput | loan_applicationsWhereInput[]
    id?: StringFilter<"loan_applications"> | string
    customerId?: StringFilter<"loan_applications"> | string
    agentId?: StringNullableFilter<"loan_applications"> | string | null
    loanType?: Enumloan_applications_loanTypeFilter<"loan_applications"> | $Enums.loan_applications_loanType
    status?: Enumloan_applications_statusFilter<"loan_applications"> | $Enums.loan_applications_status
    currentStep?: IntFilter<"loan_applications"> | number
    completedSteps?: JsonFilter<"loan_applications">
    isNewUser?: BoolFilter<"loan_applications"> | boolean
    submittedByAgent?: BoolFilter<"loan_applications"> | boolean
    titleDeedImage?: StringNullableFilter<"loan_applications"> | string | null
    titleDeedData?: JsonNullableFilter<"loan_applications">
    supportingImages?: JsonFilter<"loan_applications">
    idCardFrontImage?: StringNullableFilter<"loan_applications"> | string | null
    idCardBackImage?: StringNullableFilter<"loan_applications"> | string | null
    requestedAmount?: DecimalFilter<"loan_applications"> | Decimal | DecimalJsLike | number | string
    approvedAmount?: DecimalNullableFilter<"loan_applications"> | Decimal | DecimalJsLike | number | string | null
    maxApprovedAmount?: DecimalNullableFilter<"loan_applications"> | Decimal | DecimalJsLike | number | string | null
    propertyType?: StringNullableFilter<"loan_applications"> | string | null
    propertyValue?: DecimalNullableFilter<"loan_applications"> | Decimal | DecimalJsLike | number | string | null
    propertyArea?: StringNullableFilter<"loan_applications"> | string | null
    propertyLocation?: StringNullableFilter<"loan_applications"> | string | null
    landNumber?: StringNullableFilter<"loan_applications"> | string | null
    ownerName?: StringNullableFilter<"loan_applications"> | string | null
    submittedAt?: DateTimeNullableFilter<"loan_applications"> | Date | string | null
    reviewedAt?: DateTimeNullableFilter<"loan_applications"> | Date | string | null
    reviewedBy?: StringNullableFilter<"loan_applications"> | string | null
    reviewNotes?: StringNullableFilter<"loan_applications"> | string | null
    createdAt?: DateTimeFilter<"loan_applications"> | Date | string
    updatedAt?: DateTimeFilter<"loan_applications"> | Date | string
  }

  export type loan_applicationsOrderByWithRelationInput = {
    id?: SortOrder
    customerId?: SortOrder
    agentId?: SortOrderInput | SortOrder
    loanType?: SortOrder
    status?: SortOrder
    currentStep?: SortOrder
    completedSteps?: SortOrder
    isNewUser?: SortOrder
    submittedByAgent?: SortOrder
    titleDeedImage?: SortOrderInput | SortOrder
    titleDeedData?: SortOrderInput | SortOrder
    supportingImages?: SortOrder
    idCardFrontImage?: SortOrderInput | SortOrder
    idCardBackImage?: SortOrderInput | SortOrder
    requestedAmount?: SortOrder
    approvedAmount?: SortOrderInput | SortOrder
    maxApprovedAmount?: SortOrderInput | SortOrder
    propertyType?: SortOrderInput | SortOrder
    propertyValue?: SortOrderInput | SortOrder
    propertyArea?: SortOrderInput | SortOrder
    propertyLocation?: SortOrderInput | SortOrder
    landNumber?: SortOrderInput | SortOrder
    ownerName?: SortOrderInput | SortOrder
    submittedAt?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    reviewedBy?: SortOrderInput | SortOrder
    reviewNotes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: loan_applicationsOrderByRelevanceInput
  }

  export type loan_applicationsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: loan_applicationsWhereInput | loan_applicationsWhereInput[]
    OR?: loan_applicationsWhereInput[]
    NOT?: loan_applicationsWhereInput | loan_applicationsWhereInput[]
    customerId?: StringFilter<"loan_applications"> | string
    agentId?: StringNullableFilter<"loan_applications"> | string | null
    loanType?: Enumloan_applications_loanTypeFilter<"loan_applications"> | $Enums.loan_applications_loanType
    status?: Enumloan_applications_statusFilter<"loan_applications"> | $Enums.loan_applications_status
    currentStep?: IntFilter<"loan_applications"> | number
    completedSteps?: JsonFilter<"loan_applications">
    isNewUser?: BoolFilter<"loan_applications"> | boolean
    submittedByAgent?: BoolFilter<"loan_applications"> | boolean
    titleDeedImage?: StringNullableFilter<"loan_applications"> | string | null
    titleDeedData?: JsonNullableFilter<"loan_applications">
    supportingImages?: JsonFilter<"loan_applications">
    idCardFrontImage?: StringNullableFilter<"loan_applications"> | string | null
    idCardBackImage?: StringNullableFilter<"loan_applications"> | string | null
    requestedAmount?: DecimalFilter<"loan_applications"> | Decimal | DecimalJsLike | number | string
    approvedAmount?: DecimalNullableFilter<"loan_applications"> | Decimal | DecimalJsLike | number | string | null
    maxApprovedAmount?: DecimalNullableFilter<"loan_applications"> | Decimal | DecimalJsLike | number | string | null
    propertyType?: StringNullableFilter<"loan_applications"> | string | null
    propertyValue?: DecimalNullableFilter<"loan_applications"> | Decimal | DecimalJsLike | number | string | null
    propertyArea?: StringNullableFilter<"loan_applications"> | string | null
    propertyLocation?: StringNullableFilter<"loan_applications"> | string | null
    landNumber?: StringNullableFilter<"loan_applications"> | string | null
    ownerName?: StringNullableFilter<"loan_applications"> | string | null
    submittedAt?: DateTimeNullableFilter<"loan_applications"> | Date | string | null
    reviewedAt?: DateTimeNullableFilter<"loan_applications"> | Date | string | null
    reviewedBy?: StringNullableFilter<"loan_applications"> | string | null
    reviewNotes?: StringNullableFilter<"loan_applications"> | string | null
    createdAt?: DateTimeFilter<"loan_applications"> | Date | string
    updatedAt?: DateTimeFilter<"loan_applications"> | Date | string
  }, "id">

  export type loan_applicationsOrderByWithAggregationInput = {
    id?: SortOrder
    customerId?: SortOrder
    agentId?: SortOrderInput | SortOrder
    loanType?: SortOrder
    status?: SortOrder
    currentStep?: SortOrder
    completedSteps?: SortOrder
    isNewUser?: SortOrder
    submittedByAgent?: SortOrder
    titleDeedImage?: SortOrderInput | SortOrder
    titleDeedData?: SortOrderInput | SortOrder
    supportingImages?: SortOrder
    idCardFrontImage?: SortOrderInput | SortOrder
    idCardBackImage?: SortOrderInput | SortOrder
    requestedAmount?: SortOrder
    approvedAmount?: SortOrderInput | SortOrder
    maxApprovedAmount?: SortOrderInput | SortOrder
    propertyType?: SortOrderInput | SortOrder
    propertyValue?: SortOrderInput | SortOrder
    propertyArea?: SortOrderInput | SortOrder
    propertyLocation?: SortOrderInput | SortOrder
    landNumber?: SortOrderInput | SortOrder
    ownerName?: SortOrderInput | SortOrder
    submittedAt?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    reviewedBy?: SortOrderInput | SortOrder
    reviewNotes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: loan_applicationsCountOrderByAggregateInput
    _avg?: loan_applicationsAvgOrderByAggregateInput
    _max?: loan_applicationsMaxOrderByAggregateInput
    _min?: loan_applicationsMinOrderByAggregateInput
    _sum?: loan_applicationsSumOrderByAggregateInput
  }

  export type loan_applicationsScalarWhereWithAggregatesInput = {
    AND?: loan_applicationsScalarWhereWithAggregatesInput | loan_applicationsScalarWhereWithAggregatesInput[]
    OR?: loan_applicationsScalarWhereWithAggregatesInput[]
    NOT?: loan_applicationsScalarWhereWithAggregatesInput | loan_applicationsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"loan_applications"> | string
    customerId?: StringWithAggregatesFilter<"loan_applications"> | string
    agentId?: StringNullableWithAggregatesFilter<"loan_applications"> | string | null
    loanType?: Enumloan_applications_loanTypeWithAggregatesFilter<"loan_applications"> | $Enums.loan_applications_loanType
    status?: Enumloan_applications_statusWithAggregatesFilter<"loan_applications"> | $Enums.loan_applications_status
    currentStep?: IntWithAggregatesFilter<"loan_applications"> | number
    completedSteps?: JsonWithAggregatesFilter<"loan_applications">
    isNewUser?: BoolWithAggregatesFilter<"loan_applications"> | boolean
    submittedByAgent?: BoolWithAggregatesFilter<"loan_applications"> | boolean
    titleDeedImage?: StringNullableWithAggregatesFilter<"loan_applications"> | string | null
    titleDeedData?: JsonNullableWithAggregatesFilter<"loan_applications">
    supportingImages?: JsonWithAggregatesFilter<"loan_applications">
    idCardFrontImage?: StringNullableWithAggregatesFilter<"loan_applications"> | string | null
    idCardBackImage?: StringNullableWithAggregatesFilter<"loan_applications"> | string | null
    requestedAmount?: DecimalWithAggregatesFilter<"loan_applications"> | Decimal | DecimalJsLike | number | string
    approvedAmount?: DecimalNullableWithAggregatesFilter<"loan_applications"> | Decimal | DecimalJsLike | number | string | null
    maxApprovedAmount?: DecimalNullableWithAggregatesFilter<"loan_applications"> | Decimal | DecimalJsLike | number | string | null
    propertyType?: StringNullableWithAggregatesFilter<"loan_applications"> | string | null
    propertyValue?: DecimalNullableWithAggregatesFilter<"loan_applications"> | Decimal | DecimalJsLike | number | string | null
    propertyArea?: StringNullableWithAggregatesFilter<"loan_applications"> | string | null
    propertyLocation?: StringNullableWithAggregatesFilter<"loan_applications"> | string | null
    landNumber?: StringNullableWithAggregatesFilter<"loan_applications"> | string | null
    ownerName?: StringNullableWithAggregatesFilter<"loan_applications"> | string | null
    submittedAt?: DateTimeNullableWithAggregatesFilter<"loan_applications"> | Date | string | null
    reviewedAt?: DateTimeNullableWithAggregatesFilter<"loan_applications"> | Date | string | null
    reviewedBy?: StringNullableWithAggregatesFilter<"loan_applications"> | string | null
    reviewNotes?: StringNullableWithAggregatesFilter<"loan_applications"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"loan_applications"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"loan_applications"> | Date | string
  }

  export type loan_installmentsWhereInput = {
    AND?: loan_installmentsWhereInput | loan_installmentsWhereInput[]
    OR?: loan_installmentsWhereInput[]
    NOT?: loan_installmentsWhereInput | loan_installmentsWhereInput[]
    id?: StringFilter<"loan_installments"> | string
    loanId?: StringFilter<"loan_installments"> | string
    installmentNumber?: IntFilter<"loan_installments"> | number
    dueDate?: DateTimeFilter<"loan_installments"> | Date | string
    principalAmount?: DecimalFilter<"loan_installments"> | Decimal | DecimalJsLike | number | string
    interestAmount?: DecimalFilter<"loan_installments"> | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFilter<"loan_installments"> | Decimal | DecimalJsLike | number | string
    isPaid?: BoolFilter<"loan_installments"> | boolean
    paidDate?: DateTimeNullableFilter<"loan_installments"> | Date | string | null
    paidAmount?: DecimalNullableFilter<"loan_installments"> | Decimal | DecimalJsLike | number | string | null
    isLate?: BoolFilter<"loan_installments"> | boolean
    lateDays?: IntNullableFilter<"loan_installments"> | number | null
    lateFee?: DecimalNullableFilter<"loan_installments"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"loan_installments"> | Date | string
    updatedAt?: DateTimeFilter<"loan_installments"> | Date | string
  }

  export type loan_installmentsOrderByWithRelationInput = {
    id?: SortOrder
    loanId?: SortOrder
    installmentNumber?: SortOrder
    dueDate?: SortOrder
    principalAmount?: SortOrder
    interestAmount?: SortOrder
    totalAmount?: SortOrder
    isPaid?: SortOrder
    paidDate?: SortOrderInput | SortOrder
    paidAmount?: SortOrderInput | SortOrder
    isLate?: SortOrder
    lateDays?: SortOrderInput | SortOrder
    lateFee?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: loan_installmentsOrderByRelevanceInput
  }

  export type loan_installmentsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    loanId_installmentNumber?: loan_installmentsLoanIdInstallmentNumberCompoundUniqueInput
    AND?: loan_installmentsWhereInput | loan_installmentsWhereInput[]
    OR?: loan_installmentsWhereInput[]
    NOT?: loan_installmentsWhereInput | loan_installmentsWhereInput[]
    loanId?: StringFilter<"loan_installments"> | string
    installmentNumber?: IntFilter<"loan_installments"> | number
    dueDate?: DateTimeFilter<"loan_installments"> | Date | string
    principalAmount?: DecimalFilter<"loan_installments"> | Decimal | DecimalJsLike | number | string
    interestAmount?: DecimalFilter<"loan_installments"> | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFilter<"loan_installments"> | Decimal | DecimalJsLike | number | string
    isPaid?: BoolFilter<"loan_installments"> | boolean
    paidDate?: DateTimeNullableFilter<"loan_installments"> | Date | string | null
    paidAmount?: DecimalNullableFilter<"loan_installments"> | Decimal | DecimalJsLike | number | string | null
    isLate?: BoolFilter<"loan_installments"> | boolean
    lateDays?: IntNullableFilter<"loan_installments"> | number | null
    lateFee?: DecimalNullableFilter<"loan_installments"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"loan_installments"> | Date | string
    updatedAt?: DateTimeFilter<"loan_installments"> | Date | string
  }, "id" | "loanId_installmentNumber">

  export type loan_installmentsOrderByWithAggregationInput = {
    id?: SortOrder
    loanId?: SortOrder
    installmentNumber?: SortOrder
    dueDate?: SortOrder
    principalAmount?: SortOrder
    interestAmount?: SortOrder
    totalAmount?: SortOrder
    isPaid?: SortOrder
    paidDate?: SortOrderInput | SortOrder
    paidAmount?: SortOrderInput | SortOrder
    isLate?: SortOrder
    lateDays?: SortOrderInput | SortOrder
    lateFee?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: loan_installmentsCountOrderByAggregateInput
    _avg?: loan_installmentsAvgOrderByAggregateInput
    _max?: loan_installmentsMaxOrderByAggregateInput
    _min?: loan_installmentsMinOrderByAggregateInput
    _sum?: loan_installmentsSumOrderByAggregateInput
  }

  export type loan_installmentsScalarWhereWithAggregatesInput = {
    AND?: loan_installmentsScalarWhereWithAggregatesInput | loan_installmentsScalarWhereWithAggregatesInput[]
    OR?: loan_installmentsScalarWhereWithAggregatesInput[]
    NOT?: loan_installmentsScalarWhereWithAggregatesInput | loan_installmentsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"loan_installments"> | string
    loanId?: StringWithAggregatesFilter<"loan_installments"> | string
    installmentNumber?: IntWithAggregatesFilter<"loan_installments"> | number
    dueDate?: DateTimeWithAggregatesFilter<"loan_installments"> | Date | string
    principalAmount?: DecimalWithAggregatesFilter<"loan_installments"> | Decimal | DecimalJsLike | number | string
    interestAmount?: DecimalWithAggregatesFilter<"loan_installments"> | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalWithAggregatesFilter<"loan_installments"> | Decimal | DecimalJsLike | number | string
    isPaid?: BoolWithAggregatesFilter<"loan_installments"> | boolean
    paidDate?: DateTimeNullableWithAggregatesFilter<"loan_installments"> | Date | string | null
    paidAmount?: DecimalNullableWithAggregatesFilter<"loan_installments"> | Decimal | DecimalJsLike | number | string | null
    isLate?: BoolWithAggregatesFilter<"loan_installments"> | boolean
    lateDays?: IntNullableWithAggregatesFilter<"loan_installments"> | number | null
    lateFee?: DecimalNullableWithAggregatesFilter<"loan_installments"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeWithAggregatesFilter<"loan_installments"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"loan_installments"> | Date | string
  }

  export type loansWhereInput = {
    AND?: loansWhereInput | loansWhereInput[]
    OR?: loansWhereInput[]
    NOT?: loansWhereInput | loansWhereInput[]
    id?: StringFilter<"loans"> | string
    loanNumber?: StringFilter<"loans"> | string
    customerId?: StringFilter<"loans"> | string
    agentId?: StringNullableFilter<"loans"> | string | null
    applicationId?: StringFilter<"loans"> | string
    loanType?: Enumloans_loanTypeFilter<"loans"> | $Enums.loans_loanType
    status?: Enumloans_statusFilter<"loans"> | $Enums.loans_status
    principalAmount?: DecimalFilter<"loans"> | Decimal | DecimalJsLike | number | string
    interestRate?: DecimalFilter<"loans"> | Decimal | DecimalJsLike | number | string
    termMonths?: IntFilter<"loans"> | number
    monthlyPayment?: DecimalFilter<"loans"> | Decimal | DecimalJsLike | number | string
    currentInstallment?: IntFilter<"loans"> | number
    totalInstallments?: IntFilter<"loans"> | number
    remainingBalance?: DecimalFilter<"loans"> | Decimal | DecimalJsLike | number | string
    nextPaymentDate?: DateTimeFilter<"loans"> | Date | string
    contractDate?: DateTimeFilter<"loans"> | Date | string
    expiryDate?: DateTimeFilter<"loans"> | Date | string
    titleDeedNumber?: StringNullableFilter<"loans"> | string | null
    collateralValue?: DecimalNullableFilter<"loans"> | Decimal | DecimalJsLike | number | string | null
    collateralDetails?: JsonNullableFilter<"loans">
    linkMap?: StringNullableFilter<"loans"> | string | null
    landAccountId?: IntNullableFilter<"loans"> | number | null
    landAccountName?: StringNullableFilter<"loans"> | string | null
    createdAt?: DateTimeFilter<"loans"> | Date | string
    updatedAt?: DateTimeFilter<"loans"> | Date | string
  }

  export type loansOrderByWithRelationInput = {
    id?: SortOrder
    loanNumber?: SortOrder
    customerId?: SortOrder
    agentId?: SortOrderInput | SortOrder
    applicationId?: SortOrder
    loanType?: SortOrder
    status?: SortOrder
    principalAmount?: SortOrder
    interestRate?: SortOrder
    termMonths?: SortOrder
    monthlyPayment?: SortOrder
    currentInstallment?: SortOrder
    totalInstallments?: SortOrder
    remainingBalance?: SortOrder
    nextPaymentDate?: SortOrder
    contractDate?: SortOrder
    expiryDate?: SortOrder
    titleDeedNumber?: SortOrderInput | SortOrder
    collateralValue?: SortOrderInput | SortOrder
    collateralDetails?: SortOrderInput | SortOrder
    linkMap?: SortOrderInput | SortOrder
    landAccountId?: SortOrderInput | SortOrder
    landAccountName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: loansOrderByRelevanceInput
  }

  export type loansWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    loanNumber?: string
    applicationId?: string
    AND?: loansWhereInput | loansWhereInput[]
    OR?: loansWhereInput[]
    NOT?: loansWhereInput | loansWhereInput[]
    customerId?: StringFilter<"loans"> | string
    agentId?: StringNullableFilter<"loans"> | string | null
    loanType?: Enumloans_loanTypeFilter<"loans"> | $Enums.loans_loanType
    status?: Enumloans_statusFilter<"loans"> | $Enums.loans_status
    principalAmount?: DecimalFilter<"loans"> | Decimal | DecimalJsLike | number | string
    interestRate?: DecimalFilter<"loans"> | Decimal | DecimalJsLike | number | string
    termMonths?: IntFilter<"loans"> | number
    monthlyPayment?: DecimalFilter<"loans"> | Decimal | DecimalJsLike | number | string
    currentInstallment?: IntFilter<"loans"> | number
    totalInstallments?: IntFilter<"loans"> | number
    remainingBalance?: DecimalFilter<"loans"> | Decimal | DecimalJsLike | number | string
    nextPaymentDate?: DateTimeFilter<"loans"> | Date | string
    contractDate?: DateTimeFilter<"loans"> | Date | string
    expiryDate?: DateTimeFilter<"loans"> | Date | string
    titleDeedNumber?: StringNullableFilter<"loans"> | string | null
    collateralValue?: DecimalNullableFilter<"loans"> | Decimal | DecimalJsLike | number | string | null
    collateralDetails?: JsonNullableFilter<"loans">
    linkMap?: StringNullableFilter<"loans"> | string | null
    landAccountId?: IntNullableFilter<"loans"> | number | null
    landAccountName?: StringNullableFilter<"loans"> | string | null
    createdAt?: DateTimeFilter<"loans"> | Date | string
    updatedAt?: DateTimeFilter<"loans"> | Date | string
  }, "id" | "loanNumber" | "applicationId">

  export type loansOrderByWithAggregationInput = {
    id?: SortOrder
    loanNumber?: SortOrder
    customerId?: SortOrder
    agentId?: SortOrderInput | SortOrder
    applicationId?: SortOrder
    loanType?: SortOrder
    status?: SortOrder
    principalAmount?: SortOrder
    interestRate?: SortOrder
    termMonths?: SortOrder
    monthlyPayment?: SortOrder
    currentInstallment?: SortOrder
    totalInstallments?: SortOrder
    remainingBalance?: SortOrder
    nextPaymentDate?: SortOrder
    contractDate?: SortOrder
    expiryDate?: SortOrder
    titleDeedNumber?: SortOrderInput | SortOrder
    collateralValue?: SortOrderInput | SortOrder
    collateralDetails?: SortOrderInput | SortOrder
    linkMap?: SortOrderInput | SortOrder
    landAccountId?: SortOrderInput | SortOrder
    landAccountName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: loansCountOrderByAggregateInput
    _avg?: loansAvgOrderByAggregateInput
    _max?: loansMaxOrderByAggregateInput
    _min?: loansMinOrderByAggregateInput
    _sum?: loansSumOrderByAggregateInput
  }

  export type loansScalarWhereWithAggregatesInput = {
    AND?: loansScalarWhereWithAggregatesInput | loansScalarWhereWithAggregatesInput[]
    OR?: loansScalarWhereWithAggregatesInput[]
    NOT?: loansScalarWhereWithAggregatesInput | loansScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"loans"> | string
    loanNumber?: StringWithAggregatesFilter<"loans"> | string
    customerId?: StringWithAggregatesFilter<"loans"> | string
    agentId?: StringNullableWithAggregatesFilter<"loans"> | string | null
    applicationId?: StringWithAggregatesFilter<"loans"> | string
    loanType?: Enumloans_loanTypeWithAggregatesFilter<"loans"> | $Enums.loans_loanType
    status?: Enumloans_statusWithAggregatesFilter<"loans"> | $Enums.loans_status
    principalAmount?: DecimalWithAggregatesFilter<"loans"> | Decimal | DecimalJsLike | number | string
    interestRate?: DecimalWithAggregatesFilter<"loans"> | Decimal | DecimalJsLike | number | string
    termMonths?: IntWithAggregatesFilter<"loans"> | number
    monthlyPayment?: DecimalWithAggregatesFilter<"loans"> | Decimal | DecimalJsLike | number | string
    currentInstallment?: IntWithAggregatesFilter<"loans"> | number
    totalInstallments?: IntWithAggregatesFilter<"loans"> | number
    remainingBalance?: DecimalWithAggregatesFilter<"loans"> | Decimal | DecimalJsLike | number | string
    nextPaymentDate?: DateTimeWithAggregatesFilter<"loans"> | Date | string
    contractDate?: DateTimeWithAggregatesFilter<"loans"> | Date | string
    expiryDate?: DateTimeWithAggregatesFilter<"loans"> | Date | string
    titleDeedNumber?: StringNullableWithAggregatesFilter<"loans"> | string | null
    collateralValue?: DecimalNullableWithAggregatesFilter<"loans"> | Decimal | DecimalJsLike | number | string | null
    collateralDetails?: JsonNullableWithAggregatesFilter<"loans">
    linkMap?: StringNullableWithAggregatesFilter<"loans"> | string | null
    landAccountId?: IntNullableWithAggregatesFilter<"loans"> | number | null
    landAccountName?: StringNullableWithAggregatesFilter<"loans"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"loans"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"loans"> | Date | string
  }

  export type notificationsWhereInput = {
    AND?: notificationsWhereInput | notificationsWhereInput[]
    OR?: notificationsWhereInput[]
    NOT?: notificationsWhereInput | notificationsWhereInput[]
    id?: StringFilter<"notifications"> | string
    userId?: StringFilter<"notifications"> | string
    type?: Enumnotifications_typeFilter<"notifications"> | $Enums.notifications_type
    title?: StringFilter<"notifications"> | string
    message?: StringFilter<"notifications"> | string
    actionUrl?: StringNullableFilter<"notifications"> | string | null
    isRead?: BoolFilter<"notifications"> | boolean
    readAt?: DateTimeNullableFilter<"notifications"> | Date | string | null
    createdAt?: DateTimeFilter<"notifications"> | Date | string
    updatedAt?: DateTimeFilter<"notifications"> | Date | string
  }

  export type notificationsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    actionUrl?: SortOrderInput | SortOrder
    isRead?: SortOrder
    readAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: notificationsOrderByRelevanceInput
  }

  export type notificationsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: notificationsWhereInput | notificationsWhereInput[]
    OR?: notificationsWhereInput[]
    NOT?: notificationsWhereInput | notificationsWhereInput[]
    userId?: StringFilter<"notifications"> | string
    type?: Enumnotifications_typeFilter<"notifications"> | $Enums.notifications_type
    title?: StringFilter<"notifications"> | string
    message?: StringFilter<"notifications"> | string
    actionUrl?: StringNullableFilter<"notifications"> | string | null
    isRead?: BoolFilter<"notifications"> | boolean
    readAt?: DateTimeNullableFilter<"notifications"> | Date | string | null
    createdAt?: DateTimeFilter<"notifications"> | Date | string
    updatedAt?: DateTimeFilter<"notifications"> | Date | string
  }, "id">

  export type notificationsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    actionUrl?: SortOrderInput | SortOrder
    isRead?: SortOrder
    readAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: notificationsCountOrderByAggregateInput
    _max?: notificationsMaxOrderByAggregateInput
    _min?: notificationsMinOrderByAggregateInput
  }

  export type notificationsScalarWhereWithAggregatesInput = {
    AND?: notificationsScalarWhereWithAggregatesInput | notificationsScalarWhereWithAggregatesInput[]
    OR?: notificationsScalarWhereWithAggregatesInput[]
    NOT?: notificationsScalarWhereWithAggregatesInput | notificationsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"notifications"> | string
    userId?: StringWithAggregatesFilter<"notifications"> | string
    type?: Enumnotifications_typeWithAggregatesFilter<"notifications"> | $Enums.notifications_type
    title?: StringWithAggregatesFilter<"notifications"> | string
    message?: StringWithAggregatesFilter<"notifications"> | string
    actionUrl?: StringNullableWithAggregatesFilter<"notifications"> | string | null
    isRead?: BoolWithAggregatesFilter<"notifications"> | boolean
    readAt?: DateTimeNullableWithAggregatesFilter<"notifications"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"notifications"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"notifications"> | Date | string
  }

  export type paymentsWhereInput = {
    AND?: paymentsWhereInput | paymentsWhereInput[]
    OR?: paymentsWhereInput[]
    NOT?: paymentsWhereInput | paymentsWhereInput[]
    id?: StringFilter<"payments"> | string
    userId?: StringFilter<"payments"> | string
    loanId?: StringFilter<"payments"> | string
    installmentId?: StringNullableFilter<"payments"> | string | null
    amount?: DecimalFilter<"payments"> | Decimal | DecimalJsLike | number | string
    paymentMethod?: Enumpayments_paymentMethodFilter<"payments"> | $Enums.payments_paymentMethod
    status?: Enumpayments_statusFilter<"payments"> | $Enums.payments_status
    referenceNumber?: StringFilter<"payments"> | string
    transactionId?: StringNullableFilter<"payments"> | string | null
    qrCode?: StringNullableFilter<"payments"> | string | null
    barcodeNumber?: StringNullableFilter<"payments"> | string | null
    bankName?: StringNullableFilter<"payments"> | string | null
    accountNumber?: StringNullableFilter<"payments"> | string | null
    accountName?: StringNullableFilter<"payments"> | string | null
    dueDate?: DateTimeFilter<"payments"> | Date | string
    paidDate?: DateTimeNullableFilter<"payments"> | Date | string | null
    principalAmount?: DecimalFilter<"payments"> | Decimal | DecimalJsLike | number | string
    interestAmount?: DecimalFilter<"payments"> | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalFilter<"payments"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"payments"> | Date | string
    updatedAt?: DateTimeFilter<"payments"> | Date | string
  }

  export type paymentsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    loanId?: SortOrder
    installmentId?: SortOrderInput | SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    status?: SortOrder
    referenceNumber?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    qrCode?: SortOrderInput | SortOrder
    barcodeNumber?: SortOrderInput | SortOrder
    bankName?: SortOrderInput | SortOrder
    accountNumber?: SortOrderInput | SortOrder
    accountName?: SortOrderInput | SortOrder
    dueDate?: SortOrder
    paidDate?: SortOrderInput | SortOrder
    principalAmount?: SortOrder
    interestAmount?: SortOrder
    feeAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: paymentsOrderByRelevanceInput
  }

  export type paymentsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    referenceNumber?: string
    AND?: paymentsWhereInput | paymentsWhereInput[]
    OR?: paymentsWhereInput[]
    NOT?: paymentsWhereInput | paymentsWhereInput[]
    userId?: StringFilter<"payments"> | string
    loanId?: StringFilter<"payments"> | string
    installmentId?: StringNullableFilter<"payments"> | string | null
    amount?: DecimalFilter<"payments"> | Decimal | DecimalJsLike | number | string
    paymentMethod?: Enumpayments_paymentMethodFilter<"payments"> | $Enums.payments_paymentMethod
    status?: Enumpayments_statusFilter<"payments"> | $Enums.payments_status
    transactionId?: StringNullableFilter<"payments"> | string | null
    qrCode?: StringNullableFilter<"payments"> | string | null
    barcodeNumber?: StringNullableFilter<"payments"> | string | null
    bankName?: StringNullableFilter<"payments"> | string | null
    accountNumber?: StringNullableFilter<"payments"> | string | null
    accountName?: StringNullableFilter<"payments"> | string | null
    dueDate?: DateTimeFilter<"payments"> | Date | string
    paidDate?: DateTimeNullableFilter<"payments"> | Date | string | null
    principalAmount?: DecimalFilter<"payments"> | Decimal | DecimalJsLike | number | string
    interestAmount?: DecimalFilter<"payments"> | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalFilter<"payments"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"payments"> | Date | string
    updatedAt?: DateTimeFilter<"payments"> | Date | string
  }, "id" | "referenceNumber">

  export type paymentsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    loanId?: SortOrder
    installmentId?: SortOrderInput | SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    status?: SortOrder
    referenceNumber?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    qrCode?: SortOrderInput | SortOrder
    barcodeNumber?: SortOrderInput | SortOrder
    bankName?: SortOrderInput | SortOrder
    accountNumber?: SortOrderInput | SortOrder
    accountName?: SortOrderInput | SortOrder
    dueDate?: SortOrder
    paidDate?: SortOrderInput | SortOrder
    principalAmount?: SortOrder
    interestAmount?: SortOrder
    feeAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: paymentsCountOrderByAggregateInput
    _avg?: paymentsAvgOrderByAggregateInput
    _max?: paymentsMaxOrderByAggregateInput
    _min?: paymentsMinOrderByAggregateInput
    _sum?: paymentsSumOrderByAggregateInput
  }

  export type paymentsScalarWhereWithAggregatesInput = {
    AND?: paymentsScalarWhereWithAggregatesInput | paymentsScalarWhereWithAggregatesInput[]
    OR?: paymentsScalarWhereWithAggregatesInput[]
    NOT?: paymentsScalarWhereWithAggregatesInput | paymentsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"payments"> | string
    userId?: StringWithAggregatesFilter<"payments"> | string
    loanId?: StringWithAggregatesFilter<"payments"> | string
    installmentId?: StringNullableWithAggregatesFilter<"payments"> | string | null
    amount?: DecimalWithAggregatesFilter<"payments"> | Decimal | DecimalJsLike | number | string
    paymentMethod?: Enumpayments_paymentMethodWithAggregatesFilter<"payments"> | $Enums.payments_paymentMethod
    status?: Enumpayments_statusWithAggregatesFilter<"payments"> | $Enums.payments_status
    referenceNumber?: StringWithAggregatesFilter<"payments"> | string
    transactionId?: StringNullableWithAggregatesFilter<"payments"> | string | null
    qrCode?: StringNullableWithAggregatesFilter<"payments"> | string | null
    barcodeNumber?: StringNullableWithAggregatesFilter<"payments"> | string | null
    bankName?: StringNullableWithAggregatesFilter<"payments"> | string | null
    accountNumber?: StringNullableWithAggregatesFilter<"payments"> | string | null
    accountName?: StringNullableWithAggregatesFilter<"payments"> | string | null
    dueDate?: DateTimeWithAggregatesFilter<"payments"> | Date | string
    paidDate?: DateTimeNullableWithAggregatesFilter<"payments"> | Date | string | null
    principalAmount?: DecimalWithAggregatesFilter<"payments"> | Decimal | DecimalJsLike | number | string
    interestAmount?: DecimalWithAggregatesFilter<"payments"> | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalWithAggregatesFilter<"payments"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"payments"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"payments"> | Date | string
  }

  export type privilegesWhereInput = {
    AND?: privilegesWhereInput | privilegesWhereInput[]
    OR?: privilegesWhereInput[]
    NOT?: privilegesWhereInput | privilegesWhereInput[]
    id?: StringFilter<"privileges"> | string
    title?: StringFilter<"privileges"> | string
    description?: StringFilter<"privileges"> | string
    imageUrl?: StringNullableFilter<"privileges"> | string | null
    actionUrl?: StringNullableFilter<"privileges"> | string | null
    isActive?: BoolFilter<"privileges"> | boolean
    sortOrder?: IntFilter<"privileges"> | number
    targetUserTypes?: JsonFilter<"privileges">
    coinCost?: IntNullableFilter<"privileges"> | number | null
    requiresLoan?: BoolFilter<"privileges"> | boolean
    validFrom?: DateTimeNullableFilter<"privileges"> | Date | string | null
    validUntil?: DateTimeNullableFilter<"privileges"> | Date | string | null
    createdAt?: DateTimeFilter<"privileges"> | Date | string
    updatedAt?: DateTimeFilter<"privileges"> | Date | string
  }

  export type privilegesOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    actionUrl?: SortOrderInput | SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    targetUserTypes?: SortOrder
    coinCost?: SortOrderInput | SortOrder
    requiresLoan?: SortOrder
    validFrom?: SortOrderInput | SortOrder
    validUntil?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: privilegesOrderByRelevanceInput
  }

  export type privilegesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: privilegesWhereInput | privilegesWhereInput[]
    OR?: privilegesWhereInput[]
    NOT?: privilegesWhereInput | privilegesWhereInput[]
    title?: StringFilter<"privileges"> | string
    description?: StringFilter<"privileges"> | string
    imageUrl?: StringNullableFilter<"privileges"> | string | null
    actionUrl?: StringNullableFilter<"privileges"> | string | null
    isActive?: BoolFilter<"privileges"> | boolean
    sortOrder?: IntFilter<"privileges"> | number
    targetUserTypes?: JsonFilter<"privileges">
    coinCost?: IntNullableFilter<"privileges"> | number | null
    requiresLoan?: BoolFilter<"privileges"> | boolean
    validFrom?: DateTimeNullableFilter<"privileges"> | Date | string | null
    validUntil?: DateTimeNullableFilter<"privileges"> | Date | string | null
    createdAt?: DateTimeFilter<"privileges"> | Date | string
    updatedAt?: DateTimeFilter<"privileges"> | Date | string
  }, "id">

  export type privilegesOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    actionUrl?: SortOrderInput | SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    targetUserTypes?: SortOrder
    coinCost?: SortOrderInput | SortOrder
    requiresLoan?: SortOrder
    validFrom?: SortOrderInput | SortOrder
    validUntil?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: privilegesCountOrderByAggregateInput
    _avg?: privilegesAvgOrderByAggregateInput
    _max?: privilegesMaxOrderByAggregateInput
    _min?: privilegesMinOrderByAggregateInput
    _sum?: privilegesSumOrderByAggregateInput
  }

  export type privilegesScalarWhereWithAggregatesInput = {
    AND?: privilegesScalarWhereWithAggregatesInput | privilegesScalarWhereWithAggregatesInput[]
    OR?: privilegesScalarWhereWithAggregatesInput[]
    NOT?: privilegesScalarWhereWithAggregatesInput | privilegesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"privileges"> | string
    title?: StringWithAggregatesFilter<"privileges"> | string
    description?: StringWithAggregatesFilter<"privileges"> | string
    imageUrl?: StringNullableWithAggregatesFilter<"privileges"> | string | null
    actionUrl?: StringNullableWithAggregatesFilter<"privileges"> | string | null
    isActive?: BoolWithAggregatesFilter<"privileges"> | boolean
    sortOrder?: IntWithAggregatesFilter<"privileges"> | number
    targetUserTypes?: JsonWithAggregatesFilter<"privileges">
    coinCost?: IntNullableWithAggregatesFilter<"privileges"> | number | null
    requiresLoan?: BoolWithAggregatesFilter<"privileges"> | boolean
    validFrom?: DateTimeNullableWithAggregatesFilter<"privileges"> | Date | string | null
    validUntil?: DateTimeNullableWithAggregatesFilter<"privileges"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"privileges"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"privileges"> | Date | string
  }

  export type reward_redemptionsWhereInput = {
    AND?: reward_redemptionsWhereInput | reward_redemptionsWhereInput[]
    OR?: reward_redemptionsWhereInput[]
    NOT?: reward_redemptionsWhereInput | reward_redemptionsWhereInput[]
    id?: StringFilter<"reward_redemptions"> | string
    userId?: StringFilter<"reward_redemptions"> | string
    rewardId?: StringFilter<"reward_redemptions"> | string
    coinSpent?: IntFilter<"reward_redemptions"> | number
    status?: Enumreward_redemptions_statusFilter<"reward_redemptions"> | $Enums.reward_redemptions_status
    deliveryAddress?: StringNullableFilter<"reward_redemptions"> | string | null
    trackingNumber?: StringNullableFilter<"reward_redemptions"> | string | null
    redeemedAt?: DateTimeFilter<"reward_redemptions"> | Date | string
    deliveredAt?: DateTimeNullableFilter<"reward_redemptions"> | Date | string | null
  }

  export type reward_redemptionsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    rewardId?: SortOrder
    coinSpent?: SortOrder
    status?: SortOrder
    deliveryAddress?: SortOrderInput | SortOrder
    trackingNumber?: SortOrderInput | SortOrder
    redeemedAt?: SortOrder
    deliveredAt?: SortOrderInput | SortOrder
    _relevance?: reward_redemptionsOrderByRelevanceInput
  }

  export type reward_redemptionsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: reward_redemptionsWhereInput | reward_redemptionsWhereInput[]
    OR?: reward_redemptionsWhereInput[]
    NOT?: reward_redemptionsWhereInput | reward_redemptionsWhereInput[]
    userId?: StringFilter<"reward_redemptions"> | string
    rewardId?: StringFilter<"reward_redemptions"> | string
    coinSpent?: IntFilter<"reward_redemptions"> | number
    status?: Enumreward_redemptions_statusFilter<"reward_redemptions"> | $Enums.reward_redemptions_status
    deliveryAddress?: StringNullableFilter<"reward_redemptions"> | string | null
    trackingNumber?: StringNullableFilter<"reward_redemptions"> | string | null
    redeemedAt?: DateTimeFilter<"reward_redemptions"> | Date | string
    deliveredAt?: DateTimeNullableFilter<"reward_redemptions"> | Date | string | null
  }, "id">

  export type reward_redemptionsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    rewardId?: SortOrder
    coinSpent?: SortOrder
    status?: SortOrder
    deliveryAddress?: SortOrderInput | SortOrder
    trackingNumber?: SortOrderInput | SortOrder
    redeemedAt?: SortOrder
    deliveredAt?: SortOrderInput | SortOrder
    _count?: reward_redemptionsCountOrderByAggregateInput
    _avg?: reward_redemptionsAvgOrderByAggregateInput
    _max?: reward_redemptionsMaxOrderByAggregateInput
    _min?: reward_redemptionsMinOrderByAggregateInput
    _sum?: reward_redemptionsSumOrderByAggregateInput
  }

  export type reward_redemptionsScalarWhereWithAggregatesInput = {
    AND?: reward_redemptionsScalarWhereWithAggregatesInput | reward_redemptionsScalarWhereWithAggregatesInput[]
    OR?: reward_redemptionsScalarWhereWithAggregatesInput[]
    NOT?: reward_redemptionsScalarWhereWithAggregatesInput | reward_redemptionsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"reward_redemptions"> | string
    userId?: StringWithAggregatesFilter<"reward_redemptions"> | string
    rewardId?: StringWithAggregatesFilter<"reward_redemptions"> | string
    coinSpent?: IntWithAggregatesFilter<"reward_redemptions"> | number
    status?: Enumreward_redemptions_statusWithAggregatesFilter<"reward_redemptions"> | $Enums.reward_redemptions_status
    deliveryAddress?: StringNullableWithAggregatesFilter<"reward_redemptions"> | string | null
    trackingNumber?: StringNullableWithAggregatesFilter<"reward_redemptions"> | string | null
    redeemedAt?: DateTimeWithAggregatesFilter<"reward_redemptions"> | Date | string
    deliveredAt?: DateTimeNullableWithAggregatesFilter<"reward_redemptions"> | Date | string | null
  }

  export type rewardsWhereInput = {
    AND?: rewardsWhereInput | rewardsWhereInput[]
    OR?: rewardsWhereInput[]
    NOT?: rewardsWhereInput | rewardsWhereInput[]
    id?: StringFilter<"rewards"> | string
    name?: StringFilter<"rewards"> | string
    description?: StringFilter<"rewards"> | string
    coinCost?: IntFilter<"rewards"> | number
    imageUrl?: StringNullableFilter<"rewards"> | string | null
    isActive?: BoolFilter<"rewards"> | boolean
    stockCount?: IntNullableFilter<"rewards"> | number | null
    createdAt?: DateTimeFilter<"rewards"> | Date | string
    updatedAt?: DateTimeFilter<"rewards"> | Date | string
  }

  export type rewardsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    coinCost?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    isActive?: SortOrder
    stockCount?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: rewardsOrderByRelevanceInput
  }

  export type rewardsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: rewardsWhereInput | rewardsWhereInput[]
    OR?: rewardsWhereInput[]
    NOT?: rewardsWhereInput | rewardsWhereInput[]
    name?: StringFilter<"rewards"> | string
    description?: StringFilter<"rewards"> | string
    coinCost?: IntFilter<"rewards"> | number
    imageUrl?: StringNullableFilter<"rewards"> | string | null
    isActive?: BoolFilter<"rewards"> | boolean
    stockCount?: IntNullableFilter<"rewards"> | number | null
    createdAt?: DateTimeFilter<"rewards"> | Date | string
    updatedAt?: DateTimeFilter<"rewards"> | Date | string
  }, "id">

  export type rewardsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    coinCost?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    isActive?: SortOrder
    stockCount?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: rewardsCountOrderByAggregateInput
    _avg?: rewardsAvgOrderByAggregateInput
    _max?: rewardsMaxOrderByAggregateInput
    _min?: rewardsMinOrderByAggregateInput
    _sum?: rewardsSumOrderByAggregateInput
  }

  export type rewardsScalarWhereWithAggregatesInput = {
    AND?: rewardsScalarWhereWithAggregatesInput | rewardsScalarWhereWithAggregatesInput[]
    OR?: rewardsScalarWhereWithAggregatesInput[]
    NOT?: rewardsScalarWhereWithAggregatesInput | rewardsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"rewards"> | string
    name?: StringWithAggregatesFilter<"rewards"> | string
    description?: StringWithAggregatesFilter<"rewards"> | string
    coinCost?: IntWithAggregatesFilter<"rewards"> | number
    imageUrl?: StringNullableWithAggregatesFilter<"rewards"> | string | null
    isActive?: BoolWithAggregatesFilter<"rewards"> | boolean
    stockCount?: IntNullableWithAggregatesFilter<"rewards"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"rewards"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"rewards"> | Date | string
  }

  export type sessionsWhereInput = {
    AND?: sessionsWhereInput | sessionsWhereInput[]
    OR?: sessionsWhereInput[]
    NOT?: sessionsWhereInput | sessionsWhereInput[]
    id?: StringFilter<"sessions"> | string
    userId?: StringFilter<"sessions"> | string
    token?: StringFilter<"sessions"> | string
    deviceInfo?: StringNullableFilter<"sessions"> | string | null
    ipAddress?: StringNullableFilter<"sessions"> | string | null
    userAgent?: StringNullableFilter<"sessions"> | string | null
    expiresAt?: DateTimeFilter<"sessions"> | Date | string
    createdAt?: DateTimeFilter<"sessions"> | Date | string
  }

  export type sessionsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    deviceInfo?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    _relevance?: sessionsOrderByRelevanceInput
  }

  export type sessionsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: sessionsWhereInput | sessionsWhereInput[]
    OR?: sessionsWhereInput[]
    NOT?: sessionsWhereInput | sessionsWhereInput[]
    userId?: StringFilter<"sessions"> | string
    deviceInfo?: StringNullableFilter<"sessions"> | string | null
    ipAddress?: StringNullableFilter<"sessions"> | string | null
    userAgent?: StringNullableFilter<"sessions"> | string | null
    expiresAt?: DateTimeFilter<"sessions"> | Date | string
    createdAt?: DateTimeFilter<"sessions"> | Date | string
  }, "id" | "token">

  export type sessionsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    deviceInfo?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    _count?: sessionsCountOrderByAggregateInput
    _max?: sessionsMaxOrderByAggregateInput
    _min?: sessionsMinOrderByAggregateInput
  }

  export type sessionsScalarWhereWithAggregatesInput = {
    AND?: sessionsScalarWhereWithAggregatesInput | sessionsScalarWhereWithAggregatesInput[]
    OR?: sessionsScalarWhereWithAggregatesInput[]
    NOT?: sessionsScalarWhereWithAggregatesInput | sessionsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"sessions"> | string
    userId?: StringWithAggregatesFilter<"sessions"> | string
    token?: StringWithAggregatesFilter<"sessions"> | string
    deviceInfo?: StringNullableWithAggregatesFilter<"sessions"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"sessions"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"sessions"> | string | null
    expiresAt?: DateTimeWithAggregatesFilter<"sessions"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"sessions"> | Date | string
  }

  export type system_configWhereInput = {
    AND?: system_configWhereInput | system_configWhereInput[]
    OR?: system_configWhereInput[]
    NOT?: system_configWhereInput | system_configWhereInput[]
    id?: StringFilter<"system_config"> | string
    key?: StringFilter<"system_config"> | string
    value?: StringFilter<"system_config"> | string
    description?: StringNullableFilter<"system_config"> | string | null
    updatedAt?: DateTimeFilter<"system_config"> | Date | string
  }

  export type system_configOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    _relevance?: system_configOrderByRelevanceInput
  }

  export type system_configWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    AND?: system_configWhereInput | system_configWhereInput[]
    OR?: system_configWhereInput[]
    NOT?: system_configWhereInput | system_configWhereInput[]
    value?: StringFilter<"system_config"> | string
    description?: StringNullableFilter<"system_config"> | string | null
    updatedAt?: DateTimeFilter<"system_config"> | Date | string
  }, "id" | "key">

  export type system_configOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    _count?: system_configCountOrderByAggregateInput
    _max?: system_configMaxOrderByAggregateInput
    _min?: system_configMinOrderByAggregateInput
  }

  export type system_configScalarWhereWithAggregatesInput = {
    AND?: system_configScalarWhereWithAggregatesInput | system_configScalarWhereWithAggregatesInput[]
    OR?: system_configScalarWhereWithAggregatesInput[]
    NOT?: system_configScalarWhereWithAggregatesInput | system_configScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"system_config"> | string
    key?: StringWithAggregatesFilter<"system_config"> | string
    value?: StringWithAggregatesFilter<"system_config"> | string
    description?: StringNullableWithAggregatesFilter<"system_config"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"system_config"> | Date | string
  }

  export type documentsWhereInput = {
    AND?: documentsWhereInput | documentsWhereInput[]
    OR?: documentsWhereInput[]
    NOT?: documentsWhereInput | documentsWhereInput[]
    id?: StringFilter<"documents"> | string
    docType?: Enumdocuments_docTypeFilter<"documents"> | $Enums.documents_docType
    docNumber?: StringFilter<"documents"> | string
    docDate?: DateTimeFilter<"documents"> | Date | string
    title?: StringFilter<"documents"> | string
    price?: DecimalFilter<"documents"> | Decimal | DecimalJsLike | number | string
    cashFlowName?: StringFilter<"documents"> | string
    employeeId?: IntFilter<"documents"> | number
    username?: StringNullableFilter<"documents"> | string | null
    docFile?: StringNullableFilter<"documents"> | string | null
    docFileDate?: DateTimeNullableFilter<"documents"> | Date | string | null
    docFileTime?: StringNullableFilter<"documents"> | string | null
    docFilePrice?: DecimalNullableFilter<"documents"> | Decimal | DecimalJsLike | number | string | null
    filePath?: StringNullableFilter<"documents"> | string | null
    note?: StringNullableFilter<"documents"> | string | null
    createdAt?: DateTimeFilter<"documents"> | Date | string
    updatedAt?: DateTimeFilter<"documents"> | Date | string
    deletedAt?: DateTimeNullableFilter<"documents"> | Date | string | null
  }

  export type documentsOrderByWithRelationInput = {
    id?: SortOrder
    docType?: SortOrder
    docNumber?: SortOrder
    docDate?: SortOrder
    title?: SortOrder
    price?: SortOrder
    cashFlowName?: SortOrder
    employeeId?: SortOrder
    username?: SortOrderInput | SortOrder
    docFile?: SortOrderInput | SortOrder
    docFileDate?: SortOrderInput | SortOrder
    docFileTime?: SortOrderInput | SortOrder
    docFilePrice?: SortOrderInput | SortOrder
    filePath?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _relevance?: documentsOrderByRelevanceInput
  }

  export type documentsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: documentsWhereInput | documentsWhereInput[]
    OR?: documentsWhereInput[]
    NOT?: documentsWhereInput | documentsWhereInput[]
    docType?: Enumdocuments_docTypeFilter<"documents"> | $Enums.documents_docType
    docNumber?: StringFilter<"documents"> | string
    docDate?: DateTimeFilter<"documents"> | Date | string
    title?: StringFilter<"documents"> | string
    price?: DecimalFilter<"documents"> | Decimal | DecimalJsLike | number | string
    cashFlowName?: StringFilter<"documents"> | string
    employeeId?: IntFilter<"documents"> | number
    username?: StringNullableFilter<"documents"> | string | null
    docFile?: StringNullableFilter<"documents"> | string | null
    docFileDate?: DateTimeNullableFilter<"documents"> | Date | string | null
    docFileTime?: StringNullableFilter<"documents"> | string | null
    docFilePrice?: DecimalNullableFilter<"documents"> | Decimal | DecimalJsLike | number | string | null
    filePath?: StringNullableFilter<"documents"> | string | null
    note?: StringNullableFilter<"documents"> | string | null
    createdAt?: DateTimeFilter<"documents"> | Date | string
    updatedAt?: DateTimeFilter<"documents"> | Date | string
    deletedAt?: DateTimeNullableFilter<"documents"> | Date | string | null
  }, "id">

  export type documentsOrderByWithAggregationInput = {
    id?: SortOrder
    docType?: SortOrder
    docNumber?: SortOrder
    docDate?: SortOrder
    title?: SortOrder
    price?: SortOrder
    cashFlowName?: SortOrder
    employeeId?: SortOrder
    username?: SortOrderInput | SortOrder
    docFile?: SortOrderInput | SortOrder
    docFileDate?: SortOrderInput | SortOrder
    docFileTime?: SortOrderInput | SortOrder
    docFilePrice?: SortOrderInput | SortOrder
    filePath?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: documentsCountOrderByAggregateInput
    _avg?: documentsAvgOrderByAggregateInput
    _max?: documentsMaxOrderByAggregateInput
    _min?: documentsMinOrderByAggregateInput
    _sum?: documentsSumOrderByAggregateInput
  }

  export type documentsScalarWhereWithAggregatesInput = {
    AND?: documentsScalarWhereWithAggregatesInput | documentsScalarWhereWithAggregatesInput[]
    OR?: documentsScalarWhereWithAggregatesInput[]
    NOT?: documentsScalarWhereWithAggregatesInput | documentsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"documents"> | string
    docType?: Enumdocuments_docTypeWithAggregatesFilter<"documents"> | $Enums.documents_docType
    docNumber?: StringWithAggregatesFilter<"documents"> | string
    docDate?: DateTimeWithAggregatesFilter<"documents"> | Date | string
    title?: StringWithAggregatesFilter<"documents"> | string
    price?: DecimalWithAggregatesFilter<"documents"> | Decimal | DecimalJsLike | number | string
    cashFlowName?: StringWithAggregatesFilter<"documents"> | string
    employeeId?: IntWithAggregatesFilter<"documents"> | number
    username?: StringNullableWithAggregatesFilter<"documents"> | string | null
    docFile?: StringNullableWithAggregatesFilter<"documents"> | string | null
    docFileDate?: DateTimeNullableWithAggregatesFilter<"documents"> | Date | string | null
    docFileTime?: StringNullableWithAggregatesFilter<"documents"> | string | null
    docFilePrice?: DecimalNullableWithAggregatesFilter<"documents"> | Decimal | DecimalJsLike | number | string | null
    filePath?: StringNullableWithAggregatesFilter<"documents"> | string | null
    note?: StringNullableWithAggregatesFilter<"documents"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"documents"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"documents"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"documents"> | Date | string | null
  }

  export type document_title_listsWhereInput = {
    AND?: document_title_listsWhereInput | document_title_listsWhereInput[]
    OR?: document_title_listsWhereInput[]
    NOT?: document_title_listsWhereInput | document_title_listsWhereInput[]
    id?: StringFilter<"document_title_lists"> | string
    docType?: Enumdocument_title_lists_docTypeFilter<"document_title_lists"> | $Enums.document_title_lists_docType
    title?: StringFilter<"document_title_lists"> | string
    note?: StringNullableFilter<"document_title_lists"> | string | null
    createdAt?: DateTimeFilter<"document_title_lists"> | Date | string
    updatedAt?: DateTimeFilter<"document_title_lists"> | Date | string
    deletedAt?: DateTimeNullableFilter<"document_title_lists"> | Date | string | null
  }

  export type document_title_listsOrderByWithRelationInput = {
    id?: SortOrder
    docType?: SortOrder
    title?: SortOrder
    note?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _relevance?: document_title_listsOrderByRelevanceInput
  }

  export type document_title_listsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: document_title_listsWhereInput | document_title_listsWhereInput[]
    OR?: document_title_listsWhereInput[]
    NOT?: document_title_listsWhereInput | document_title_listsWhereInput[]
    docType?: Enumdocument_title_lists_docTypeFilter<"document_title_lists"> | $Enums.document_title_lists_docType
    title?: StringFilter<"document_title_lists"> | string
    note?: StringNullableFilter<"document_title_lists"> | string | null
    createdAt?: DateTimeFilter<"document_title_lists"> | Date | string
    updatedAt?: DateTimeFilter<"document_title_lists"> | Date | string
    deletedAt?: DateTimeNullableFilter<"document_title_lists"> | Date | string | null
  }, "id">

  export type document_title_listsOrderByWithAggregationInput = {
    id?: SortOrder
    docType?: SortOrder
    title?: SortOrder
    note?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: document_title_listsCountOrderByAggregateInput
    _max?: document_title_listsMaxOrderByAggregateInput
    _min?: document_title_listsMinOrderByAggregateInput
  }

  export type document_title_listsScalarWhereWithAggregatesInput = {
    AND?: document_title_listsScalarWhereWithAggregatesInput | document_title_listsScalarWhereWithAggregatesInput[]
    OR?: document_title_listsScalarWhereWithAggregatesInput[]
    NOT?: document_title_listsScalarWhereWithAggregatesInput | document_title_listsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"document_title_lists"> | string
    docType?: Enumdocument_title_lists_docTypeWithAggregatesFilter<"document_title_lists"> | $Enums.document_title_lists_docType
    title?: StringWithAggregatesFilter<"document_title_lists"> | string
    note?: StringNullableWithAggregatesFilter<"document_title_lists"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"document_title_lists"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"document_title_lists"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"document_title_lists"> | Date | string | null
  }

  export type land_accountsWhereInput = {
    AND?: land_accountsWhereInput | land_accountsWhereInput[]
    OR?: land_accountsWhereInput[]
    NOT?: land_accountsWhereInput | land_accountsWhereInput[]
    id?: StringFilter<"land_accounts"> | string
    accountName?: StringFilter<"land_accounts"> | string
    accountBalance?: DecimalFilter<"land_accounts"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"land_accounts"> | Date | string
    updatedAt?: DateTimeFilter<"land_accounts"> | Date | string
    deletedAt?: DateTimeNullableFilter<"land_accounts"> | Date | string | null
    logs?: Land_account_logsListRelationFilter
    reports?: Land_account_reportsListRelationFilter
  }

  export type land_accountsOrderByWithRelationInput = {
    id?: SortOrder
    accountName?: SortOrder
    accountBalance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    logs?: land_account_logsOrderByRelationAggregateInput
    reports?: land_account_reportsOrderByRelationAggregateInput
    _relevance?: land_accountsOrderByRelevanceInput
  }

  export type land_accountsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: land_accountsWhereInput | land_accountsWhereInput[]
    OR?: land_accountsWhereInput[]
    NOT?: land_accountsWhereInput | land_accountsWhereInput[]
    accountName?: StringFilter<"land_accounts"> | string
    accountBalance?: DecimalFilter<"land_accounts"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"land_accounts"> | Date | string
    updatedAt?: DateTimeFilter<"land_accounts"> | Date | string
    deletedAt?: DateTimeNullableFilter<"land_accounts"> | Date | string | null
    logs?: Land_account_logsListRelationFilter
    reports?: Land_account_reportsListRelationFilter
  }, "id">

  export type land_accountsOrderByWithAggregationInput = {
    id?: SortOrder
    accountName?: SortOrder
    accountBalance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: land_accountsCountOrderByAggregateInput
    _avg?: land_accountsAvgOrderByAggregateInput
    _max?: land_accountsMaxOrderByAggregateInput
    _min?: land_accountsMinOrderByAggregateInput
    _sum?: land_accountsSumOrderByAggregateInput
  }

  export type land_accountsScalarWhereWithAggregatesInput = {
    AND?: land_accountsScalarWhereWithAggregatesInput | land_accountsScalarWhereWithAggregatesInput[]
    OR?: land_accountsScalarWhereWithAggregatesInput[]
    NOT?: land_accountsScalarWhereWithAggregatesInput | land_accountsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"land_accounts"> | string
    accountName?: StringWithAggregatesFilter<"land_accounts"> | string
    accountBalance?: DecimalWithAggregatesFilter<"land_accounts"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"land_accounts"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"land_accounts"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"land_accounts"> | Date | string | null
  }

  export type land_account_logsWhereInput = {
    AND?: land_account_logsWhereInput | land_account_logsWhereInput[]
    OR?: land_account_logsWhereInput[]
    NOT?: land_account_logsWhereInput | land_account_logsWhereInput[]
    id?: StringFilter<"land_account_logs"> | string
    landAccountId?: StringFilter<"land_account_logs"> | string
    detail?: StringFilter<"land_account_logs"> | string
    amount?: DecimalFilter<"land_account_logs"> | Decimal | DecimalJsLike | number | string
    note?: StringNullableFilter<"land_account_logs"> | string | null
    employeeId?: IntFilter<"land_account_logs"> | number
    employeeName?: StringNullableFilter<"land_account_logs"> | string | null
    createdAt?: DateTimeFilter<"land_account_logs"> | Date | string
    updatedAt?: DateTimeFilter<"land_account_logs"> | Date | string
    deletedAt?: DateTimeNullableFilter<"land_account_logs"> | Date | string | null
    landAccount?: XOR<Land_accountsScalarRelationFilter, land_accountsWhereInput>
  }

  export type land_account_logsOrderByWithRelationInput = {
    id?: SortOrder
    landAccountId?: SortOrder
    detail?: SortOrder
    amount?: SortOrder
    note?: SortOrderInput | SortOrder
    employeeId?: SortOrder
    employeeName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    landAccount?: land_accountsOrderByWithRelationInput
    _relevance?: land_account_logsOrderByRelevanceInput
  }

  export type land_account_logsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: land_account_logsWhereInput | land_account_logsWhereInput[]
    OR?: land_account_logsWhereInput[]
    NOT?: land_account_logsWhereInput | land_account_logsWhereInput[]
    landAccountId?: StringFilter<"land_account_logs"> | string
    detail?: StringFilter<"land_account_logs"> | string
    amount?: DecimalFilter<"land_account_logs"> | Decimal | DecimalJsLike | number | string
    note?: StringNullableFilter<"land_account_logs"> | string | null
    employeeId?: IntFilter<"land_account_logs"> | number
    employeeName?: StringNullableFilter<"land_account_logs"> | string | null
    createdAt?: DateTimeFilter<"land_account_logs"> | Date | string
    updatedAt?: DateTimeFilter<"land_account_logs"> | Date | string
    deletedAt?: DateTimeNullableFilter<"land_account_logs"> | Date | string | null
    landAccount?: XOR<Land_accountsScalarRelationFilter, land_accountsWhereInput>
  }, "id">

  export type land_account_logsOrderByWithAggregationInput = {
    id?: SortOrder
    landAccountId?: SortOrder
    detail?: SortOrder
    amount?: SortOrder
    note?: SortOrderInput | SortOrder
    employeeId?: SortOrder
    employeeName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: land_account_logsCountOrderByAggregateInput
    _avg?: land_account_logsAvgOrderByAggregateInput
    _max?: land_account_logsMaxOrderByAggregateInput
    _min?: land_account_logsMinOrderByAggregateInput
    _sum?: land_account_logsSumOrderByAggregateInput
  }

  export type land_account_logsScalarWhereWithAggregatesInput = {
    AND?: land_account_logsScalarWhereWithAggregatesInput | land_account_logsScalarWhereWithAggregatesInput[]
    OR?: land_account_logsScalarWhereWithAggregatesInput[]
    NOT?: land_account_logsScalarWhereWithAggregatesInput | land_account_logsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"land_account_logs"> | string
    landAccountId?: StringWithAggregatesFilter<"land_account_logs"> | string
    detail?: StringWithAggregatesFilter<"land_account_logs"> | string
    amount?: DecimalWithAggregatesFilter<"land_account_logs"> | Decimal | DecimalJsLike | number | string
    note?: StringNullableWithAggregatesFilter<"land_account_logs"> | string | null
    employeeId?: IntWithAggregatesFilter<"land_account_logs"> | number
    employeeName?: StringNullableWithAggregatesFilter<"land_account_logs"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"land_account_logs"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"land_account_logs"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"land_account_logs"> | Date | string | null
  }

  export type land_account_reportsWhereInput = {
    AND?: land_account_reportsWhereInput | land_account_reportsWhereInput[]
    OR?: land_account_reportsWhereInput[]
    NOT?: land_account_reportsWhereInput | land_account_reportsWhereInput[]
    id?: StringFilter<"land_account_reports"> | string
    landAccountId?: StringFilter<"land_account_reports"> | string
    detail?: StringFilter<"land_account_reports"> | string
    amount?: DecimalFilter<"land_account_reports"> | Decimal | DecimalJsLike | number | string
    note?: StringNullableFilter<"land_account_reports"> | string | null
    accountBalance?: DecimalNullableFilter<"land_account_reports"> | Decimal | DecimalJsLike | number | string | null
    employeeId?: IntFilter<"land_account_reports"> | number
    employeeName?: StringNullableFilter<"land_account_reports"> | string | null
    createdAt?: DateTimeFilter<"land_account_reports"> | Date | string
    updatedAt?: DateTimeFilter<"land_account_reports"> | Date | string
    deletedAt?: DateTimeNullableFilter<"land_account_reports"> | Date | string | null
    landAccount?: XOR<Land_accountsScalarRelationFilter, land_accountsWhereInput>
  }

  export type land_account_reportsOrderByWithRelationInput = {
    id?: SortOrder
    landAccountId?: SortOrder
    detail?: SortOrder
    amount?: SortOrder
    note?: SortOrderInput | SortOrder
    accountBalance?: SortOrderInput | SortOrder
    employeeId?: SortOrder
    employeeName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    landAccount?: land_accountsOrderByWithRelationInput
    _relevance?: land_account_reportsOrderByRelevanceInput
  }

  export type land_account_reportsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: land_account_reportsWhereInput | land_account_reportsWhereInput[]
    OR?: land_account_reportsWhereInput[]
    NOT?: land_account_reportsWhereInput | land_account_reportsWhereInput[]
    landAccountId?: StringFilter<"land_account_reports"> | string
    detail?: StringFilter<"land_account_reports"> | string
    amount?: DecimalFilter<"land_account_reports"> | Decimal | DecimalJsLike | number | string
    note?: StringNullableFilter<"land_account_reports"> | string | null
    accountBalance?: DecimalNullableFilter<"land_account_reports"> | Decimal | DecimalJsLike | number | string | null
    employeeId?: IntFilter<"land_account_reports"> | number
    employeeName?: StringNullableFilter<"land_account_reports"> | string | null
    createdAt?: DateTimeFilter<"land_account_reports"> | Date | string
    updatedAt?: DateTimeFilter<"land_account_reports"> | Date | string
    deletedAt?: DateTimeNullableFilter<"land_account_reports"> | Date | string | null
    landAccount?: XOR<Land_accountsScalarRelationFilter, land_accountsWhereInput>
  }, "id">

  export type land_account_reportsOrderByWithAggregationInput = {
    id?: SortOrder
    landAccountId?: SortOrder
    detail?: SortOrder
    amount?: SortOrder
    note?: SortOrderInput | SortOrder
    accountBalance?: SortOrderInput | SortOrder
    employeeId?: SortOrder
    employeeName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: land_account_reportsCountOrderByAggregateInput
    _avg?: land_account_reportsAvgOrderByAggregateInput
    _max?: land_account_reportsMaxOrderByAggregateInput
    _min?: land_account_reportsMinOrderByAggregateInput
    _sum?: land_account_reportsSumOrderByAggregateInput
  }

  export type land_account_reportsScalarWhereWithAggregatesInput = {
    AND?: land_account_reportsScalarWhereWithAggregatesInput | land_account_reportsScalarWhereWithAggregatesInput[]
    OR?: land_account_reportsScalarWhereWithAggregatesInput[]
    NOT?: land_account_reportsScalarWhereWithAggregatesInput | land_account_reportsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"land_account_reports"> | string
    landAccountId?: StringWithAggregatesFilter<"land_account_reports"> | string
    detail?: StringWithAggregatesFilter<"land_account_reports"> | string
    amount?: DecimalWithAggregatesFilter<"land_account_reports"> | Decimal | DecimalJsLike | number | string
    note?: StringNullableWithAggregatesFilter<"land_account_reports"> | string | null
    accountBalance?: DecimalNullableWithAggregatesFilter<"land_account_reports"> | Decimal | DecimalJsLike | number | string | null
    employeeId?: IntWithAggregatesFilter<"land_account_reports"> | number
    employeeName?: StringNullableWithAggregatesFilter<"land_account_reports"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"land_account_reports"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"land_account_reports"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"land_account_reports"> | Date | string | null
  }

  export type user_profilesWhereInput = {
    AND?: user_profilesWhereInput | user_profilesWhereInput[]
    OR?: user_profilesWhereInput[]
    NOT?: user_profilesWhereInput | user_profilesWhereInput[]
    id?: StringFilter<"user_profiles"> | string
    userId?: StringFilter<"user_profiles"> | string
    firstName?: StringNullableFilter<"user_profiles"> | string | null
    lastName?: StringNullableFilter<"user_profiles"> | string | null
    idCardNumber?: StringNullableFilter<"user_profiles"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"user_profiles"> | Date | string | null
    address?: StringNullableFilter<"user_profiles"> | string | null
    email?: StringNullableFilter<"user_profiles"> | string | null
    lineId?: StringNullableFilter<"user_profiles"> | string | null
    idCardFrontImage?: StringNullableFilter<"user_profiles"> | string | null
    idCardBackImage?: StringNullableFilter<"user_profiles"> | string | null
    preferredLanguage?: StringFilter<"user_profiles"> | string
    notificationEnabled?: BoolFilter<"user_profiles"> | boolean
    coinBalance?: IntFilter<"user_profiles"> | number
    createdAt?: DateTimeFilter<"user_profiles"> | Date | string
    updatedAt?: DateTimeFilter<"user_profiles"> | Date | string
  }

  export type user_profilesOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    idCardNumber?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    lineId?: SortOrderInput | SortOrder
    idCardFrontImage?: SortOrderInput | SortOrder
    idCardBackImage?: SortOrderInput | SortOrder
    preferredLanguage?: SortOrder
    notificationEnabled?: SortOrder
    coinBalance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: user_profilesOrderByRelevanceInput
  }

  export type user_profilesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    idCardNumber?: string
    AND?: user_profilesWhereInput | user_profilesWhereInput[]
    OR?: user_profilesWhereInput[]
    NOT?: user_profilesWhereInput | user_profilesWhereInput[]
    firstName?: StringNullableFilter<"user_profiles"> | string | null
    lastName?: StringNullableFilter<"user_profiles"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"user_profiles"> | Date | string | null
    address?: StringNullableFilter<"user_profiles"> | string | null
    email?: StringNullableFilter<"user_profiles"> | string | null
    lineId?: StringNullableFilter<"user_profiles"> | string | null
    idCardFrontImage?: StringNullableFilter<"user_profiles"> | string | null
    idCardBackImage?: StringNullableFilter<"user_profiles"> | string | null
    preferredLanguage?: StringFilter<"user_profiles"> | string
    notificationEnabled?: BoolFilter<"user_profiles"> | boolean
    coinBalance?: IntFilter<"user_profiles"> | number
    createdAt?: DateTimeFilter<"user_profiles"> | Date | string
    updatedAt?: DateTimeFilter<"user_profiles"> | Date | string
  }, "id" | "userId" | "idCardNumber">

  export type user_profilesOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    idCardNumber?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    lineId?: SortOrderInput | SortOrder
    idCardFrontImage?: SortOrderInput | SortOrder
    idCardBackImage?: SortOrderInput | SortOrder
    preferredLanguage?: SortOrder
    notificationEnabled?: SortOrder
    coinBalance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: user_profilesCountOrderByAggregateInput
    _avg?: user_profilesAvgOrderByAggregateInput
    _max?: user_profilesMaxOrderByAggregateInput
    _min?: user_profilesMinOrderByAggregateInput
    _sum?: user_profilesSumOrderByAggregateInput
  }

  export type user_profilesScalarWhereWithAggregatesInput = {
    AND?: user_profilesScalarWhereWithAggregatesInput | user_profilesScalarWhereWithAggregatesInput[]
    OR?: user_profilesScalarWhereWithAggregatesInput[]
    NOT?: user_profilesScalarWhereWithAggregatesInput | user_profilesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"user_profiles"> | string
    userId?: StringWithAggregatesFilter<"user_profiles"> | string
    firstName?: StringNullableWithAggregatesFilter<"user_profiles"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"user_profiles"> | string | null
    idCardNumber?: StringNullableWithAggregatesFilter<"user_profiles"> | string | null
    dateOfBirth?: DateTimeNullableWithAggregatesFilter<"user_profiles"> | Date | string | null
    address?: StringNullableWithAggregatesFilter<"user_profiles"> | string | null
    email?: StringNullableWithAggregatesFilter<"user_profiles"> | string | null
    lineId?: StringNullableWithAggregatesFilter<"user_profiles"> | string | null
    idCardFrontImage?: StringNullableWithAggregatesFilter<"user_profiles"> | string | null
    idCardBackImage?: StringNullableWithAggregatesFilter<"user_profiles"> | string | null
    preferredLanguage?: StringWithAggregatesFilter<"user_profiles"> | string
    notificationEnabled?: BoolWithAggregatesFilter<"user_profiles"> | boolean
    coinBalance?: IntWithAggregatesFilter<"user_profiles"> | number
    createdAt?: DateTimeWithAggregatesFilter<"user_profiles"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"user_profiles"> | Date | string
  }

  export type usersWhereInput = {
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    id?: StringFilter<"users"> | string
    phoneNumber?: StringFilter<"users"> | string
    pin?: StringNullableFilter<"users"> | string | null
    otpSecret?: StringNullableFilter<"users"> | string | null
    otpEnabled?: BoolFilter<"users"> | boolean
    lastOtpSentAt?: DateTimeNullableFilter<"users"> | Date | string | null
    userType?: Enumusers_userTypeFilter<"users"> | $Enums.users_userType
    isActive?: BoolFilter<"users"> | boolean
    lastLoginAt?: DateTimeNullableFilter<"users"> | Date | string | null
    createdAt?: DateTimeFilter<"users"> | Date | string
    updatedAt?: DateTimeFilter<"users"> | Date | string
  }

  export type usersOrderByWithRelationInput = {
    id?: SortOrder
    phoneNumber?: SortOrder
    pin?: SortOrderInput | SortOrder
    otpSecret?: SortOrderInput | SortOrder
    otpEnabled?: SortOrder
    lastOtpSentAt?: SortOrderInput | SortOrder
    userType?: SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: usersOrderByRelevanceInput
  }

  export type usersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    phoneNumber?: string
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    pin?: StringNullableFilter<"users"> | string | null
    otpSecret?: StringNullableFilter<"users"> | string | null
    otpEnabled?: BoolFilter<"users"> | boolean
    lastOtpSentAt?: DateTimeNullableFilter<"users"> | Date | string | null
    userType?: Enumusers_userTypeFilter<"users"> | $Enums.users_userType
    isActive?: BoolFilter<"users"> | boolean
    lastLoginAt?: DateTimeNullableFilter<"users"> | Date | string | null
    createdAt?: DateTimeFilter<"users"> | Date | string
    updatedAt?: DateTimeFilter<"users"> | Date | string
  }, "id" | "phoneNumber">

  export type usersOrderByWithAggregationInput = {
    id?: SortOrder
    phoneNumber?: SortOrder
    pin?: SortOrderInput | SortOrder
    otpSecret?: SortOrderInput | SortOrder
    otpEnabled?: SortOrder
    lastOtpSentAt?: SortOrderInput | SortOrder
    userType?: SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: usersCountOrderByAggregateInput
    _max?: usersMaxOrderByAggregateInput
    _min?: usersMinOrderByAggregateInput
  }

  export type usersScalarWhereWithAggregatesInput = {
    AND?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    OR?: usersScalarWhereWithAggregatesInput[]
    NOT?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"users"> | string
    phoneNumber?: StringWithAggregatesFilter<"users"> | string
    pin?: StringNullableWithAggregatesFilter<"users"> | string | null
    otpSecret?: StringNullableWithAggregatesFilter<"users"> | string | null
    otpEnabled?: BoolWithAggregatesFilter<"users"> | boolean
    lastOtpSentAt?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
    userType?: Enumusers_userTypeWithAggregatesFilter<"users"> | $Enums.users_userType
    isActive?: BoolWithAggregatesFilter<"users"> | boolean
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"users"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"users"> | Date | string
  }

  export type admin_permissionsCreateInput = {
    id: string
    adminId: string
    permission: $Enums.admin_permissions_permission
    grantedAt?: Date | string
    grantedBy?: string | null
  }

  export type admin_permissionsUncheckedCreateInput = {
    id: string
    adminId: string
    permission: $Enums.admin_permissions_permission
    grantedAt?: Date | string
    grantedBy?: string | null
  }

  export type admin_permissionsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    permission?: Enumadmin_permissions_permissionFieldUpdateOperationsInput | $Enums.admin_permissions_permission
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grantedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type admin_permissionsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    permission?: Enumadmin_permissions_permissionFieldUpdateOperationsInput | $Enums.admin_permissions_permission
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grantedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type admin_permissionsCreateManyInput = {
    id: string
    adminId: string
    permission: $Enums.admin_permissions_permission
    grantedAt?: Date | string
    grantedBy?: string | null
  }

  export type admin_permissionsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    permission?: Enumadmin_permissions_permissionFieldUpdateOperationsInput | $Enums.admin_permissions_permission
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grantedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type admin_permissionsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    permission?: Enumadmin_permissions_permissionFieldUpdateOperationsInput | $Enums.admin_permissions_permission
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grantedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type admin_sessionsCreateInput = {
    id: string
    adminId: string
    token: string
    deviceInfo?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type admin_sessionsUncheckedCreateInput = {
    id: string
    adminId: string
    token: string
    deviceInfo?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type admin_sessionsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type admin_sessionsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type admin_sessionsCreateManyInput = {
    id: string
    adminId: string
    token: string
    deviceInfo?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type admin_sessionsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type admin_sessionsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type adminsCreateInput = {
    id: string
    email: string
    password: string
    firstName: string
    lastName: string
    role?: $Enums.admins_role
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type adminsUncheckedCreateInput = {
    id: string
    email: string
    password: string
    firstName: string
    lastName: string
    role?: $Enums.admins_role
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type adminsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: Enumadmins_roleFieldUpdateOperationsInput | $Enums.admins_role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type adminsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: Enumadmins_roleFieldUpdateOperationsInput | $Enums.admins_role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type adminsCreateManyInput = {
    id: string
    email: string
    password: string
    firstName: string
    lastName: string
    role?: $Enums.admins_role
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type adminsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: Enumadmins_roleFieldUpdateOperationsInput | $Enums.admins_role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type adminsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: Enumadmins_roleFieldUpdateOperationsInput | $Enums.admins_role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type agent_customersCreateInput = {
    id: string
    agentId: string
    customerId: string
    assignedAt?: Date | string
    isActive?: boolean
  }

  export type agent_customersUncheckedCreateInput = {
    id: string
    agentId: string
    customerId: string
    assignedAt?: Date | string
    isActive?: boolean
  }

  export type agent_customersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type agent_customersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type agent_customersCreateManyInput = {
    id: string
    agentId: string
    customerId: string
    assignedAt?: Date | string
    isActive?: boolean
  }

  export type agent_customersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type agent_customersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type audit_logsCreateInput = {
    id: string
    action: string
    entity: string
    entityId: string
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    adminId?: string | null
  }

  export type audit_logsUncheckedCreateInput = {
    id: string
    action: string
    entity: string
    entityId: string
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    adminId?: string | null
  }

  export type audit_logsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type audit_logsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type audit_logsCreateManyInput = {
    id: string
    action: string
    entity: string
    entityId: string
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    adminId?: string | null
  }

  export type audit_logsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type audit_logsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type bannersCreateInput = {
    id: string
    title: string
    description?: string | null
    imageUrl: string
    actionUrl?: string | null
    isActive?: boolean
    sortOrder?: number
    targetUserTypes: JsonNullValueInput | InputJsonValue
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type bannersUncheckedCreateInput = {
    id: string
    title: string
    description?: string | null
    imageUrl: string
    actionUrl?: string | null
    isActive?: boolean
    sortOrder?: number
    targetUserTypes: JsonNullValueInput | InputJsonValue
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type bannersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: StringFieldUpdateOperationsInput | string
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    targetUserTypes?: JsonNullValueInput | InputJsonValue
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type bannersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: StringFieldUpdateOperationsInput | string
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    targetUserTypes?: JsonNullValueInput | InputJsonValue
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type bannersCreateManyInput = {
    id: string
    title: string
    description?: string | null
    imageUrl: string
    actionUrl?: string | null
    isActive?: boolean
    sortOrder?: number
    targetUserTypes: JsonNullValueInput | InputJsonValue
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type bannersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: StringFieldUpdateOperationsInput | string
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    targetUserTypes?: JsonNullValueInput | InputJsonValue
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type bannersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: StringFieldUpdateOperationsInput | string
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    targetUserTypes?: JsonNullValueInput | InputJsonValue
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type coin_transactionsCreateInput = {
    id: string
    userId: string
    type: $Enums.coin_transactions_type
    amount: number
    description: string
    loanId?: string | null
    rewardId?: string | null
    createdAt?: Date | string
  }

  export type coin_transactionsUncheckedCreateInput = {
    id: string
    userId: string
    type: $Enums.coin_transactions_type
    amount: number
    description: string
    loanId?: string | null
    rewardId?: string | null
    createdAt?: Date | string
  }

  export type coin_transactionsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: Enumcoin_transactions_typeFieldUpdateOperationsInput | $Enums.coin_transactions_type
    amount?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    loanId?: NullableStringFieldUpdateOperationsInput | string | null
    rewardId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type coin_transactionsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: Enumcoin_transactions_typeFieldUpdateOperationsInput | $Enums.coin_transactions_type
    amount?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    loanId?: NullableStringFieldUpdateOperationsInput | string | null
    rewardId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type coin_transactionsCreateManyInput = {
    id: string
    userId: string
    type: $Enums.coin_transactions_type
    amount: number
    description: string
    loanId?: string | null
    rewardId?: string | null
    createdAt?: Date | string
  }

  export type coin_transactionsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: Enumcoin_transactions_typeFieldUpdateOperationsInput | $Enums.coin_transactions_type
    amount?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    loanId?: NullableStringFieldUpdateOperationsInput | string | null
    rewardId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type coin_transactionsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: Enumcoin_transactions_typeFieldUpdateOperationsInput | $Enums.coin_transactions_type
    amount?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    loanId?: NullableStringFieldUpdateOperationsInput | string | null
    rewardId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type loan_applicationsCreateInput = {
    id: string
    customerId: string
    agentId?: string | null
    loanType?: $Enums.loan_applications_loanType
    status?: $Enums.loan_applications_status
    currentStep?: number
    completedSteps: JsonNullValueInput | InputJsonValue
    isNewUser?: boolean
    submittedByAgent?: boolean
    titleDeedImage?: string | null
    titleDeedData?: NullableJsonNullValueInput | InputJsonValue
    supportingImages: JsonNullValueInput | InputJsonValue
    idCardFrontImage?: string | null
    idCardBackImage?: string | null
    requestedAmount?: Decimal | DecimalJsLike | number | string
    approvedAmount?: Decimal | DecimalJsLike | number | string | null
    maxApprovedAmount?: Decimal | DecimalJsLike | number | string | null
    propertyType?: string | null
    propertyValue?: Decimal | DecimalJsLike | number | string | null
    propertyArea?: string | null
    propertyLocation?: string | null
    landNumber?: string | null
    ownerName?: string | null
    submittedAt?: Date | string | null
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    reviewNotes?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type loan_applicationsUncheckedCreateInput = {
    id: string
    customerId: string
    agentId?: string | null
    loanType?: $Enums.loan_applications_loanType
    status?: $Enums.loan_applications_status
    currentStep?: number
    completedSteps: JsonNullValueInput | InputJsonValue
    isNewUser?: boolean
    submittedByAgent?: boolean
    titleDeedImage?: string | null
    titleDeedData?: NullableJsonNullValueInput | InputJsonValue
    supportingImages: JsonNullValueInput | InputJsonValue
    idCardFrontImage?: string | null
    idCardBackImage?: string | null
    requestedAmount?: Decimal | DecimalJsLike | number | string
    approvedAmount?: Decimal | DecimalJsLike | number | string | null
    maxApprovedAmount?: Decimal | DecimalJsLike | number | string | null
    propertyType?: string | null
    propertyValue?: Decimal | DecimalJsLike | number | string | null
    propertyArea?: string | null
    propertyLocation?: string | null
    landNumber?: string | null
    ownerName?: string | null
    submittedAt?: Date | string | null
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    reviewNotes?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type loan_applicationsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    loanType?: Enumloan_applications_loanTypeFieldUpdateOperationsInput | $Enums.loan_applications_loanType
    status?: Enumloan_applications_statusFieldUpdateOperationsInput | $Enums.loan_applications_status
    currentStep?: IntFieldUpdateOperationsInput | number
    completedSteps?: JsonNullValueInput | InputJsonValue
    isNewUser?: BoolFieldUpdateOperationsInput | boolean
    submittedByAgent?: BoolFieldUpdateOperationsInput | boolean
    titleDeedImage?: NullableStringFieldUpdateOperationsInput | string | null
    titleDeedData?: NullableJsonNullValueInput | InputJsonValue
    supportingImages?: JsonNullValueInput | InputJsonValue
    idCardFrontImage?: NullableStringFieldUpdateOperationsInput | string | null
    idCardBackImage?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    approvedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxApprovedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    propertyType?: NullableStringFieldUpdateOperationsInput | string | null
    propertyValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    propertyArea?: NullableStringFieldUpdateOperationsInput | string | null
    propertyLocation?: NullableStringFieldUpdateOperationsInput | string | null
    landNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ownerName?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type loan_applicationsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    loanType?: Enumloan_applications_loanTypeFieldUpdateOperationsInput | $Enums.loan_applications_loanType
    status?: Enumloan_applications_statusFieldUpdateOperationsInput | $Enums.loan_applications_status
    currentStep?: IntFieldUpdateOperationsInput | number
    completedSteps?: JsonNullValueInput | InputJsonValue
    isNewUser?: BoolFieldUpdateOperationsInput | boolean
    submittedByAgent?: BoolFieldUpdateOperationsInput | boolean
    titleDeedImage?: NullableStringFieldUpdateOperationsInput | string | null
    titleDeedData?: NullableJsonNullValueInput | InputJsonValue
    supportingImages?: JsonNullValueInput | InputJsonValue
    idCardFrontImage?: NullableStringFieldUpdateOperationsInput | string | null
    idCardBackImage?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    approvedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxApprovedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    propertyType?: NullableStringFieldUpdateOperationsInput | string | null
    propertyValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    propertyArea?: NullableStringFieldUpdateOperationsInput | string | null
    propertyLocation?: NullableStringFieldUpdateOperationsInput | string | null
    landNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ownerName?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type loan_applicationsCreateManyInput = {
    id: string
    customerId: string
    agentId?: string | null
    loanType?: $Enums.loan_applications_loanType
    status?: $Enums.loan_applications_status
    currentStep?: number
    completedSteps: JsonNullValueInput | InputJsonValue
    isNewUser?: boolean
    submittedByAgent?: boolean
    titleDeedImage?: string | null
    titleDeedData?: NullableJsonNullValueInput | InputJsonValue
    supportingImages: JsonNullValueInput | InputJsonValue
    idCardFrontImage?: string | null
    idCardBackImage?: string | null
    requestedAmount?: Decimal | DecimalJsLike | number | string
    approvedAmount?: Decimal | DecimalJsLike | number | string | null
    maxApprovedAmount?: Decimal | DecimalJsLike | number | string | null
    propertyType?: string | null
    propertyValue?: Decimal | DecimalJsLike | number | string | null
    propertyArea?: string | null
    propertyLocation?: string | null
    landNumber?: string | null
    ownerName?: string | null
    submittedAt?: Date | string | null
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    reviewNotes?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type loan_applicationsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    loanType?: Enumloan_applications_loanTypeFieldUpdateOperationsInput | $Enums.loan_applications_loanType
    status?: Enumloan_applications_statusFieldUpdateOperationsInput | $Enums.loan_applications_status
    currentStep?: IntFieldUpdateOperationsInput | number
    completedSteps?: JsonNullValueInput | InputJsonValue
    isNewUser?: BoolFieldUpdateOperationsInput | boolean
    submittedByAgent?: BoolFieldUpdateOperationsInput | boolean
    titleDeedImage?: NullableStringFieldUpdateOperationsInput | string | null
    titleDeedData?: NullableJsonNullValueInput | InputJsonValue
    supportingImages?: JsonNullValueInput | InputJsonValue
    idCardFrontImage?: NullableStringFieldUpdateOperationsInput | string | null
    idCardBackImage?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    approvedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxApprovedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    propertyType?: NullableStringFieldUpdateOperationsInput | string | null
    propertyValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    propertyArea?: NullableStringFieldUpdateOperationsInput | string | null
    propertyLocation?: NullableStringFieldUpdateOperationsInput | string | null
    landNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ownerName?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type loan_applicationsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    loanType?: Enumloan_applications_loanTypeFieldUpdateOperationsInput | $Enums.loan_applications_loanType
    status?: Enumloan_applications_statusFieldUpdateOperationsInput | $Enums.loan_applications_status
    currentStep?: IntFieldUpdateOperationsInput | number
    completedSteps?: JsonNullValueInput | InputJsonValue
    isNewUser?: BoolFieldUpdateOperationsInput | boolean
    submittedByAgent?: BoolFieldUpdateOperationsInput | boolean
    titleDeedImage?: NullableStringFieldUpdateOperationsInput | string | null
    titleDeedData?: NullableJsonNullValueInput | InputJsonValue
    supportingImages?: JsonNullValueInput | InputJsonValue
    idCardFrontImage?: NullableStringFieldUpdateOperationsInput | string | null
    idCardBackImage?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    approvedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxApprovedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    propertyType?: NullableStringFieldUpdateOperationsInput | string | null
    propertyValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    propertyArea?: NullableStringFieldUpdateOperationsInput | string | null
    propertyLocation?: NullableStringFieldUpdateOperationsInput | string | null
    landNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ownerName?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type loan_installmentsCreateInput = {
    id: string
    loanId: string
    installmentNumber: number
    dueDate: Date | string
    principalAmount: Decimal | DecimalJsLike | number | string
    interestAmount: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    isPaid?: boolean
    paidDate?: Date | string | null
    paidAmount?: Decimal | DecimalJsLike | number | string | null
    isLate?: boolean
    lateDays?: number | null
    lateFee?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type loan_installmentsUncheckedCreateInput = {
    id: string
    loanId: string
    installmentNumber: number
    dueDate: Date | string
    principalAmount: Decimal | DecimalJsLike | number | string
    interestAmount: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    isPaid?: boolean
    paidDate?: Date | string | null
    paidAmount?: Decimal | DecimalJsLike | number | string | null
    isLate?: boolean
    lateDays?: number | null
    lateFee?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type loan_installmentsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    loanId?: StringFieldUpdateOperationsInput | string
    installmentNumber?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    principalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    interestAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isLate?: BoolFieldUpdateOperationsInput | boolean
    lateDays?: NullableIntFieldUpdateOperationsInput | number | null
    lateFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type loan_installmentsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    loanId?: StringFieldUpdateOperationsInput | string
    installmentNumber?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    principalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    interestAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isLate?: BoolFieldUpdateOperationsInput | boolean
    lateDays?: NullableIntFieldUpdateOperationsInput | number | null
    lateFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type loan_installmentsCreateManyInput = {
    id: string
    loanId: string
    installmentNumber: number
    dueDate: Date | string
    principalAmount: Decimal | DecimalJsLike | number | string
    interestAmount: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    isPaid?: boolean
    paidDate?: Date | string | null
    paidAmount?: Decimal | DecimalJsLike | number | string | null
    isLate?: boolean
    lateDays?: number | null
    lateFee?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type loan_installmentsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    loanId?: StringFieldUpdateOperationsInput | string
    installmentNumber?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    principalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    interestAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isLate?: BoolFieldUpdateOperationsInput | boolean
    lateDays?: NullableIntFieldUpdateOperationsInput | number | null
    lateFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type loan_installmentsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    loanId?: StringFieldUpdateOperationsInput | string
    installmentNumber?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    principalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    interestAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isLate?: BoolFieldUpdateOperationsInput | boolean
    lateDays?: NullableIntFieldUpdateOperationsInput | number | null
    lateFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type loansCreateInput = {
    id: string
    loanNumber: string
    customerId: string
    agentId?: string | null
    applicationId: string
    loanType: $Enums.loans_loanType
    status?: $Enums.loans_status
    principalAmount: Decimal | DecimalJsLike | number | string
    interestRate: Decimal | DecimalJsLike | number | string
    termMonths: number
    monthlyPayment: Decimal | DecimalJsLike | number | string
    currentInstallment?: number
    totalInstallments: number
    remainingBalance: Decimal | DecimalJsLike | number | string
    nextPaymentDate: Date | string
    contractDate: Date | string
    expiryDate: Date | string
    titleDeedNumber?: string | null
    collateralValue?: Decimal | DecimalJsLike | number | string | null
    collateralDetails?: NullableJsonNullValueInput | InputJsonValue
    linkMap?: string | null
    landAccountId?: number | null
    landAccountName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type loansUncheckedCreateInput = {
    id: string
    loanNumber: string
    customerId: string
    agentId?: string | null
    applicationId: string
    loanType: $Enums.loans_loanType
    status?: $Enums.loans_status
    principalAmount: Decimal | DecimalJsLike | number | string
    interestRate: Decimal | DecimalJsLike | number | string
    termMonths: number
    monthlyPayment: Decimal | DecimalJsLike | number | string
    currentInstallment?: number
    totalInstallments: number
    remainingBalance: Decimal | DecimalJsLike | number | string
    nextPaymentDate: Date | string
    contractDate: Date | string
    expiryDate: Date | string
    titleDeedNumber?: string | null
    collateralValue?: Decimal | DecimalJsLike | number | string | null
    collateralDetails?: NullableJsonNullValueInput | InputJsonValue
    linkMap?: string | null
    landAccountId?: number | null
    landAccountName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type loansUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    loanNumber?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    applicationId?: StringFieldUpdateOperationsInput | string
    loanType?: Enumloans_loanTypeFieldUpdateOperationsInput | $Enums.loans_loanType
    status?: Enumloans_statusFieldUpdateOperationsInput | $Enums.loans_status
    principalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    interestRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    termMonths?: IntFieldUpdateOperationsInput | number
    monthlyPayment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentInstallment?: IntFieldUpdateOperationsInput | number
    totalInstallments?: IntFieldUpdateOperationsInput | number
    remainingBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nextPaymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    contractDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    titleDeedNumber?: NullableStringFieldUpdateOperationsInput | string | null
    collateralValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    collateralDetails?: NullableJsonNullValueInput | InputJsonValue
    linkMap?: NullableStringFieldUpdateOperationsInput | string | null
    landAccountId?: NullableIntFieldUpdateOperationsInput | number | null
    landAccountName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type loansUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    loanNumber?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    applicationId?: StringFieldUpdateOperationsInput | string
    loanType?: Enumloans_loanTypeFieldUpdateOperationsInput | $Enums.loans_loanType
    status?: Enumloans_statusFieldUpdateOperationsInput | $Enums.loans_status
    principalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    interestRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    termMonths?: IntFieldUpdateOperationsInput | number
    monthlyPayment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentInstallment?: IntFieldUpdateOperationsInput | number
    totalInstallments?: IntFieldUpdateOperationsInput | number
    remainingBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nextPaymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    contractDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    titleDeedNumber?: NullableStringFieldUpdateOperationsInput | string | null
    collateralValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    collateralDetails?: NullableJsonNullValueInput | InputJsonValue
    linkMap?: NullableStringFieldUpdateOperationsInput | string | null
    landAccountId?: NullableIntFieldUpdateOperationsInput | number | null
    landAccountName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type loansCreateManyInput = {
    id: string
    loanNumber: string
    customerId: string
    agentId?: string | null
    applicationId: string
    loanType: $Enums.loans_loanType
    status?: $Enums.loans_status
    principalAmount: Decimal | DecimalJsLike | number | string
    interestRate: Decimal | DecimalJsLike | number | string
    termMonths: number
    monthlyPayment: Decimal | DecimalJsLike | number | string
    currentInstallment?: number
    totalInstallments: number
    remainingBalance: Decimal | DecimalJsLike | number | string
    nextPaymentDate: Date | string
    contractDate: Date | string
    expiryDate: Date | string
    titleDeedNumber?: string | null
    collateralValue?: Decimal | DecimalJsLike | number | string | null
    collateralDetails?: NullableJsonNullValueInput | InputJsonValue
    linkMap?: string | null
    landAccountId?: number | null
    landAccountName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type loansUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    loanNumber?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    applicationId?: StringFieldUpdateOperationsInput | string
    loanType?: Enumloans_loanTypeFieldUpdateOperationsInput | $Enums.loans_loanType
    status?: Enumloans_statusFieldUpdateOperationsInput | $Enums.loans_status
    principalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    interestRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    termMonths?: IntFieldUpdateOperationsInput | number
    monthlyPayment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentInstallment?: IntFieldUpdateOperationsInput | number
    totalInstallments?: IntFieldUpdateOperationsInput | number
    remainingBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nextPaymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    contractDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    titleDeedNumber?: NullableStringFieldUpdateOperationsInput | string | null
    collateralValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    collateralDetails?: NullableJsonNullValueInput | InputJsonValue
    linkMap?: NullableStringFieldUpdateOperationsInput | string | null
    landAccountId?: NullableIntFieldUpdateOperationsInput | number | null
    landAccountName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type loansUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    loanNumber?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    applicationId?: StringFieldUpdateOperationsInput | string
    loanType?: Enumloans_loanTypeFieldUpdateOperationsInput | $Enums.loans_loanType
    status?: Enumloans_statusFieldUpdateOperationsInput | $Enums.loans_status
    principalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    interestRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    termMonths?: IntFieldUpdateOperationsInput | number
    monthlyPayment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentInstallment?: IntFieldUpdateOperationsInput | number
    totalInstallments?: IntFieldUpdateOperationsInput | number
    remainingBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nextPaymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    contractDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    titleDeedNumber?: NullableStringFieldUpdateOperationsInput | string | null
    collateralValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    collateralDetails?: NullableJsonNullValueInput | InputJsonValue
    linkMap?: NullableStringFieldUpdateOperationsInput | string | null
    landAccountId?: NullableIntFieldUpdateOperationsInput | number | null
    landAccountName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notificationsCreateInput = {
    id: string
    userId: string
    type: $Enums.notifications_type
    title: string
    message: string
    actionUrl?: string | null
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type notificationsUncheckedCreateInput = {
    id: string
    userId: string
    type: $Enums.notifications_type
    title: string
    message: string
    actionUrl?: string | null
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type notificationsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: Enumnotifications_typeFieldUpdateOperationsInput | $Enums.notifications_type
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notificationsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: Enumnotifications_typeFieldUpdateOperationsInput | $Enums.notifications_type
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notificationsCreateManyInput = {
    id: string
    userId: string
    type: $Enums.notifications_type
    title: string
    message: string
    actionUrl?: string | null
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type notificationsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: Enumnotifications_typeFieldUpdateOperationsInput | $Enums.notifications_type
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notificationsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: Enumnotifications_typeFieldUpdateOperationsInput | $Enums.notifications_type
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type paymentsCreateInput = {
    id: string
    userId: string
    loanId: string
    installmentId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: $Enums.payments_paymentMethod
    status?: $Enums.payments_status
    referenceNumber: string
    transactionId?: string | null
    qrCode?: string | null
    barcodeNumber?: string | null
    bankName?: string | null
    accountNumber?: string | null
    accountName?: string | null
    dueDate: Date | string
    paidDate?: Date | string | null
    principalAmount?: Decimal | DecimalJsLike | number | string
    interestAmount?: Decimal | DecimalJsLike | number | string
    feeAmount?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type paymentsUncheckedCreateInput = {
    id: string
    userId: string
    loanId: string
    installmentId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: $Enums.payments_paymentMethod
    status?: $Enums.payments_status
    referenceNumber: string
    transactionId?: string | null
    qrCode?: string | null
    barcodeNumber?: string | null
    bankName?: string | null
    accountNumber?: string | null
    accountName?: string | null
    dueDate: Date | string
    paidDate?: Date | string | null
    principalAmount?: Decimal | DecimalJsLike | number | string
    interestAmount?: Decimal | DecimalJsLike | number | string
    feeAmount?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type paymentsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    loanId?: StringFieldUpdateOperationsInput | string
    installmentId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: Enumpayments_paymentMethodFieldUpdateOperationsInput | $Enums.payments_paymentMethod
    status?: Enumpayments_statusFieldUpdateOperationsInput | $Enums.payments_status
    referenceNumber?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    barcodeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    accountName?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    principalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    interestAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type paymentsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    loanId?: StringFieldUpdateOperationsInput | string
    installmentId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: Enumpayments_paymentMethodFieldUpdateOperationsInput | $Enums.payments_paymentMethod
    status?: Enumpayments_statusFieldUpdateOperationsInput | $Enums.payments_status
    referenceNumber?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    barcodeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    accountName?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    principalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    interestAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type paymentsCreateManyInput = {
    id: string
    userId: string
    loanId: string
    installmentId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: $Enums.payments_paymentMethod
    status?: $Enums.payments_status
    referenceNumber: string
    transactionId?: string | null
    qrCode?: string | null
    barcodeNumber?: string | null
    bankName?: string | null
    accountNumber?: string | null
    accountName?: string | null
    dueDate: Date | string
    paidDate?: Date | string | null
    principalAmount?: Decimal | DecimalJsLike | number | string
    interestAmount?: Decimal | DecimalJsLike | number | string
    feeAmount?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type paymentsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    loanId?: StringFieldUpdateOperationsInput | string
    installmentId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: Enumpayments_paymentMethodFieldUpdateOperationsInput | $Enums.payments_paymentMethod
    status?: Enumpayments_statusFieldUpdateOperationsInput | $Enums.payments_status
    referenceNumber?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    barcodeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    accountName?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    principalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    interestAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type paymentsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    loanId?: StringFieldUpdateOperationsInput | string
    installmentId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: Enumpayments_paymentMethodFieldUpdateOperationsInput | $Enums.payments_paymentMethod
    status?: Enumpayments_statusFieldUpdateOperationsInput | $Enums.payments_status
    referenceNumber?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    barcodeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    accountName?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    principalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    interestAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type privilegesCreateInput = {
    id: string
    title: string
    description: string
    imageUrl?: string | null
    actionUrl?: string | null
    isActive?: boolean
    sortOrder?: number
    targetUserTypes: JsonNullValueInput | InputJsonValue
    coinCost?: number | null
    requiresLoan?: boolean
    validFrom?: Date | string | null
    validUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type privilegesUncheckedCreateInput = {
    id: string
    title: string
    description: string
    imageUrl?: string | null
    actionUrl?: string | null
    isActive?: boolean
    sortOrder?: number
    targetUserTypes: JsonNullValueInput | InputJsonValue
    coinCost?: number | null
    requiresLoan?: boolean
    validFrom?: Date | string | null
    validUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type privilegesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    targetUserTypes?: JsonNullValueInput | InputJsonValue
    coinCost?: NullableIntFieldUpdateOperationsInput | number | null
    requiresLoan?: BoolFieldUpdateOperationsInput | boolean
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type privilegesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    targetUserTypes?: JsonNullValueInput | InputJsonValue
    coinCost?: NullableIntFieldUpdateOperationsInput | number | null
    requiresLoan?: BoolFieldUpdateOperationsInput | boolean
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type privilegesCreateManyInput = {
    id: string
    title: string
    description: string
    imageUrl?: string | null
    actionUrl?: string | null
    isActive?: boolean
    sortOrder?: number
    targetUserTypes: JsonNullValueInput | InputJsonValue
    coinCost?: number | null
    requiresLoan?: boolean
    validFrom?: Date | string | null
    validUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type privilegesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    targetUserTypes?: JsonNullValueInput | InputJsonValue
    coinCost?: NullableIntFieldUpdateOperationsInput | number | null
    requiresLoan?: BoolFieldUpdateOperationsInput | boolean
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type privilegesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    targetUserTypes?: JsonNullValueInput | InputJsonValue
    coinCost?: NullableIntFieldUpdateOperationsInput | number | null
    requiresLoan?: BoolFieldUpdateOperationsInput | boolean
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type reward_redemptionsCreateInput = {
    id: string
    userId: string
    rewardId: string
    coinSpent: number
    status?: $Enums.reward_redemptions_status
    deliveryAddress?: string | null
    trackingNumber?: string | null
    redeemedAt?: Date | string
    deliveredAt?: Date | string | null
  }

  export type reward_redemptionsUncheckedCreateInput = {
    id: string
    userId: string
    rewardId: string
    coinSpent: number
    status?: $Enums.reward_redemptions_status
    deliveryAddress?: string | null
    trackingNumber?: string | null
    redeemedAt?: Date | string
    deliveredAt?: Date | string | null
  }

  export type reward_redemptionsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rewardId?: StringFieldUpdateOperationsInput | string
    coinSpent?: IntFieldUpdateOperationsInput | number
    status?: Enumreward_redemptions_statusFieldUpdateOperationsInput | $Enums.reward_redemptions_status
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    redeemedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type reward_redemptionsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rewardId?: StringFieldUpdateOperationsInput | string
    coinSpent?: IntFieldUpdateOperationsInput | number
    status?: Enumreward_redemptions_statusFieldUpdateOperationsInput | $Enums.reward_redemptions_status
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    redeemedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type reward_redemptionsCreateManyInput = {
    id: string
    userId: string
    rewardId: string
    coinSpent: number
    status?: $Enums.reward_redemptions_status
    deliveryAddress?: string | null
    trackingNumber?: string | null
    redeemedAt?: Date | string
    deliveredAt?: Date | string | null
  }

  export type reward_redemptionsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rewardId?: StringFieldUpdateOperationsInput | string
    coinSpent?: IntFieldUpdateOperationsInput | number
    status?: Enumreward_redemptions_statusFieldUpdateOperationsInput | $Enums.reward_redemptions_status
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    redeemedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type reward_redemptionsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rewardId?: StringFieldUpdateOperationsInput | string
    coinSpent?: IntFieldUpdateOperationsInput | number
    status?: Enumreward_redemptions_statusFieldUpdateOperationsInput | $Enums.reward_redemptions_status
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    redeemedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type rewardsCreateInput = {
    id: string
    name: string
    description: string
    coinCost: number
    imageUrl?: string | null
    isActive?: boolean
    stockCount?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type rewardsUncheckedCreateInput = {
    id: string
    name: string
    description: string
    coinCost: number
    imageUrl?: string | null
    isActive?: boolean
    stockCount?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type rewardsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    coinCost?: IntFieldUpdateOperationsInput | number
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    stockCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type rewardsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    coinCost?: IntFieldUpdateOperationsInput | number
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    stockCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type rewardsCreateManyInput = {
    id: string
    name: string
    description: string
    coinCost: number
    imageUrl?: string | null
    isActive?: boolean
    stockCount?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type rewardsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    coinCost?: IntFieldUpdateOperationsInput | number
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    stockCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type rewardsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    coinCost?: IntFieldUpdateOperationsInput | number
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    stockCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type sessionsCreateInput = {
    id: string
    userId: string
    token: string
    deviceInfo?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type sessionsUncheckedCreateInput = {
    id: string
    userId: string
    token: string
    deviceInfo?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type sessionsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type sessionsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type sessionsCreateManyInput = {
    id: string
    userId: string
    token: string
    deviceInfo?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type sessionsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type sessionsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type system_configCreateInput = {
    id: string
    key: string
    value: string
    description?: string | null
    updatedAt: Date | string
  }

  export type system_configUncheckedCreateInput = {
    id: string
    key: string
    value: string
    description?: string | null
    updatedAt: Date | string
  }

  export type system_configUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type system_configUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type system_configCreateManyInput = {
    id: string
    key: string
    value: string
    description?: string | null
    updatedAt: Date | string
  }

  export type system_configUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type system_configUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type documentsCreateInput = {
    id: string
    docType: $Enums.documents_docType
    docNumber: string
    docDate: Date | string
    title: string
    price: Decimal | DecimalJsLike | number | string
    cashFlowName: string
    employeeId?: number
    username?: string | null
    docFile?: string | null
    docFileDate?: Date | string | null
    docFileTime?: string | null
    docFilePrice?: Decimal | DecimalJsLike | number | string | null
    filePath?: string | null
    note?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    deletedAt?: Date | string | null
  }

  export type documentsUncheckedCreateInput = {
    id: string
    docType: $Enums.documents_docType
    docNumber: string
    docDate: Date | string
    title: string
    price: Decimal | DecimalJsLike | number | string
    cashFlowName: string
    employeeId?: number
    username?: string | null
    docFile?: string | null
    docFileDate?: Date | string | null
    docFileTime?: string | null
    docFilePrice?: Decimal | DecimalJsLike | number | string | null
    filePath?: string | null
    note?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    deletedAt?: Date | string | null
  }

  export type documentsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    docType?: Enumdocuments_docTypeFieldUpdateOperationsInput | $Enums.documents_docType
    docNumber?: StringFieldUpdateOperationsInput | string
    docDate?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cashFlowName?: StringFieldUpdateOperationsInput | string
    employeeId?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    docFile?: NullableStringFieldUpdateOperationsInput | string | null
    docFileDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    docFileTime?: NullableStringFieldUpdateOperationsInput | string | null
    docFilePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type documentsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    docType?: Enumdocuments_docTypeFieldUpdateOperationsInput | $Enums.documents_docType
    docNumber?: StringFieldUpdateOperationsInput | string
    docDate?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cashFlowName?: StringFieldUpdateOperationsInput | string
    employeeId?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    docFile?: NullableStringFieldUpdateOperationsInput | string | null
    docFileDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    docFileTime?: NullableStringFieldUpdateOperationsInput | string | null
    docFilePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type documentsCreateManyInput = {
    id: string
    docType: $Enums.documents_docType
    docNumber: string
    docDate: Date | string
    title: string
    price: Decimal | DecimalJsLike | number | string
    cashFlowName: string
    employeeId?: number
    username?: string | null
    docFile?: string | null
    docFileDate?: Date | string | null
    docFileTime?: string | null
    docFilePrice?: Decimal | DecimalJsLike | number | string | null
    filePath?: string | null
    note?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    deletedAt?: Date | string | null
  }

  export type documentsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    docType?: Enumdocuments_docTypeFieldUpdateOperationsInput | $Enums.documents_docType
    docNumber?: StringFieldUpdateOperationsInput | string
    docDate?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cashFlowName?: StringFieldUpdateOperationsInput | string
    employeeId?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    docFile?: NullableStringFieldUpdateOperationsInput | string | null
    docFileDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    docFileTime?: NullableStringFieldUpdateOperationsInput | string | null
    docFilePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type documentsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    docType?: Enumdocuments_docTypeFieldUpdateOperationsInput | $Enums.documents_docType
    docNumber?: StringFieldUpdateOperationsInput | string
    docDate?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cashFlowName?: StringFieldUpdateOperationsInput | string
    employeeId?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    docFile?: NullableStringFieldUpdateOperationsInput | string | null
    docFileDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    docFileTime?: NullableStringFieldUpdateOperationsInput | string | null
    docFilePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type document_title_listsCreateInput = {
    id: string
    docType: $Enums.document_title_lists_docType
    title: string
    note?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    deletedAt?: Date | string | null
  }

  export type document_title_listsUncheckedCreateInput = {
    id: string
    docType: $Enums.document_title_lists_docType
    title: string
    note?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    deletedAt?: Date | string | null
  }

  export type document_title_listsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    docType?: Enumdocument_title_lists_docTypeFieldUpdateOperationsInput | $Enums.document_title_lists_docType
    title?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type document_title_listsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    docType?: Enumdocument_title_lists_docTypeFieldUpdateOperationsInput | $Enums.document_title_lists_docType
    title?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type document_title_listsCreateManyInput = {
    id: string
    docType: $Enums.document_title_lists_docType
    title: string
    note?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    deletedAt?: Date | string | null
  }

  export type document_title_listsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    docType?: Enumdocument_title_lists_docTypeFieldUpdateOperationsInput | $Enums.document_title_lists_docType
    title?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type document_title_listsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    docType?: Enumdocument_title_lists_docTypeFieldUpdateOperationsInput | $Enums.document_title_lists_docType
    title?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type land_accountsCreateInput = {
    id: string
    accountName: string
    accountBalance?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt: Date | string
    deletedAt?: Date | string | null
    logs?: land_account_logsCreateNestedManyWithoutLandAccountInput
    reports?: land_account_reportsCreateNestedManyWithoutLandAccountInput
  }

  export type land_accountsUncheckedCreateInput = {
    id: string
    accountName: string
    accountBalance?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt: Date | string
    deletedAt?: Date | string | null
    logs?: land_account_logsUncheckedCreateNestedManyWithoutLandAccountInput
    reports?: land_account_reportsUncheckedCreateNestedManyWithoutLandAccountInput
  }

  export type land_accountsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    accountBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logs?: land_account_logsUpdateManyWithoutLandAccountNestedInput
    reports?: land_account_reportsUpdateManyWithoutLandAccountNestedInput
  }

  export type land_accountsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    accountBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logs?: land_account_logsUncheckedUpdateManyWithoutLandAccountNestedInput
    reports?: land_account_reportsUncheckedUpdateManyWithoutLandAccountNestedInput
  }

  export type land_accountsCreateManyInput = {
    id: string
    accountName: string
    accountBalance?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt: Date | string
    deletedAt?: Date | string | null
  }

  export type land_accountsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    accountBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type land_accountsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    accountBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type land_account_logsCreateInput = {
    id: string
    detail: string
    amount?: Decimal | DecimalJsLike | number | string
    note?: string | null
    employeeId: number
    employeeName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    deletedAt?: Date | string | null
    landAccount: land_accountsCreateNestedOneWithoutLogsInput
  }

  export type land_account_logsUncheckedCreateInput = {
    id: string
    landAccountId: string
    detail: string
    amount?: Decimal | DecimalJsLike | number | string
    note?: string | null
    employeeId: number
    employeeName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    deletedAt?: Date | string | null
  }

  export type land_account_logsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    detail?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: IntFieldUpdateOperationsInput | number
    employeeName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    landAccount?: land_accountsUpdateOneRequiredWithoutLogsNestedInput
  }

  export type land_account_logsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    landAccountId?: StringFieldUpdateOperationsInput | string
    detail?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: IntFieldUpdateOperationsInput | number
    employeeName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type land_account_logsCreateManyInput = {
    id: string
    landAccountId: string
    detail: string
    amount?: Decimal | DecimalJsLike | number | string
    note?: string | null
    employeeId: number
    employeeName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    deletedAt?: Date | string | null
  }

  export type land_account_logsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    detail?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: IntFieldUpdateOperationsInput | number
    employeeName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type land_account_logsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    landAccountId?: StringFieldUpdateOperationsInput | string
    detail?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: IntFieldUpdateOperationsInput | number
    employeeName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type land_account_reportsCreateInput = {
    id: string
    detail: string
    amount?: Decimal | DecimalJsLike | number | string
    note?: string | null
    accountBalance?: Decimal | DecimalJsLike | number | string | null
    employeeId: number
    employeeName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    deletedAt?: Date | string | null
    landAccount: land_accountsCreateNestedOneWithoutReportsInput
  }

  export type land_account_reportsUncheckedCreateInput = {
    id: string
    landAccountId: string
    detail: string
    amount?: Decimal | DecimalJsLike | number | string
    note?: string | null
    accountBalance?: Decimal | DecimalJsLike | number | string | null
    employeeId: number
    employeeName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    deletedAt?: Date | string | null
  }

  export type land_account_reportsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    detail?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    accountBalance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    employeeId?: IntFieldUpdateOperationsInput | number
    employeeName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    landAccount?: land_accountsUpdateOneRequiredWithoutReportsNestedInput
  }

  export type land_account_reportsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    landAccountId?: StringFieldUpdateOperationsInput | string
    detail?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    accountBalance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    employeeId?: IntFieldUpdateOperationsInput | number
    employeeName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type land_account_reportsCreateManyInput = {
    id: string
    landAccountId: string
    detail: string
    amount?: Decimal | DecimalJsLike | number | string
    note?: string | null
    accountBalance?: Decimal | DecimalJsLike | number | string | null
    employeeId: number
    employeeName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    deletedAt?: Date | string | null
  }

  export type land_account_reportsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    detail?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    accountBalance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    employeeId?: IntFieldUpdateOperationsInput | number
    employeeName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type land_account_reportsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    landAccountId?: StringFieldUpdateOperationsInput | string
    detail?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    accountBalance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    employeeId?: IntFieldUpdateOperationsInput | number
    employeeName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type user_profilesCreateInput = {
    id: string
    userId: string
    firstName?: string | null
    lastName?: string | null
    idCardNumber?: string | null
    dateOfBirth?: Date | string | null
    address?: string | null
    email?: string | null
    lineId?: string | null
    idCardFrontImage?: string | null
    idCardBackImage?: string | null
    preferredLanguage?: string
    notificationEnabled?: boolean
    coinBalance?: number
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type user_profilesUncheckedCreateInput = {
    id: string
    userId: string
    firstName?: string | null
    lastName?: string | null
    idCardNumber?: string | null
    dateOfBirth?: Date | string | null
    address?: string | null
    email?: string | null
    lineId?: string | null
    idCardFrontImage?: string | null
    idCardBackImage?: string | null
    preferredLanguage?: string
    notificationEnabled?: boolean
    coinBalance?: number
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type user_profilesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    idCardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    lineId?: NullableStringFieldUpdateOperationsInput | string | null
    idCardFrontImage?: NullableStringFieldUpdateOperationsInput | string | null
    idCardBackImage?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    notificationEnabled?: BoolFieldUpdateOperationsInput | boolean
    coinBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_profilesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    idCardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    lineId?: NullableStringFieldUpdateOperationsInput | string | null
    idCardFrontImage?: NullableStringFieldUpdateOperationsInput | string | null
    idCardBackImage?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    notificationEnabled?: BoolFieldUpdateOperationsInput | boolean
    coinBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_profilesCreateManyInput = {
    id: string
    userId: string
    firstName?: string | null
    lastName?: string | null
    idCardNumber?: string | null
    dateOfBirth?: Date | string | null
    address?: string | null
    email?: string | null
    lineId?: string | null
    idCardFrontImage?: string | null
    idCardBackImage?: string | null
    preferredLanguage?: string
    notificationEnabled?: boolean
    coinBalance?: number
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type user_profilesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    idCardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    lineId?: NullableStringFieldUpdateOperationsInput | string | null
    idCardFrontImage?: NullableStringFieldUpdateOperationsInput | string | null
    idCardBackImage?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    notificationEnabled?: BoolFieldUpdateOperationsInput | boolean
    coinBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_profilesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    idCardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    lineId?: NullableStringFieldUpdateOperationsInput | string | null
    idCardFrontImage?: NullableStringFieldUpdateOperationsInput | string | null
    idCardBackImage?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    notificationEnabled?: BoolFieldUpdateOperationsInput | boolean
    coinBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usersCreateInput = {
    id: string
    phoneNumber: string
    pin?: string | null
    otpSecret?: string | null
    otpEnabled?: boolean
    lastOtpSentAt?: Date | string | null
    userType?: $Enums.users_userType
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type usersUncheckedCreateInput = {
    id: string
    phoneNumber: string
    pin?: string | null
    otpSecret?: string | null
    otpEnabled?: boolean
    lastOtpSentAt?: Date | string | null
    userType?: $Enums.users_userType
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type usersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    otpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    otpEnabled?: BoolFieldUpdateOperationsInput | boolean
    lastOtpSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userType?: Enumusers_userTypeFieldUpdateOperationsInput | $Enums.users_userType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    otpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    otpEnabled?: BoolFieldUpdateOperationsInput | boolean
    lastOtpSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userType?: Enumusers_userTypeFieldUpdateOperationsInput | $Enums.users_userType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usersCreateManyInput = {
    id: string
    phoneNumber: string
    pin?: string | null
    otpSecret?: string | null
    otpEnabled?: boolean
    lastOtpSentAt?: Date | string | null
    userType?: $Enums.users_userType
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type usersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    otpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    otpEnabled?: BoolFieldUpdateOperationsInput | boolean
    lastOtpSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userType?: Enumusers_userTypeFieldUpdateOperationsInput | $Enums.users_userType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    otpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    otpEnabled?: BoolFieldUpdateOperationsInput | boolean
    lastOtpSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userType?: Enumusers_userTypeFieldUpdateOperationsInput | $Enums.users_userType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type Enumadmin_permissions_permissionFilter<$PrismaModel = never> = {
    equals?: $Enums.admin_permissions_permission | Enumadmin_permissions_permissionFieldRefInput<$PrismaModel>
    in?: $Enums.admin_permissions_permission[]
    notIn?: $Enums.admin_permissions_permission[]
    not?: NestedEnumadmin_permissions_permissionFilter<$PrismaModel> | $Enums.admin_permissions_permission
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type admin_permissionsOrderByRelevanceInput = {
    fields: admin_permissionsOrderByRelevanceFieldEnum | admin_permissionsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type admin_permissionsAdminIdPermissionCompoundUniqueInput = {
    adminId: string
    permission: $Enums.admin_permissions_permission
  }

  export type admin_permissionsCountOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    permission?: SortOrder
    grantedAt?: SortOrder
    grantedBy?: SortOrder
  }

  export type admin_permissionsMaxOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    permission?: SortOrder
    grantedAt?: SortOrder
    grantedBy?: SortOrder
  }

  export type admin_permissionsMinOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    permission?: SortOrder
    grantedAt?: SortOrder
    grantedBy?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type Enumadmin_permissions_permissionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.admin_permissions_permission | Enumadmin_permissions_permissionFieldRefInput<$PrismaModel>
    in?: $Enums.admin_permissions_permission[]
    notIn?: $Enums.admin_permissions_permission[]
    not?: NestedEnumadmin_permissions_permissionWithAggregatesFilter<$PrismaModel> | $Enums.admin_permissions_permission
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumadmin_permissions_permissionFilter<$PrismaModel>
    _max?: NestedEnumadmin_permissions_permissionFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type admin_sessionsOrderByRelevanceInput = {
    fields: admin_sessionsOrderByRelevanceFieldEnum | admin_sessionsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type admin_sessionsCountOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    token?: SortOrder
    deviceInfo?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type admin_sessionsMaxOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    token?: SortOrder
    deviceInfo?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type admin_sessionsMinOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    token?: SortOrder
    deviceInfo?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type Enumadmins_roleFilter<$PrismaModel = never> = {
    equals?: $Enums.admins_role | Enumadmins_roleFieldRefInput<$PrismaModel>
    in?: $Enums.admins_role[]
    notIn?: $Enums.admins_role[]
    not?: NestedEnumadmins_roleFilter<$PrismaModel> | $Enums.admins_role
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type adminsOrderByRelevanceInput = {
    fields: adminsOrderByRelevanceFieldEnum | adminsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type adminsCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type adminsMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type adminsMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type Enumadmins_roleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.admins_role | Enumadmins_roleFieldRefInput<$PrismaModel>
    in?: $Enums.admins_role[]
    notIn?: $Enums.admins_role[]
    not?: NestedEnumadmins_roleWithAggregatesFilter<$PrismaModel> | $Enums.admins_role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumadmins_roleFilter<$PrismaModel>
    _max?: NestedEnumadmins_roleFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type agent_customersOrderByRelevanceInput = {
    fields: agent_customersOrderByRelevanceFieldEnum | agent_customersOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type agent_customersAgentIdCustomerIdCompoundUniqueInput = {
    agentId: string
    customerId: string
  }

  export type agent_customersCountOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    customerId?: SortOrder
    assignedAt?: SortOrder
    isActive?: SortOrder
  }

  export type agent_customersMaxOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    customerId?: SortOrder
    assignedAt?: SortOrder
    isActive?: SortOrder
  }

  export type agent_customersMinOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    customerId?: SortOrder
    assignedAt?: SortOrder
    isActive?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type audit_logsOrderByRelevanceInput = {
    fields: audit_logsOrderByRelevanceFieldEnum | audit_logsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type audit_logsCountOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    oldData?: SortOrder
    newData?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    adminId?: SortOrder
  }

  export type audit_logsMaxOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    adminId?: SortOrder
  }

  export type audit_logsMinOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    adminId?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type bannersOrderByRelevanceInput = {
    fields: bannersOrderByRelevanceFieldEnum | bannersOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type bannersCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    actionUrl?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    targetUserTypes?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type bannersAvgOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type bannersMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    actionUrl?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type bannersMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    actionUrl?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type bannersSumOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type Enumcoin_transactions_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.coin_transactions_type | Enumcoin_transactions_typeFieldRefInput<$PrismaModel>
    in?: $Enums.coin_transactions_type[]
    notIn?: $Enums.coin_transactions_type[]
    not?: NestedEnumcoin_transactions_typeFilter<$PrismaModel> | $Enums.coin_transactions_type
  }

  export type coin_transactionsOrderByRelevanceInput = {
    fields: coin_transactionsOrderByRelevanceFieldEnum | coin_transactionsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type coin_transactionsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    loanId?: SortOrder
    rewardId?: SortOrder
    createdAt?: SortOrder
  }

  export type coin_transactionsAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type coin_transactionsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    loanId?: SortOrder
    rewardId?: SortOrder
    createdAt?: SortOrder
  }

  export type coin_transactionsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    loanId?: SortOrder
    rewardId?: SortOrder
    createdAt?: SortOrder
  }

  export type coin_transactionsSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type Enumcoin_transactions_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.coin_transactions_type | Enumcoin_transactions_typeFieldRefInput<$PrismaModel>
    in?: $Enums.coin_transactions_type[]
    notIn?: $Enums.coin_transactions_type[]
    not?: NestedEnumcoin_transactions_typeWithAggregatesFilter<$PrismaModel> | $Enums.coin_transactions_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumcoin_transactions_typeFilter<$PrismaModel>
    _max?: NestedEnumcoin_transactions_typeFilter<$PrismaModel>
  }

  export type Enumloan_applications_loanTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.loan_applications_loanType | Enumloan_applications_loanTypeFieldRefInput<$PrismaModel>
    in?: $Enums.loan_applications_loanType[]
    notIn?: $Enums.loan_applications_loanType[]
    not?: NestedEnumloan_applications_loanTypeFilter<$PrismaModel> | $Enums.loan_applications_loanType
  }

  export type Enumloan_applications_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.loan_applications_status | Enumloan_applications_statusFieldRefInput<$PrismaModel>
    in?: $Enums.loan_applications_status[]
    notIn?: $Enums.loan_applications_status[]
    not?: NestedEnumloan_applications_statusFilter<$PrismaModel> | $Enums.loan_applications_status
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type loan_applicationsOrderByRelevanceInput = {
    fields: loan_applicationsOrderByRelevanceFieldEnum | loan_applicationsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type loan_applicationsCountOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    agentId?: SortOrder
    loanType?: SortOrder
    status?: SortOrder
    currentStep?: SortOrder
    completedSteps?: SortOrder
    isNewUser?: SortOrder
    submittedByAgent?: SortOrder
    titleDeedImage?: SortOrder
    titleDeedData?: SortOrder
    supportingImages?: SortOrder
    idCardFrontImage?: SortOrder
    idCardBackImage?: SortOrder
    requestedAmount?: SortOrder
    approvedAmount?: SortOrder
    maxApprovedAmount?: SortOrder
    propertyType?: SortOrder
    propertyValue?: SortOrder
    propertyArea?: SortOrder
    propertyLocation?: SortOrder
    landNumber?: SortOrder
    ownerName?: SortOrder
    submittedAt?: SortOrder
    reviewedAt?: SortOrder
    reviewedBy?: SortOrder
    reviewNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type loan_applicationsAvgOrderByAggregateInput = {
    currentStep?: SortOrder
    requestedAmount?: SortOrder
    approvedAmount?: SortOrder
    maxApprovedAmount?: SortOrder
    propertyValue?: SortOrder
  }

  export type loan_applicationsMaxOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    agentId?: SortOrder
    loanType?: SortOrder
    status?: SortOrder
    currentStep?: SortOrder
    isNewUser?: SortOrder
    submittedByAgent?: SortOrder
    titleDeedImage?: SortOrder
    idCardFrontImage?: SortOrder
    idCardBackImage?: SortOrder
    requestedAmount?: SortOrder
    approvedAmount?: SortOrder
    maxApprovedAmount?: SortOrder
    propertyType?: SortOrder
    propertyValue?: SortOrder
    propertyArea?: SortOrder
    propertyLocation?: SortOrder
    landNumber?: SortOrder
    ownerName?: SortOrder
    submittedAt?: SortOrder
    reviewedAt?: SortOrder
    reviewedBy?: SortOrder
    reviewNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type loan_applicationsMinOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    agentId?: SortOrder
    loanType?: SortOrder
    status?: SortOrder
    currentStep?: SortOrder
    isNewUser?: SortOrder
    submittedByAgent?: SortOrder
    titleDeedImage?: SortOrder
    idCardFrontImage?: SortOrder
    idCardBackImage?: SortOrder
    requestedAmount?: SortOrder
    approvedAmount?: SortOrder
    maxApprovedAmount?: SortOrder
    propertyType?: SortOrder
    propertyValue?: SortOrder
    propertyArea?: SortOrder
    propertyLocation?: SortOrder
    landNumber?: SortOrder
    ownerName?: SortOrder
    submittedAt?: SortOrder
    reviewedAt?: SortOrder
    reviewedBy?: SortOrder
    reviewNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type loan_applicationsSumOrderByAggregateInput = {
    currentStep?: SortOrder
    requestedAmount?: SortOrder
    approvedAmount?: SortOrder
    maxApprovedAmount?: SortOrder
    propertyValue?: SortOrder
  }

  export type Enumloan_applications_loanTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.loan_applications_loanType | Enumloan_applications_loanTypeFieldRefInput<$PrismaModel>
    in?: $Enums.loan_applications_loanType[]
    notIn?: $Enums.loan_applications_loanType[]
    not?: NestedEnumloan_applications_loanTypeWithAggregatesFilter<$PrismaModel> | $Enums.loan_applications_loanType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumloan_applications_loanTypeFilter<$PrismaModel>
    _max?: NestedEnumloan_applications_loanTypeFilter<$PrismaModel>
  }

  export type Enumloan_applications_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.loan_applications_status | Enumloan_applications_statusFieldRefInput<$PrismaModel>
    in?: $Enums.loan_applications_status[]
    notIn?: $Enums.loan_applications_status[]
    not?: NestedEnumloan_applications_statusWithAggregatesFilter<$PrismaModel> | $Enums.loan_applications_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumloan_applications_statusFilter<$PrismaModel>
    _max?: NestedEnumloan_applications_statusFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type loan_installmentsOrderByRelevanceInput = {
    fields: loan_installmentsOrderByRelevanceFieldEnum | loan_installmentsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type loan_installmentsLoanIdInstallmentNumberCompoundUniqueInput = {
    loanId: string
    installmentNumber: number
  }

  export type loan_installmentsCountOrderByAggregateInput = {
    id?: SortOrder
    loanId?: SortOrder
    installmentNumber?: SortOrder
    dueDate?: SortOrder
    principalAmount?: SortOrder
    interestAmount?: SortOrder
    totalAmount?: SortOrder
    isPaid?: SortOrder
    paidDate?: SortOrder
    paidAmount?: SortOrder
    isLate?: SortOrder
    lateDays?: SortOrder
    lateFee?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type loan_installmentsAvgOrderByAggregateInput = {
    installmentNumber?: SortOrder
    principalAmount?: SortOrder
    interestAmount?: SortOrder
    totalAmount?: SortOrder
    paidAmount?: SortOrder
    lateDays?: SortOrder
    lateFee?: SortOrder
  }

  export type loan_installmentsMaxOrderByAggregateInput = {
    id?: SortOrder
    loanId?: SortOrder
    installmentNumber?: SortOrder
    dueDate?: SortOrder
    principalAmount?: SortOrder
    interestAmount?: SortOrder
    totalAmount?: SortOrder
    isPaid?: SortOrder
    paidDate?: SortOrder
    paidAmount?: SortOrder
    isLate?: SortOrder
    lateDays?: SortOrder
    lateFee?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type loan_installmentsMinOrderByAggregateInput = {
    id?: SortOrder
    loanId?: SortOrder
    installmentNumber?: SortOrder
    dueDate?: SortOrder
    principalAmount?: SortOrder
    interestAmount?: SortOrder
    totalAmount?: SortOrder
    isPaid?: SortOrder
    paidDate?: SortOrder
    paidAmount?: SortOrder
    isLate?: SortOrder
    lateDays?: SortOrder
    lateFee?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type loan_installmentsSumOrderByAggregateInput = {
    installmentNumber?: SortOrder
    principalAmount?: SortOrder
    interestAmount?: SortOrder
    totalAmount?: SortOrder
    paidAmount?: SortOrder
    lateDays?: SortOrder
    lateFee?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type Enumloans_loanTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.loans_loanType | Enumloans_loanTypeFieldRefInput<$PrismaModel>
    in?: $Enums.loans_loanType[]
    notIn?: $Enums.loans_loanType[]
    not?: NestedEnumloans_loanTypeFilter<$PrismaModel> | $Enums.loans_loanType
  }

  export type Enumloans_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.loans_status | Enumloans_statusFieldRefInput<$PrismaModel>
    in?: $Enums.loans_status[]
    notIn?: $Enums.loans_status[]
    not?: NestedEnumloans_statusFilter<$PrismaModel> | $Enums.loans_status
  }

  export type loansOrderByRelevanceInput = {
    fields: loansOrderByRelevanceFieldEnum | loansOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type loansCountOrderByAggregateInput = {
    id?: SortOrder
    loanNumber?: SortOrder
    customerId?: SortOrder
    agentId?: SortOrder
    applicationId?: SortOrder
    loanType?: SortOrder
    status?: SortOrder
    principalAmount?: SortOrder
    interestRate?: SortOrder
    termMonths?: SortOrder
    monthlyPayment?: SortOrder
    currentInstallment?: SortOrder
    totalInstallments?: SortOrder
    remainingBalance?: SortOrder
    nextPaymentDate?: SortOrder
    contractDate?: SortOrder
    expiryDate?: SortOrder
    titleDeedNumber?: SortOrder
    collateralValue?: SortOrder
    collateralDetails?: SortOrder
    linkMap?: SortOrder
    landAccountId?: SortOrder
    landAccountName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type loansAvgOrderByAggregateInput = {
    principalAmount?: SortOrder
    interestRate?: SortOrder
    termMonths?: SortOrder
    monthlyPayment?: SortOrder
    currentInstallment?: SortOrder
    totalInstallments?: SortOrder
    remainingBalance?: SortOrder
    collateralValue?: SortOrder
    landAccountId?: SortOrder
  }

  export type loansMaxOrderByAggregateInput = {
    id?: SortOrder
    loanNumber?: SortOrder
    customerId?: SortOrder
    agentId?: SortOrder
    applicationId?: SortOrder
    loanType?: SortOrder
    status?: SortOrder
    principalAmount?: SortOrder
    interestRate?: SortOrder
    termMonths?: SortOrder
    monthlyPayment?: SortOrder
    currentInstallment?: SortOrder
    totalInstallments?: SortOrder
    remainingBalance?: SortOrder
    nextPaymentDate?: SortOrder
    contractDate?: SortOrder
    expiryDate?: SortOrder
    titleDeedNumber?: SortOrder
    collateralValue?: SortOrder
    linkMap?: SortOrder
    landAccountId?: SortOrder
    landAccountName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type loansMinOrderByAggregateInput = {
    id?: SortOrder
    loanNumber?: SortOrder
    customerId?: SortOrder
    agentId?: SortOrder
    applicationId?: SortOrder
    loanType?: SortOrder
    status?: SortOrder
    principalAmount?: SortOrder
    interestRate?: SortOrder
    termMonths?: SortOrder
    monthlyPayment?: SortOrder
    currentInstallment?: SortOrder
    totalInstallments?: SortOrder
    remainingBalance?: SortOrder
    nextPaymentDate?: SortOrder
    contractDate?: SortOrder
    expiryDate?: SortOrder
    titleDeedNumber?: SortOrder
    collateralValue?: SortOrder
    linkMap?: SortOrder
    landAccountId?: SortOrder
    landAccountName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type loansSumOrderByAggregateInput = {
    principalAmount?: SortOrder
    interestRate?: SortOrder
    termMonths?: SortOrder
    monthlyPayment?: SortOrder
    currentInstallment?: SortOrder
    totalInstallments?: SortOrder
    remainingBalance?: SortOrder
    collateralValue?: SortOrder
    landAccountId?: SortOrder
  }

  export type Enumloans_loanTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.loans_loanType | Enumloans_loanTypeFieldRefInput<$PrismaModel>
    in?: $Enums.loans_loanType[]
    notIn?: $Enums.loans_loanType[]
    not?: NestedEnumloans_loanTypeWithAggregatesFilter<$PrismaModel> | $Enums.loans_loanType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumloans_loanTypeFilter<$PrismaModel>
    _max?: NestedEnumloans_loanTypeFilter<$PrismaModel>
  }

  export type Enumloans_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.loans_status | Enumloans_statusFieldRefInput<$PrismaModel>
    in?: $Enums.loans_status[]
    notIn?: $Enums.loans_status[]
    not?: NestedEnumloans_statusWithAggregatesFilter<$PrismaModel> | $Enums.loans_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumloans_statusFilter<$PrismaModel>
    _max?: NestedEnumloans_statusFilter<$PrismaModel>
  }

  export type Enumnotifications_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.notifications_type | Enumnotifications_typeFieldRefInput<$PrismaModel>
    in?: $Enums.notifications_type[]
    notIn?: $Enums.notifications_type[]
    not?: NestedEnumnotifications_typeFilter<$PrismaModel> | $Enums.notifications_type
  }

  export type notificationsOrderByRelevanceInput = {
    fields: notificationsOrderByRelevanceFieldEnum | notificationsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type notificationsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    actionUrl?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type notificationsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    actionUrl?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type notificationsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    actionUrl?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type Enumnotifications_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.notifications_type | Enumnotifications_typeFieldRefInput<$PrismaModel>
    in?: $Enums.notifications_type[]
    notIn?: $Enums.notifications_type[]
    not?: NestedEnumnotifications_typeWithAggregatesFilter<$PrismaModel> | $Enums.notifications_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumnotifications_typeFilter<$PrismaModel>
    _max?: NestedEnumnotifications_typeFilter<$PrismaModel>
  }

  export type Enumpayments_paymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.payments_paymentMethod | Enumpayments_paymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.payments_paymentMethod[]
    notIn?: $Enums.payments_paymentMethod[]
    not?: NestedEnumpayments_paymentMethodFilter<$PrismaModel> | $Enums.payments_paymentMethod
  }

  export type Enumpayments_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.payments_status | Enumpayments_statusFieldRefInput<$PrismaModel>
    in?: $Enums.payments_status[]
    notIn?: $Enums.payments_status[]
    not?: NestedEnumpayments_statusFilter<$PrismaModel> | $Enums.payments_status
  }

  export type paymentsOrderByRelevanceInput = {
    fields: paymentsOrderByRelevanceFieldEnum | paymentsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type paymentsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    loanId?: SortOrder
    installmentId?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    status?: SortOrder
    referenceNumber?: SortOrder
    transactionId?: SortOrder
    qrCode?: SortOrder
    barcodeNumber?: SortOrder
    bankName?: SortOrder
    accountNumber?: SortOrder
    accountName?: SortOrder
    dueDate?: SortOrder
    paidDate?: SortOrder
    principalAmount?: SortOrder
    interestAmount?: SortOrder
    feeAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type paymentsAvgOrderByAggregateInput = {
    amount?: SortOrder
    principalAmount?: SortOrder
    interestAmount?: SortOrder
    feeAmount?: SortOrder
  }

  export type paymentsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    loanId?: SortOrder
    installmentId?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    status?: SortOrder
    referenceNumber?: SortOrder
    transactionId?: SortOrder
    qrCode?: SortOrder
    barcodeNumber?: SortOrder
    bankName?: SortOrder
    accountNumber?: SortOrder
    accountName?: SortOrder
    dueDate?: SortOrder
    paidDate?: SortOrder
    principalAmount?: SortOrder
    interestAmount?: SortOrder
    feeAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type paymentsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    loanId?: SortOrder
    installmentId?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    status?: SortOrder
    referenceNumber?: SortOrder
    transactionId?: SortOrder
    qrCode?: SortOrder
    barcodeNumber?: SortOrder
    bankName?: SortOrder
    accountNumber?: SortOrder
    accountName?: SortOrder
    dueDate?: SortOrder
    paidDate?: SortOrder
    principalAmount?: SortOrder
    interestAmount?: SortOrder
    feeAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type paymentsSumOrderByAggregateInput = {
    amount?: SortOrder
    principalAmount?: SortOrder
    interestAmount?: SortOrder
    feeAmount?: SortOrder
  }

  export type Enumpayments_paymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.payments_paymentMethod | Enumpayments_paymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.payments_paymentMethod[]
    notIn?: $Enums.payments_paymentMethod[]
    not?: NestedEnumpayments_paymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.payments_paymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumpayments_paymentMethodFilter<$PrismaModel>
    _max?: NestedEnumpayments_paymentMethodFilter<$PrismaModel>
  }

  export type Enumpayments_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.payments_status | Enumpayments_statusFieldRefInput<$PrismaModel>
    in?: $Enums.payments_status[]
    notIn?: $Enums.payments_status[]
    not?: NestedEnumpayments_statusWithAggregatesFilter<$PrismaModel> | $Enums.payments_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumpayments_statusFilter<$PrismaModel>
    _max?: NestedEnumpayments_statusFilter<$PrismaModel>
  }

  export type privilegesOrderByRelevanceInput = {
    fields: privilegesOrderByRelevanceFieldEnum | privilegesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type privilegesCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    actionUrl?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    targetUserTypes?: SortOrder
    coinCost?: SortOrder
    requiresLoan?: SortOrder
    validFrom?: SortOrder
    validUntil?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type privilegesAvgOrderByAggregateInput = {
    sortOrder?: SortOrder
    coinCost?: SortOrder
  }

  export type privilegesMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    actionUrl?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    coinCost?: SortOrder
    requiresLoan?: SortOrder
    validFrom?: SortOrder
    validUntil?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type privilegesMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    actionUrl?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    coinCost?: SortOrder
    requiresLoan?: SortOrder
    validFrom?: SortOrder
    validUntil?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type privilegesSumOrderByAggregateInput = {
    sortOrder?: SortOrder
    coinCost?: SortOrder
  }

  export type Enumreward_redemptions_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.reward_redemptions_status | Enumreward_redemptions_statusFieldRefInput<$PrismaModel>
    in?: $Enums.reward_redemptions_status[]
    notIn?: $Enums.reward_redemptions_status[]
    not?: NestedEnumreward_redemptions_statusFilter<$PrismaModel> | $Enums.reward_redemptions_status
  }

  export type reward_redemptionsOrderByRelevanceInput = {
    fields: reward_redemptionsOrderByRelevanceFieldEnum | reward_redemptionsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type reward_redemptionsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    rewardId?: SortOrder
    coinSpent?: SortOrder
    status?: SortOrder
    deliveryAddress?: SortOrder
    trackingNumber?: SortOrder
    redeemedAt?: SortOrder
    deliveredAt?: SortOrder
  }

  export type reward_redemptionsAvgOrderByAggregateInput = {
    coinSpent?: SortOrder
  }

  export type reward_redemptionsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    rewardId?: SortOrder
    coinSpent?: SortOrder
    status?: SortOrder
    deliveryAddress?: SortOrder
    trackingNumber?: SortOrder
    redeemedAt?: SortOrder
    deliveredAt?: SortOrder
  }

  export type reward_redemptionsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    rewardId?: SortOrder
    coinSpent?: SortOrder
    status?: SortOrder
    deliveryAddress?: SortOrder
    trackingNumber?: SortOrder
    redeemedAt?: SortOrder
    deliveredAt?: SortOrder
  }

  export type reward_redemptionsSumOrderByAggregateInput = {
    coinSpent?: SortOrder
  }

  export type Enumreward_redemptions_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.reward_redemptions_status | Enumreward_redemptions_statusFieldRefInput<$PrismaModel>
    in?: $Enums.reward_redemptions_status[]
    notIn?: $Enums.reward_redemptions_status[]
    not?: NestedEnumreward_redemptions_statusWithAggregatesFilter<$PrismaModel> | $Enums.reward_redemptions_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumreward_redemptions_statusFilter<$PrismaModel>
    _max?: NestedEnumreward_redemptions_statusFilter<$PrismaModel>
  }

  export type rewardsOrderByRelevanceInput = {
    fields: rewardsOrderByRelevanceFieldEnum | rewardsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type rewardsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    coinCost?: SortOrder
    imageUrl?: SortOrder
    isActive?: SortOrder
    stockCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type rewardsAvgOrderByAggregateInput = {
    coinCost?: SortOrder
    stockCount?: SortOrder
  }

  export type rewardsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    coinCost?: SortOrder
    imageUrl?: SortOrder
    isActive?: SortOrder
    stockCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type rewardsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    coinCost?: SortOrder
    imageUrl?: SortOrder
    isActive?: SortOrder
    stockCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type rewardsSumOrderByAggregateInput = {
    coinCost?: SortOrder
    stockCount?: SortOrder
  }

  export type sessionsOrderByRelevanceInput = {
    fields: sessionsOrderByRelevanceFieldEnum | sessionsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type sessionsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    deviceInfo?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type sessionsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    deviceInfo?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type sessionsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    deviceInfo?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type system_configOrderByRelevanceInput = {
    fields: system_configOrderByRelevanceFieldEnum | system_configOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type system_configCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrder
    updatedAt?: SortOrder
  }

  export type system_configMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrder
    updatedAt?: SortOrder
  }

  export type system_configMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrder
    updatedAt?: SortOrder
  }

  export type Enumdocuments_docTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.documents_docType | Enumdocuments_docTypeFieldRefInput<$PrismaModel>
    in?: $Enums.documents_docType[]
    notIn?: $Enums.documents_docType[]
    not?: NestedEnumdocuments_docTypeFilter<$PrismaModel> | $Enums.documents_docType
  }

  export type documentsOrderByRelevanceInput = {
    fields: documentsOrderByRelevanceFieldEnum | documentsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type documentsCountOrderByAggregateInput = {
    id?: SortOrder
    docType?: SortOrder
    docNumber?: SortOrder
    docDate?: SortOrder
    title?: SortOrder
    price?: SortOrder
    cashFlowName?: SortOrder
    employeeId?: SortOrder
    username?: SortOrder
    docFile?: SortOrder
    docFileDate?: SortOrder
    docFileTime?: SortOrder
    docFilePrice?: SortOrder
    filePath?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type documentsAvgOrderByAggregateInput = {
    price?: SortOrder
    employeeId?: SortOrder
    docFilePrice?: SortOrder
  }

  export type documentsMaxOrderByAggregateInput = {
    id?: SortOrder
    docType?: SortOrder
    docNumber?: SortOrder
    docDate?: SortOrder
    title?: SortOrder
    price?: SortOrder
    cashFlowName?: SortOrder
    employeeId?: SortOrder
    username?: SortOrder
    docFile?: SortOrder
    docFileDate?: SortOrder
    docFileTime?: SortOrder
    docFilePrice?: SortOrder
    filePath?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type documentsMinOrderByAggregateInput = {
    id?: SortOrder
    docType?: SortOrder
    docNumber?: SortOrder
    docDate?: SortOrder
    title?: SortOrder
    price?: SortOrder
    cashFlowName?: SortOrder
    employeeId?: SortOrder
    username?: SortOrder
    docFile?: SortOrder
    docFileDate?: SortOrder
    docFileTime?: SortOrder
    docFilePrice?: SortOrder
    filePath?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type documentsSumOrderByAggregateInput = {
    price?: SortOrder
    employeeId?: SortOrder
    docFilePrice?: SortOrder
  }

  export type Enumdocuments_docTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.documents_docType | Enumdocuments_docTypeFieldRefInput<$PrismaModel>
    in?: $Enums.documents_docType[]
    notIn?: $Enums.documents_docType[]
    not?: NestedEnumdocuments_docTypeWithAggregatesFilter<$PrismaModel> | $Enums.documents_docType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumdocuments_docTypeFilter<$PrismaModel>
    _max?: NestedEnumdocuments_docTypeFilter<$PrismaModel>
  }

  export type Enumdocument_title_lists_docTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.document_title_lists_docType | Enumdocument_title_lists_docTypeFieldRefInput<$PrismaModel>
    in?: $Enums.document_title_lists_docType[]
    notIn?: $Enums.document_title_lists_docType[]
    not?: NestedEnumdocument_title_lists_docTypeFilter<$PrismaModel> | $Enums.document_title_lists_docType
  }

  export type document_title_listsOrderByRelevanceInput = {
    fields: document_title_listsOrderByRelevanceFieldEnum | document_title_listsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type document_title_listsCountOrderByAggregateInput = {
    id?: SortOrder
    docType?: SortOrder
    title?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type document_title_listsMaxOrderByAggregateInput = {
    id?: SortOrder
    docType?: SortOrder
    title?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type document_title_listsMinOrderByAggregateInput = {
    id?: SortOrder
    docType?: SortOrder
    title?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type Enumdocument_title_lists_docTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.document_title_lists_docType | Enumdocument_title_lists_docTypeFieldRefInput<$PrismaModel>
    in?: $Enums.document_title_lists_docType[]
    notIn?: $Enums.document_title_lists_docType[]
    not?: NestedEnumdocument_title_lists_docTypeWithAggregatesFilter<$PrismaModel> | $Enums.document_title_lists_docType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumdocument_title_lists_docTypeFilter<$PrismaModel>
    _max?: NestedEnumdocument_title_lists_docTypeFilter<$PrismaModel>
  }

  export type Land_account_logsListRelationFilter = {
    every?: land_account_logsWhereInput
    some?: land_account_logsWhereInput
    none?: land_account_logsWhereInput
  }

  export type Land_account_reportsListRelationFilter = {
    every?: land_account_reportsWhereInput
    some?: land_account_reportsWhereInput
    none?: land_account_reportsWhereInput
  }

  export type land_account_logsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type land_account_reportsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type land_accountsOrderByRelevanceInput = {
    fields: land_accountsOrderByRelevanceFieldEnum | land_accountsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type land_accountsCountOrderByAggregateInput = {
    id?: SortOrder
    accountName?: SortOrder
    accountBalance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type land_accountsAvgOrderByAggregateInput = {
    accountBalance?: SortOrder
  }

  export type land_accountsMaxOrderByAggregateInput = {
    id?: SortOrder
    accountName?: SortOrder
    accountBalance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type land_accountsMinOrderByAggregateInput = {
    id?: SortOrder
    accountName?: SortOrder
    accountBalance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type land_accountsSumOrderByAggregateInput = {
    accountBalance?: SortOrder
  }

  export type Land_accountsScalarRelationFilter = {
    is?: land_accountsWhereInput
    isNot?: land_accountsWhereInput
  }

  export type land_account_logsOrderByRelevanceInput = {
    fields: land_account_logsOrderByRelevanceFieldEnum | land_account_logsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type land_account_logsCountOrderByAggregateInput = {
    id?: SortOrder
    landAccountId?: SortOrder
    detail?: SortOrder
    amount?: SortOrder
    note?: SortOrder
    employeeId?: SortOrder
    employeeName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type land_account_logsAvgOrderByAggregateInput = {
    amount?: SortOrder
    employeeId?: SortOrder
  }

  export type land_account_logsMaxOrderByAggregateInput = {
    id?: SortOrder
    landAccountId?: SortOrder
    detail?: SortOrder
    amount?: SortOrder
    note?: SortOrder
    employeeId?: SortOrder
    employeeName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type land_account_logsMinOrderByAggregateInput = {
    id?: SortOrder
    landAccountId?: SortOrder
    detail?: SortOrder
    amount?: SortOrder
    note?: SortOrder
    employeeId?: SortOrder
    employeeName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type land_account_logsSumOrderByAggregateInput = {
    amount?: SortOrder
    employeeId?: SortOrder
  }

  export type land_account_reportsOrderByRelevanceInput = {
    fields: land_account_reportsOrderByRelevanceFieldEnum | land_account_reportsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type land_account_reportsCountOrderByAggregateInput = {
    id?: SortOrder
    landAccountId?: SortOrder
    detail?: SortOrder
    amount?: SortOrder
    note?: SortOrder
    accountBalance?: SortOrder
    employeeId?: SortOrder
    employeeName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type land_account_reportsAvgOrderByAggregateInput = {
    amount?: SortOrder
    accountBalance?: SortOrder
    employeeId?: SortOrder
  }

  export type land_account_reportsMaxOrderByAggregateInput = {
    id?: SortOrder
    landAccountId?: SortOrder
    detail?: SortOrder
    amount?: SortOrder
    note?: SortOrder
    accountBalance?: SortOrder
    employeeId?: SortOrder
    employeeName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type land_account_reportsMinOrderByAggregateInput = {
    id?: SortOrder
    landAccountId?: SortOrder
    detail?: SortOrder
    amount?: SortOrder
    note?: SortOrder
    accountBalance?: SortOrder
    employeeId?: SortOrder
    employeeName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type land_account_reportsSumOrderByAggregateInput = {
    amount?: SortOrder
    accountBalance?: SortOrder
    employeeId?: SortOrder
  }

  export type user_profilesOrderByRelevanceInput = {
    fields: user_profilesOrderByRelevanceFieldEnum | user_profilesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type user_profilesCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    idCardNumber?: SortOrder
    dateOfBirth?: SortOrder
    address?: SortOrder
    email?: SortOrder
    lineId?: SortOrder
    idCardFrontImage?: SortOrder
    idCardBackImage?: SortOrder
    preferredLanguage?: SortOrder
    notificationEnabled?: SortOrder
    coinBalance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type user_profilesAvgOrderByAggregateInput = {
    coinBalance?: SortOrder
  }

  export type user_profilesMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    idCardNumber?: SortOrder
    dateOfBirth?: SortOrder
    address?: SortOrder
    email?: SortOrder
    lineId?: SortOrder
    idCardFrontImage?: SortOrder
    idCardBackImage?: SortOrder
    preferredLanguage?: SortOrder
    notificationEnabled?: SortOrder
    coinBalance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type user_profilesMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    idCardNumber?: SortOrder
    dateOfBirth?: SortOrder
    address?: SortOrder
    email?: SortOrder
    lineId?: SortOrder
    idCardFrontImage?: SortOrder
    idCardBackImage?: SortOrder
    preferredLanguage?: SortOrder
    notificationEnabled?: SortOrder
    coinBalance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type user_profilesSumOrderByAggregateInput = {
    coinBalance?: SortOrder
  }

  export type Enumusers_userTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.users_userType | Enumusers_userTypeFieldRefInput<$PrismaModel>
    in?: $Enums.users_userType[]
    notIn?: $Enums.users_userType[]
    not?: NestedEnumusers_userTypeFilter<$PrismaModel> | $Enums.users_userType
  }

  export type usersOrderByRelevanceInput = {
    fields: usersOrderByRelevanceFieldEnum | usersOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type usersCountOrderByAggregateInput = {
    id?: SortOrder
    phoneNumber?: SortOrder
    pin?: SortOrder
    otpSecret?: SortOrder
    otpEnabled?: SortOrder
    lastOtpSentAt?: SortOrder
    userType?: SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type usersMaxOrderByAggregateInput = {
    id?: SortOrder
    phoneNumber?: SortOrder
    pin?: SortOrder
    otpSecret?: SortOrder
    otpEnabled?: SortOrder
    lastOtpSentAt?: SortOrder
    userType?: SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type usersMinOrderByAggregateInput = {
    id?: SortOrder
    phoneNumber?: SortOrder
    pin?: SortOrder
    otpSecret?: SortOrder
    otpEnabled?: SortOrder
    lastOtpSentAt?: SortOrder
    userType?: SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type Enumusers_userTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.users_userType | Enumusers_userTypeFieldRefInput<$PrismaModel>
    in?: $Enums.users_userType[]
    notIn?: $Enums.users_userType[]
    not?: NestedEnumusers_userTypeWithAggregatesFilter<$PrismaModel> | $Enums.users_userType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumusers_userTypeFilter<$PrismaModel>
    _max?: NestedEnumusers_userTypeFilter<$PrismaModel>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type Enumadmin_permissions_permissionFieldUpdateOperationsInput = {
    set?: $Enums.admin_permissions_permission
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type Enumadmins_roleFieldUpdateOperationsInput = {
    set?: $Enums.admins_role
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type Enumcoin_transactions_typeFieldUpdateOperationsInput = {
    set?: $Enums.coin_transactions_type
  }

  export type Enumloan_applications_loanTypeFieldUpdateOperationsInput = {
    set?: $Enums.loan_applications_loanType
  }

  export type Enumloan_applications_statusFieldUpdateOperationsInput = {
    set?: $Enums.loan_applications_status
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type Enumloans_loanTypeFieldUpdateOperationsInput = {
    set?: $Enums.loans_loanType
  }

  export type Enumloans_statusFieldUpdateOperationsInput = {
    set?: $Enums.loans_status
  }

  export type Enumnotifications_typeFieldUpdateOperationsInput = {
    set?: $Enums.notifications_type
  }

  export type Enumpayments_paymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.payments_paymentMethod
  }

  export type Enumpayments_statusFieldUpdateOperationsInput = {
    set?: $Enums.payments_status
  }

  export type Enumreward_redemptions_statusFieldUpdateOperationsInput = {
    set?: $Enums.reward_redemptions_status
  }

  export type Enumdocuments_docTypeFieldUpdateOperationsInput = {
    set?: $Enums.documents_docType
  }

  export type Enumdocument_title_lists_docTypeFieldUpdateOperationsInput = {
    set?: $Enums.document_title_lists_docType
  }

  export type land_account_logsCreateNestedManyWithoutLandAccountInput = {
    create?: XOR<land_account_logsCreateWithoutLandAccountInput, land_account_logsUncheckedCreateWithoutLandAccountInput> | land_account_logsCreateWithoutLandAccountInput[] | land_account_logsUncheckedCreateWithoutLandAccountInput[]
    connectOrCreate?: land_account_logsCreateOrConnectWithoutLandAccountInput | land_account_logsCreateOrConnectWithoutLandAccountInput[]
    createMany?: land_account_logsCreateManyLandAccountInputEnvelope
    connect?: land_account_logsWhereUniqueInput | land_account_logsWhereUniqueInput[]
  }

  export type land_account_reportsCreateNestedManyWithoutLandAccountInput = {
    create?: XOR<land_account_reportsCreateWithoutLandAccountInput, land_account_reportsUncheckedCreateWithoutLandAccountInput> | land_account_reportsCreateWithoutLandAccountInput[] | land_account_reportsUncheckedCreateWithoutLandAccountInput[]
    connectOrCreate?: land_account_reportsCreateOrConnectWithoutLandAccountInput | land_account_reportsCreateOrConnectWithoutLandAccountInput[]
    createMany?: land_account_reportsCreateManyLandAccountInputEnvelope
    connect?: land_account_reportsWhereUniqueInput | land_account_reportsWhereUniqueInput[]
  }

  export type land_account_logsUncheckedCreateNestedManyWithoutLandAccountInput = {
    create?: XOR<land_account_logsCreateWithoutLandAccountInput, land_account_logsUncheckedCreateWithoutLandAccountInput> | land_account_logsCreateWithoutLandAccountInput[] | land_account_logsUncheckedCreateWithoutLandAccountInput[]
    connectOrCreate?: land_account_logsCreateOrConnectWithoutLandAccountInput | land_account_logsCreateOrConnectWithoutLandAccountInput[]
    createMany?: land_account_logsCreateManyLandAccountInputEnvelope
    connect?: land_account_logsWhereUniqueInput | land_account_logsWhereUniqueInput[]
  }

  export type land_account_reportsUncheckedCreateNestedManyWithoutLandAccountInput = {
    create?: XOR<land_account_reportsCreateWithoutLandAccountInput, land_account_reportsUncheckedCreateWithoutLandAccountInput> | land_account_reportsCreateWithoutLandAccountInput[] | land_account_reportsUncheckedCreateWithoutLandAccountInput[]
    connectOrCreate?: land_account_reportsCreateOrConnectWithoutLandAccountInput | land_account_reportsCreateOrConnectWithoutLandAccountInput[]
    createMany?: land_account_reportsCreateManyLandAccountInputEnvelope
    connect?: land_account_reportsWhereUniqueInput | land_account_reportsWhereUniqueInput[]
  }

  export type land_account_logsUpdateManyWithoutLandAccountNestedInput = {
    create?: XOR<land_account_logsCreateWithoutLandAccountInput, land_account_logsUncheckedCreateWithoutLandAccountInput> | land_account_logsCreateWithoutLandAccountInput[] | land_account_logsUncheckedCreateWithoutLandAccountInput[]
    connectOrCreate?: land_account_logsCreateOrConnectWithoutLandAccountInput | land_account_logsCreateOrConnectWithoutLandAccountInput[]
    upsert?: land_account_logsUpsertWithWhereUniqueWithoutLandAccountInput | land_account_logsUpsertWithWhereUniqueWithoutLandAccountInput[]
    createMany?: land_account_logsCreateManyLandAccountInputEnvelope
    set?: land_account_logsWhereUniqueInput | land_account_logsWhereUniqueInput[]
    disconnect?: land_account_logsWhereUniqueInput | land_account_logsWhereUniqueInput[]
    delete?: land_account_logsWhereUniqueInput | land_account_logsWhereUniqueInput[]
    connect?: land_account_logsWhereUniqueInput | land_account_logsWhereUniqueInput[]
    update?: land_account_logsUpdateWithWhereUniqueWithoutLandAccountInput | land_account_logsUpdateWithWhereUniqueWithoutLandAccountInput[]
    updateMany?: land_account_logsUpdateManyWithWhereWithoutLandAccountInput | land_account_logsUpdateManyWithWhereWithoutLandAccountInput[]
    deleteMany?: land_account_logsScalarWhereInput | land_account_logsScalarWhereInput[]
  }

  export type land_account_reportsUpdateManyWithoutLandAccountNestedInput = {
    create?: XOR<land_account_reportsCreateWithoutLandAccountInput, land_account_reportsUncheckedCreateWithoutLandAccountInput> | land_account_reportsCreateWithoutLandAccountInput[] | land_account_reportsUncheckedCreateWithoutLandAccountInput[]
    connectOrCreate?: land_account_reportsCreateOrConnectWithoutLandAccountInput | land_account_reportsCreateOrConnectWithoutLandAccountInput[]
    upsert?: land_account_reportsUpsertWithWhereUniqueWithoutLandAccountInput | land_account_reportsUpsertWithWhereUniqueWithoutLandAccountInput[]
    createMany?: land_account_reportsCreateManyLandAccountInputEnvelope
    set?: land_account_reportsWhereUniqueInput | land_account_reportsWhereUniqueInput[]
    disconnect?: land_account_reportsWhereUniqueInput | land_account_reportsWhereUniqueInput[]
    delete?: land_account_reportsWhereUniqueInput | land_account_reportsWhereUniqueInput[]
    connect?: land_account_reportsWhereUniqueInput | land_account_reportsWhereUniqueInput[]
    update?: land_account_reportsUpdateWithWhereUniqueWithoutLandAccountInput | land_account_reportsUpdateWithWhereUniqueWithoutLandAccountInput[]
    updateMany?: land_account_reportsUpdateManyWithWhereWithoutLandAccountInput | land_account_reportsUpdateManyWithWhereWithoutLandAccountInput[]
    deleteMany?: land_account_reportsScalarWhereInput | land_account_reportsScalarWhereInput[]
  }

  export type land_account_logsUncheckedUpdateManyWithoutLandAccountNestedInput = {
    create?: XOR<land_account_logsCreateWithoutLandAccountInput, land_account_logsUncheckedCreateWithoutLandAccountInput> | land_account_logsCreateWithoutLandAccountInput[] | land_account_logsUncheckedCreateWithoutLandAccountInput[]
    connectOrCreate?: land_account_logsCreateOrConnectWithoutLandAccountInput | land_account_logsCreateOrConnectWithoutLandAccountInput[]
    upsert?: land_account_logsUpsertWithWhereUniqueWithoutLandAccountInput | land_account_logsUpsertWithWhereUniqueWithoutLandAccountInput[]
    createMany?: land_account_logsCreateManyLandAccountInputEnvelope
    set?: land_account_logsWhereUniqueInput | land_account_logsWhereUniqueInput[]
    disconnect?: land_account_logsWhereUniqueInput | land_account_logsWhereUniqueInput[]
    delete?: land_account_logsWhereUniqueInput | land_account_logsWhereUniqueInput[]
    connect?: land_account_logsWhereUniqueInput | land_account_logsWhereUniqueInput[]
    update?: land_account_logsUpdateWithWhereUniqueWithoutLandAccountInput | land_account_logsUpdateWithWhereUniqueWithoutLandAccountInput[]
    updateMany?: land_account_logsUpdateManyWithWhereWithoutLandAccountInput | land_account_logsUpdateManyWithWhereWithoutLandAccountInput[]
    deleteMany?: land_account_logsScalarWhereInput | land_account_logsScalarWhereInput[]
  }

  export type land_account_reportsUncheckedUpdateManyWithoutLandAccountNestedInput = {
    create?: XOR<land_account_reportsCreateWithoutLandAccountInput, land_account_reportsUncheckedCreateWithoutLandAccountInput> | land_account_reportsCreateWithoutLandAccountInput[] | land_account_reportsUncheckedCreateWithoutLandAccountInput[]
    connectOrCreate?: land_account_reportsCreateOrConnectWithoutLandAccountInput | land_account_reportsCreateOrConnectWithoutLandAccountInput[]
    upsert?: land_account_reportsUpsertWithWhereUniqueWithoutLandAccountInput | land_account_reportsUpsertWithWhereUniqueWithoutLandAccountInput[]
    createMany?: land_account_reportsCreateManyLandAccountInputEnvelope
    set?: land_account_reportsWhereUniqueInput | land_account_reportsWhereUniqueInput[]
    disconnect?: land_account_reportsWhereUniqueInput | land_account_reportsWhereUniqueInput[]
    delete?: land_account_reportsWhereUniqueInput | land_account_reportsWhereUniqueInput[]
    connect?: land_account_reportsWhereUniqueInput | land_account_reportsWhereUniqueInput[]
    update?: land_account_reportsUpdateWithWhereUniqueWithoutLandAccountInput | land_account_reportsUpdateWithWhereUniqueWithoutLandAccountInput[]
    updateMany?: land_account_reportsUpdateManyWithWhereWithoutLandAccountInput | land_account_reportsUpdateManyWithWhereWithoutLandAccountInput[]
    deleteMany?: land_account_reportsScalarWhereInput | land_account_reportsScalarWhereInput[]
  }

  export type land_accountsCreateNestedOneWithoutLogsInput = {
    create?: XOR<land_accountsCreateWithoutLogsInput, land_accountsUncheckedCreateWithoutLogsInput>
    connectOrCreate?: land_accountsCreateOrConnectWithoutLogsInput
    connect?: land_accountsWhereUniqueInput
  }

  export type land_accountsUpdateOneRequiredWithoutLogsNestedInput = {
    create?: XOR<land_accountsCreateWithoutLogsInput, land_accountsUncheckedCreateWithoutLogsInput>
    connectOrCreate?: land_accountsCreateOrConnectWithoutLogsInput
    upsert?: land_accountsUpsertWithoutLogsInput
    connect?: land_accountsWhereUniqueInput
    update?: XOR<XOR<land_accountsUpdateToOneWithWhereWithoutLogsInput, land_accountsUpdateWithoutLogsInput>, land_accountsUncheckedUpdateWithoutLogsInput>
  }

  export type land_accountsCreateNestedOneWithoutReportsInput = {
    create?: XOR<land_accountsCreateWithoutReportsInput, land_accountsUncheckedCreateWithoutReportsInput>
    connectOrCreate?: land_accountsCreateOrConnectWithoutReportsInput
    connect?: land_accountsWhereUniqueInput
  }

  export type land_accountsUpdateOneRequiredWithoutReportsNestedInput = {
    create?: XOR<land_accountsCreateWithoutReportsInput, land_accountsUncheckedCreateWithoutReportsInput>
    connectOrCreate?: land_accountsCreateOrConnectWithoutReportsInput
    upsert?: land_accountsUpsertWithoutReportsInput
    connect?: land_accountsWhereUniqueInput
    update?: XOR<XOR<land_accountsUpdateToOneWithWhereWithoutReportsInput, land_accountsUpdateWithoutReportsInput>, land_accountsUncheckedUpdateWithoutReportsInput>
  }

  export type Enumusers_userTypeFieldUpdateOperationsInput = {
    set?: $Enums.users_userType
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumadmin_permissions_permissionFilter<$PrismaModel = never> = {
    equals?: $Enums.admin_permissions_permission | Enumadmin_permissions_permissionFieldRefInput<$PrismaModel>
    in?: $Enums.admin_permissions_permission[]
    notIn?: $Enums.admin_permissions_permission[]
    not?: NestedEnumadmin_permissions_permissionFilter<$PrismaModel> | $Enums.admin_permissions_permission
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumadmin_permissions_permissionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.admin_permissions_permission | Enumadmin_permissions_permissionFieldRefInput<$PrismaModel>
    in?: $Enums.admin_permissions_permission[]
    notIn?: $Enums.admin_permissions_permission[]
    not?: NestedEnumadmin_permissions_permissionWithAggregatesFilter<$PrismaModel> | $Enums.admin_permissions_permission
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumadmin_permissions_permissionFilter<$PrismaModel>
    _max?: NestedEnumadmin_permissions_permissionFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumadmins_roleFilter<$PrismaModel = never> = {
    equals?: $Enums.admins_role | Enumadmins_roleFieldRefInput<$PrismaModel>
    in?: $Enums.admins_role[]
    notIn?: $Enums.admins_role[]
    not?: NestedEnumadmins_roleFilter<$PrismaModel> | $Enums.admins_role
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumadmins_roleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.admins_role | Enumadmins_roleFieldRefInput<$PrismaModel>
    in?: $Enums.admins_role[]
    notIn?: $Enums.admins_role[]
    not?: NestedEnumadmins_roleWithAggregatesFilter<$PrismaModel> | $Enums.admins_role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumadmins_roleFilter<$PrismaModel>
    _max?: NestedEnumadmins_roleFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumcoin_transactions_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.coin_transactions_type | Enumcoin_transactions_typeFieldRefInput<$PrismaModel>
    in?: $Enums.coin_transactions_type[]
    notIn?: $Enums.coin_transactions_type[]
    not?: NestedEnumcoin_transactions_typeFilter<$PrismaModel> | $Enums.coin_transactions_type
  }

  export type NestedEnumcoin_transactions_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.coin_transactions_type | Enumcoin_transactions_typeFieldRefInput<$PrismaModel>
    in?: $Enums.coin_transactions_type[]
    notIn?: $Enums.coin_transactions_type[]
    not?: NestedEnumcoin_transactions_typeWithAggregatesFilter<$PrismaModel> | $Enums.coin_transactions_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumcoin_transactions_typeFilter<$PrismaModel>
    _max?: NestedEnumcoin_transactions_typeFilter<$PrismaModel>
  }

  export type NestedEnumloan_applications_loanTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.loan_applications_loanType | Enumloan_applications_loanTypeFieldRefInput<$PrismaModel>
    in?: $Enums.loan_applications_loanType[]
    notIn?: $Enums.loan_applications_loanType[]
    not?: NestedEnumloan_applications_loanTypeFilter<$PrismaModel> | $Enums.loan_applications_loanType
  }

  export type NestedEnumloan_applications_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.loan_applications_status | Enumloan_applications_statusFieldRefInput<$PrismaModel>
    in?: $Enums.loan_applications_status[]
    notIn?: $Enums.loan_applications_status[]
    not?: NestedEnumloan_applications_statusFilter<$PrismaModel> | $Enums.loan_applications_status
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedEnumloan_applications_loanTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.loan_applications_loanType | Enumloan_applications_loanTypeFieldRefInput<$PrismaModel>
    in?: $Enums.loan_applications_loanType[]
    notIn?: $Enums.loan_applications_loanType[]
    not?: NestedEnumloan_applications_loanTypeWithAggregatesFilter<$PrismaModel> | $Enums.loan_applications_loanType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumloan_applications_loanTypeFilter<$PrismaModel>
    _max?: NestedEnumloan_applications_loanTypeFilter<$PrismaModel>
  }

  export type NestedEnumloan_applications_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.loan_applications_status | Enumloan_applications_statusFieldRefInput<$PrismaModel>
    in?: $Enums.loan_applications_status[]
    notIn?: $Enums.loan_applications_status[]
    not?: NestedEnumloan_applications_statusWithAggregatesFilter<$PrismaModel> | $Enums.loan_applications_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumloan_applications_statusFilter<$PrismaModel>
    _max?: NestedEnumloan_applications_statusFilter<$PrismaModel>
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumloans_loanTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.loans_loanType | Enumloans_loanTypeFieldRefInput<$PrismaModel>
    in?: $Enums.loans_loanType[]
    notIn?: $Enums.loans_loanType[]
    not?: NestedEnumloans_loanTypeFilter<$PrismaModel> | $Enums.loans_loanType
  }

  export type NestedEnumloans_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.loans_status | Enumloans_statusFieldRefInput<$PrismaModel>
    in?: $Enums.loans_status[]
    notIn?: $Enums.loans_status[]
    not?: NestedEnumloans_statusFilter<$PrismaModel> | $Enums.loans_status
  }

  export type NestedEnumloans_loanTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.loans_loanType | Enumloans_loanTypeFieldRefInput<$PrismaModel>
    in?: $Enums.loans_loanType[]
    notIn?: $Enums.loans_loanType[]
    not?: NestedEnumloans_loanTypeWithAggregatesFilter<$PrismaModel> | $Enums.loans_loanType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumloans_loanTypeFilter<$PrismaModel>
    _max?: NestedEnumloans_loanTypeFilter<$PrismaModel>
  }

  export type NestedEnumloans_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.loans_status | Enumloans_statusFieldRefInput<$PrismaModel>
    in?: $Enums.loans_status[]
    notIn?: $Enums.loans_status[]
    not?: NestedEnumloans_statusWithAggregatesFilter<$PrismaModel> | $Enums.loans_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumloans_statusFilter<$PrismaModel>
    _max?: NestedEnumloans_statusFilter<$PrismaModel>
  }

  export type NestedEnumnotifications_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.notifications_type | Enumnotifications_typeFieldRefInput<$PrismaModel>
    in?: $Enums.notifications_type[]
    notIn?: $Enums.notifications_type[]
    not?: NestedEnumnotifications_typeFilter<$PrismaModel> | $Enums.notifications_type
  }

  export type NestedEnumnotifications_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.notifications_type | Enumnotifications_typeFieldRefInput<$PrismaModel>
    in?: $Enums.notifications_type[]
    notIn?: $Enums.notifications_type[]
    not?: NestedEnumnotifications_typeWithAggregatesFilter<$PrismaModel> | $Enums.notifications_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumnotifications_typeFilter<$PrismaModel>
    _max?: NestedEnumnotifications_typeFilter<$PrismaModel>
  }

  export type NestedEnumpayments_paymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.payments_paymentMethod | Enumpayments_paymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.payments_paymentMethod[]
    notIn?: $Enums.payments_paymentMethod[]
    not?: NestedEnumpayments_paymentMethodFilter<$PrismaModel> | $Enums.payments_paymentMethod
  }

  export type NestedEnumpayments_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.payments_status | Enumpayments_statusFieldRefInput<$PrismaModel>
    in?: $Enums.payments_status[]
    notIn?: $Enums.payments_status[]
    not?: NestedEnumpayments_statusFilter<$PrismaModel> | $Enums.payments_status
  }

  export type NestedEnumpayments_paymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.payments_paymentMethod | Enumpayments_paymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.payments_paymentMethod[]
    notIn?: $Enums.payments_paymentMethod[]
    not?: NestedEnumpayments_paymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.payments_paymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumpayments_paymentMethodFilter<$PrismaModel>
    _max?: NestedEnumpayments_paymentMethodFilter<$PrismaModel>
  }

  export type NestedEnumpayments_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.payments_status | Enumpayments_statusFieldRefInput<$PrismaModel>
    in?: $Enums.payments_status[]
    notIn?: $Enums.payments_status[]
    not?: NestedEnumpayments_statusWithAggregatesFilter<$PrismaModel> | $Enums.payments_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumpayments_statusFilter<$PrismaModel>
    _max?: NestedEnumpayments_statusFilter<$PrismaModel>
  }

  export type NestedEnumreward_redemptions_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.reward_redemptions_status | Enumreward_redemptions_statusFieldRefInput<$PrismaModel>
    in?: $Enums.reward_redemptions_status[]
    notIn?: $Enums.reward_redemptions_status[]
    not?: NestedEnumreward_redemptions_statusFilter<$PrismaModel> | $Enums.reward_redemptions_status
  }

  export type NestedEnumreward_redemptions_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.reward_redemptions_status | Enumreward_redemptions_statusFieldRefInput<$PrismaModel>
    in?: $Enums.reward_redemptions_status[]
    notIn?: $Enums.reward_redemptions_status[]
    not?: NestedEnumreward_redemptions_statusWithAggregatesFilter<$PrismaModel> | $Enums.reward_redemptions_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumreward_redemptions_statusFilter<$PrismaModel>
    _max?: NestedEnumreward_redemptions_statusFilter<$PrismaModel>
  }

  export type NestedEnumdocuments_docTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.documents_docType | Enumdocuments_docTypeFieldRefInput<$PrismaModel>
    in?: $Enums.documents_docType[]
    notIn?: $Enums.documents_docType[]
    not?: NestedEnumdocuments_docTypeFilter<$PrismaModel> | $Enums.documents_docType
  }

  export type NestedEnumdocuments_docTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.documents_docType | Enumdocuments_docTypeFieldRefInput<$PrismaModel>
    in?: $Enums.documents_docType[]
    notIn?: $Enums.documents_docType[]
    not?: NestedEnumdocuments_docTypeWithAggregatesFilter<$PrismaModel> | $Enums.documents_docType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumdocuments_docTypeFilter<$PrismaModel>
    _max?: NestedEnumdocuments_docTypeFilter<$PrismaModel>
  }

  export type NestedEnumdocument_title_lists_docTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.document_title_lists_docType | Enumdocument_title_lists_docTypeFieldRefInput<$PrismaModel>
    in?: $Enums.document_title_lists_docType[]
    notIn?: $Enums.document_title_lists_docType[]
    not?: NestedEnumdocument_title_lists_docTypeFilter<$PrismaModel> | $Enums.document_title_lists_docType
  }

  export type NestedEnumdocument_title_lists_docTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.document_title_lists_docType | Enumdocument_title_lists_docTypeFieldRefInput<$PrismaModel>
    in?: $Enums.document_title_lists_docType[]
    notIn?: $Enums.document_title_lists_docType[]
    not?: NestedEnumdocument_title_lists_docTypeWithAggregatesFilter<$PrismaModel> | $Enums.document_title_lists_docType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumdocument_title_lists_docTypeFilter<$PrismaModel>
    _max?: NestedEnumdocument_title_lists_docTypeFilter<$PrismaModel>
  }

  export type NestedEnumusers_userTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.users_userType | Enumusers_userTypeFieldRefInput<$PrismaModel>
    in?: $Enums.users_userType[]
    notIn?: $Enums.users_userType[]
    not?: NestedEnumusers_userTypeFilter<$PrismaModel> | $Enums.users_userType
  }

  export type NestedEnumusers_userTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.users_userType | Enumusers_userTypeFieldRefInput<$PrismaModel>
    in?: $Enums.users_userType[]
    notIn?: $Enums.users_userType[]
    not?: NestedEnumusers_userTypeWithAggregatesFilter<$PrismaModel> | $Enums.users_userType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumusers_userTypeFilter<$PrismaModel>
    _max?: NestedEnumusers_userTypeFilter<$PrismaModel>
  }

  export type land_account_logsCreateWithoutLandAccountInput = {
    id: string
    detail: string
    amount?: Decimal | DecimalJsLike | number | string
    note?: string | null
    employeeId: number
    employeeName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    deletedAt?: Date | string | null
  }

  export type land_account_logsUncheckedCreateWithoutLandAccountInput = {
    id: string
    detail: string
    amount?: Decimal | DecimalJsLike | number | string
    note?: string | null
    employeeId: number
    employeeName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    deletedAt?: Date | string | null
  }

  export type land_account_logsCreateOrConnectWithoutLandAccountInput = {
    where: land_account_logsWhereUniqueInput
    create: XOR<land_account_logsCreateWithoutLandAccountInput, land_account_logsUncheckedCreateWithoutLandAccountInput>
  }

  export type land_account_logsCreateManyLandAccountInputEnvelope = {
    data: land_account_logsCreateManyLandAccountInput | land_account_logsCreateManyLandAccountInput[]
    skipDuplicates?: boolean
  }

  export type land_account_reportsCreateWithoutLandAccountInput = {
    id: string
    detail: string
    amount?: Decimal | DecimalJsLike | number | string
    note?: string | null
    accountBalance?: Decimal | DecimalJsLike | number | string | null
    employeeId: number
    employeeName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    deletedAt?: Date | string | null
  }

  export type land_account_reportsUncheckedCreateWithoutLandAccountInput = {
    id: string
    detail: string
    amount?: Decimal | DecimalJsLike | number | string
    note?: string | null
    accountBalance?: Decimal | DecimalJsLike | number | string | null
    employeeId: number
    employeeName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    deletedAt?: Date | string | null
  }

  export type land_account_reportsCreateOrConnectWithoutLandAccountInput = {
    where: land_account_reportsWhereUniqueInput
    create: XOR<land_account_reportsCreateWithoutLandAccountInput, land_account_reportsUncheckedCreateWithoutLandAccountInput>
  }

  export type land_account_reportsCreateManyLandAccountInputEnvelope = {
    data: land_account_reportsCreateManyLandAccountInput | land_account_reportsCreateManyLandAccountInput[]
    skipDuplicates?: boolean
  }

  export type land_account_logsUpsertWithWhereUniqueWithoutLandAccountInput = {
    where: land_account_logsWhereUniqueInput
    update: XOR<land_account_logsUpdateWithoutLandAccountInput, land_account_logsUncheckedUpdateWithoutLandAccountInput>
    create: XOR<land_account_logsCreateWithoutLandAccountInput, land_account_logsUncheckedCreateWithoutLandAccountInput>
  }

  export type land_account_logsUpdateWithWhereUniqueWithoutLandAccountInput = {
    where: land_account_logsWhereUniqueInput
    data: XOR<land_account_logsUpdateWithoutLandAccountInput, land_account_logsUncheckedUpdateWithoutLandAccountInput>
  }

  export type land_account_logsUpdateManyWithWhereWithoutLandAccountInput = {
    where: land_account_logsScalarWhereInput
    data: XOR<land_account_logsUpdateManyMutationInput, land_account_logsUncheckedUpdateManyWithoutLandAccountInput>
  }

  export type land_account_logsScalarWhereInput = {
    AND?: land_account_logsScalarWhereInput | land_account_logsScalarWhereInput[]
    OR?: land_account_logsScalarWhereInput[]
    NOT?: land_account_logsScalarWhereInput | land_account_logsScalarWhereInput[]
    id?: StringFilter<"land_account_logs"> | string
    landAccountId?: StringFilter<"land_account_logs"> | string
    detail?: StringFilter<"land_account_logs"> | string
    amount?: DecimalFilter<"land_account_logs"> | Decimal | DecimalJsLike | number | string
    note?: StringNullableFilter<"land_account_logs"> | string | null
    employeeId?: IntFilter<"land_account_logs"> | number
    employeeName?: StringNullableFilter<"land_account_logs"> | string | null
    createdAt?: DateTimeFilter<"land_account_logs"> | Date | string
    updatedAt?: DateTimeFilter<"land_account_logs"> | Date | string
    deletedAt?: DateTimeNullableFilter<"land_account_logs"> | Date | string | null
  }

  export type land_account_reportsUpsertWithWhereUniqueWithoutLandAccountInput = {
    where: land_account_reportsWhereUniqueInput
    update: XOR<land_account_reportsUpdateWithoutLandAccountInput, land_account_reportsUncheckedUpdateWithoutLandAccountInput>
    create: XOR<land_account_reportsCreateWithoutLandAccountInput, land_account_reportsUncheckedCreateWithoutLandAccountInput>
  }

  export type land_account_reportsUpdateWithWhereUniqueWithoutLandAccountInput = {
    where: land_account_reportsWhereUniqueInput
    data: XOR<land_account_reportsUpdateWithoutLandAccountInput, land_account_reportsUncheckedUpdateWithoutLandAccountInput>
  }

  export type land_account_reportsUpdateManyWithWhereWithoutLandAccountInput = {
    where: land_account_reportsScalarWhereInput
    data: XOR<land_account_reportsUpdateManyMutationInput, land_account_reportsUncheckedUpdateManyWithoutLandAccountInput>
  }

  export type land_account_reportsScalarWhereInput = {
    AND?: land_account_reportsScalarWhereInput | land_account_reportsScalarWhereInput[]
    OR?: land_account_reportsScalarWhereInput[]
    NOT?: land_account_reportsScalarWhereInput | land_account_reportsScalarWhereInput[]
    id?: StringFilter<"land_account_reports"> | string
    landAccountId?: StringFilter<"land_account_reports"> | string
    detail?: StringFilter<"land_account_reports"> | string
    amount?: DecimalFilter<"land_account_reports"> | Decimal | DecimalJsLike | number | string
    note?: StringNullableFilter<"land_account_reports"> | string | null
    accountBalance?: DecimalNullableFilter<"land_account_reports"> | Decimal | DecimalJsLike | number | string | null
    employeeId?: IntFilter<"land_account_reports"> | number
    employeeName?: StringNullableFilter<"land_account_reports"> | string | null
    createdAt?: DateTimeFilter<"land_account_reports"> | Date | string
    updatedAt?: DateTimeFilter<"land_account_reports"> | Date | string
    deletedAt?: DateTimeNullableFilter<"land_account_reports"> | Date | string | null
  }

  export type land_accountsCreateWithoutLogsInput = {
    id: string
    accountName: string
    accountBalance?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt: Date | string
    deletedAt?: Date | string | null
    reports?: land_account_reportsCreateNestedManyWithoutLandAccountInput
  }

  export type land_accountsUncheckedCreateWithoutLogsInput = {
    id: string
    accountName: string
    accountBalance?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt: Date | string
    deletedAt?: Date | string | null
    reports?: land_account_reportsUncheckedCreateNestedManyWithoutLandAccountInput
  }

  export type land_accountsCreateOrConnectWithoutLogsInput = {
    where: land_accountsWhereUniqueInput
    create: XOR<land_accountsCreateWithoutLogsInput, land_accountsUncheckedCreateWithoutLogsInput>
  }

  export type land_accountsUpsertWithoutLogsInput = {
    update: XOR<land_accountsUpdateWithoutLogsInput, land_accountsUncheckedUpdateWithoutLogsInput>
    create: XOR<land_accountsCreateWithoutLogsInput, land_accountsUncheckedCreateWithoutLogsInput>
    where?: land_accountsWhereInput
  }

  export type land_accountsUpdateToOneWithWhereWithoutLogsInput = {
    where?: land_accountsWhereInput
    data: XOR<land_accountsUpdateWithoutLogsInput, land_accountsUncheckedUpdateWithoutLogsInput>
  }

  export type land_accountsUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    accountBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reports?: land_account_reportsUpdateManyWithoutLandAccountNestedInput
  }

  export type land_accountsUncheckedUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    accountBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reports?: land_account_reportsUncheckedUpdateManyWithoutLandAccountNestedInput
  }

  export type land_accountsCreateWithoutReportsInput = {
    id: string
    accountName: string
    accountBalance?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt: Date | string
    deletedAt?: Date | string | null
    logs?: land_account_logsCreateNestedManyWithoutLandAccountInput
  }

  export type land_accountsUncheckedCreateWithoutReportsInput = {
    id: string
    accountName: string
    accountBalance?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt: Date | string
    deletedAt?: Date | string | null
    logs?: land_account_logsUncheckedCreateNestedManyWithoutLandAccountInput
  }

  export type land_accountsCreateOrConnectWithoutReportsInput = {
    where: land_accountsWhereUniqueInput
    create: XOR<land_accountsCreateWithoutReportsInput, land_accountsUncheckedCreateWithoutReportsInput>
  }

  export type land_accountsUpsertWithoutReportsInput = {
    update: XOR<land_accountsUpdateWithoutReportsInput, land_accountsUncheckedUpdateWithoutReportsInput>
    create: XOR<land_accountsCreateWithoutReportsInput, land_accountsUncheckedCreateWithoutReportsInput>
    where?: land_accountsWhereInput
  }

  export type land_accountsUpdateToOneWithWhereWithoutReportsInput = {
    where?: land_accountsWhereInput
    data: XOR<land_accountsUpdateWithoutReportsInput, land_accountsUncheckedUpdateWithoutReportsInput>
  }

  export type land_accountsUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    accountBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logs?: land_account_logsUpdateManyWithoutLandAccountNestedInput
  }

  export type land_accountsUncheckedUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    accountBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logs?: land_account_logsUncheckedUpdateManyWithoutLandAccountNestedInput
  }

  export type land_account_logsCreateManyLandAccountInput = {
    id: string
    detail: string
    amount?: Decimal | DecimalJsLike | number | string
    note?: string | null
    employeeId: number
    employeeName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    deletedAt?: Date | string | null
  }

  export type land_account_reportsCreateManyLandAccountInput = {
    id: string
    detail: string
    amount?: Decimal | DecimalJsLike | number | string
    note?: string | null
    accountBalance?: Decimal | DecimalJsLike | number | string | null
    employeeId: number
    employeeName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    deletedAt?: Date | string | null
  }

  export type land_account_logsUpdateWithoutLandAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    detail?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: IntFieldUpdateOperationsInput | number
    employeeName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type land_account_logsUncheckedUpdateWithoutLandAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    detail?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: IntFieldUpdateOperationsInput | number
    employeeName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type land_account_logsUncheckedUpdateManyWithoutLandAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    detail?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: IntFieldUpdateOperationsInput | number
    employeeName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type land_account_reportsUpdateWithoutLandAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    detail?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    accountBalance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    employeeId?: IntFieldUpdateOperationsInput | number
    employeeName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type land_account_reportsUncheckedUpdateWithoutLandAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    detail?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    accountBalance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    employeeId?: IntFieldUpdateOperationsInput | number
    employeeName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type land_account_reportsUncheckedUpdateManyWithoutLandAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    detail?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    accountBalance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    employeeId?: IntFieldUpdateOperationsInput | number
    employeeName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}